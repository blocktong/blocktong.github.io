{"pageProps":{"posts":[{"title":"Claude 3을 VSCode에 코파일럿으로 연결하는 빠르고 쉬운 튜토리얼","description":"","date":"2024-07-01 21:35","slug":"2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial","content":"\n\n![2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_0.png](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_0.png)\n\n안녕하세요! 이번 튜토리얼에서는 Anthropic의 새로운 혁신적인 Claude 3 모델을 사용하여 Visual Studio Code를 Copilot에 연결하는 다양한 방법에 대해 설명하겠습니다.\n\n먼저, VSCode에 설치된 CodeGPT 확장 프로그램이 필요합니다. 아래 링크를 통해 다운로드할 수 있습니다:\n\n또한, VSCode Marketplace에서 직접 확장 프로그램을 검색하고 설치할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*UW94rI4_pqYVJikJDoOZWA.gif)\n\n설치 후에는 Claude 3를 CodeGPT를 통해 사용할 수 있는 다음 3가지 옵션 중 하나를 선택할 수 있습니다.\n\n### #1 — Anthropic API Key\n\n다음 링크를 사용하여 Anthropic에 계정을 생성하십시오: [https://console.anthropic.com/](https://console.anthropic.com/)\n\n<div class=\"content-ad\"></div>\n\n![ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_1](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_1.png)\n\nThen go to the “Get API Keys” menu.\n\n![ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_2](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_2.png)\n\nSelect “Create Key”.\n\n<div class=\"content-ad\"></div>\n\n![image1](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_3.png)\n\nNext, in VSCode, open CodeGPT and select Anthropic as the provider.\n\n![image2](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_4.png)\n\nWhen selecting the model, the extension will prompt you to add your API Key. Paste it and click on “Connect”.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_5.png)\n\n다음으로, Anthropic 서비스를 통해 사용 가능한 Claude 3 모델 중 하나를 선택합니다.\n\n![이미지](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_6.png)\n\n서비스 제작자가 제공하는 API를 통해 직접 Claude 3를 즐기세요.\n\n<div class=\"content-ad\"></div>\n\n# #2 — Amazon Bedrock\n\nAmazon Bedrock을 사용하여 Claude 3를 연결하려면 AWS 계정이 필요합니다. 계정을 만들려면 다음 링크를 방문해주세요: [https://aws.amazon.com/](https://aws.amazon.com/)\n\n![Connecting Claude 3 to VS Code as a Copilot: A Quick and Easy Tutorial](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_7.png)\n\nAWS 계정 내 Bedrock 섹션으로 이동한 후 사용 가능한 모델 섹션에서 Claude 3 모델을 활성화하세요. Bedrock를 구성하여 모델을 활성화하는 방법에 대한 단계별 가이드가 있는 이 기사를 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n모델이 활성화되면 VSCode를 열고 CodeGPT에 액세스하여 제공자로 Bedrock을 선택할 수 있습니다.\n\n![이미지](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_8.png)\n\nAWS 계정의 연결 세부 정보를 추가하세요.\n\n![이미지](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_9.png)\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 모델 선택기에서 Claude 3 모델을 선택하세요.\n\n![Claude 3](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_10.png)\n\n# #3 — CodeGPT Agent\n\nCodeGPT 에이전트를 통해 Claude 3에 액세스하려면 다음 링크에서 무료 계정을 생성해야 합니다: [https://app.codegpt.co](https://app.codegpt.co)\n\n<div class=\"content-ad\"></div>\n\n마켓 플레이스 섹션으로 이동해주세요.\n\n이미지:\n![image1](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_11.png)\n\n마켓 플레이스의 모델 카테고리에서 Claude 3을 검색하고, 클릭한 후 \"이 에이전트 사용해보기\"를 클릭해주세요.\n\n이미지:\n![image2](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_12.png)\n\n<div class=\"content-ad\"></div>\n\n![Connecting Claude 3 to VSCode as a Copilot: A Quick and Easy Tutorial](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_13.png)\n\n이제 VSCode에서 CodeGPT를 열고 공급자로 CodeGPT Plus를 선택하세요.\n\n![Connecting Claude 3 to VSCode as a Copilot: A Quick and Easy Tutorial](/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_14.png)\n\n모델 섹션에서 Claude 3을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n마지막 단계입니다! 이제 Visual Studio Code에서 Copilot으로 사용할 강력한 Claude 3 모델을 즐길 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*5N5PTEBunEqJStJNrbFJcg.gif)","ogImage":{"url":"/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_0.png"},"coverImage":"/assets/img/2024-07-01-ConnectingClaude3toVSCodeasaCopilotAQuickandEasyTutorial_0.png","tag":["Tech"],"readingTime":4},{"title":"Ahrefs가 90 할인으로 수십억 달러 인프라를 구축한 비결","description":"","date":"2024-07-01 21:32","slug":"2024-07-01-HowAhrefsGetsaBillionDollar-WorthInfrastructureWitha90Discount","content":"\n\n싱가포르 데이터 센터에서 3년 동안 4억 달러 이상을 절감한 우리 글이 화제였습니다. 이 글에서는 850대의 동일한 서버가 AWS 대체품에 어떻게 비교되어 한 달간의 지출을 기준으로 설명되었습니다. 이제 우리는 시야를 넓혀서 Ahrefs가 콜로케이션 여정 시작부터 온프레미스 인프라 전체를 클라우드로 전환했다면 총 비용이 어땠을지 고려해보겠습니다.\n\n역사적으로 Ahrefs는 콜로케이션에서 시작하여 OVH, SoftLayer, Hetzner 등의 호스팅 제공업체를 이용하게 되었습니다. 2017년에 회사는 콜로케이션으로 돌아가 그 이후 이 방식을 확대해왔습니다. 본 리뷰는 2017년 7월 1일부터 2023년 6월 30일까지 6년간의 실제 콜로케이션 관련 비용을 다루며, 데이터 센터에서 발생한 모든 지출을 월별로 그룹화하고 역사적인 월간 지출 그래프를 작성했습니다.\n\n그래프의 하늘색 바에는 월별 일반적인 비용인 약정된 전력, 전력 소비, 인터넷 서비스 요금 및 랙, 전력 분배 시스템, 생체 인식 접근 등과 같은 일회성 비용을 포함한 콜로케이션 비용이 나타납니다. 어두운 파란색 바는 네트워크 및 서버 하드웨어 구매, 그에 따른 라이선스, 지원 및 설치 및 케이블링을 위한 전문 서비스를 나타냅니다.\n\n2023년 초에 우리는 인프라에 대해 최대 단일월 투자를 약 $19백만에 하였습니다. 아래에서 해당 시간에 주문된 일부 서버를 살펴볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-07-01-HowAhrefsGetsaBillionDollar-WorthInfrastructureWitha90Discount_0.png)\n\n자, 이제 확대해서 2017년 이후 당사의 온프레미스 지출을 살펴보겠습니다. 매월 발생하는 지출 막대의 급격한 증가는 누적 지출 그래프에서 뚜렷한 증가와 일치합니다.\n\n총적으로, Ahrefs는 2017년 이후 자사의 온프레미스 인프라를 지원하기 위해 1억 2,200만 달러를 지출했습니다. 이는 회사에게 주요 비용 요소가 되었습니다.\n\n이제 이것을 월별로 사용한 서버 및 저장소에 대한 AWS 교체 비용과 비교해보겠습니다. AWS는 두 가지 주요 유형의 EC2 인스턴스를 제공합니다:\n\n<div class=\"content-ad\"></div>\n\n- AWS 온디맨드: 이 옵션은 기본적이고 할인되지 않은 시간당 요금을 가장 유연하게 제공합니다.\n- AWS 3년간 예약 인스턴스 선불: 이것은 3년의 약정과 선불 결제가 필요한 가장 비용 효율적인 선택지입니다.\n\n우리가 서버용으로 EC2 인스턴스, 저장용으로 EBS, 그리고 기본 가정들을 선택한 방법에 대한 더 자세한 정보는 글의 끝에 있는 부록을 참조해주세요.\n\n비교를 완전히 설명하기 위해 동등한 AWS 지출을 표시하기 위해 10배 확대해야 합니다.\n\n놀랍게도, 두 AWS 옵션 모두 10억 달러 미만의 가격표를 얻을 수 없으며, Ahrefs는 비용을 약 10배 낮게 유지할 수 있었습니다. 클라우드 비용에 빠져들지 않고 남은 10억 달러로 어마어마한 가능성을 상상해보세요.\n\n<div class=\"content-ad\"></div>\n\n- 페이스북이 인스타그램을 10억 달러에 인수한 것을 따라할 수 있는 회사가 있을까요?\n- 혹시 10억 7000만 달러로 가치가 평가된 Air New Zealand을 인수하여 항공 산업에 진출할 수 있을까요?\n- 혹시 15억 달러로 버즈 할리파처럼 기록을 세울만한 건축 기적을 건설할 수 있을까요?\n- 아니면 더 실용적으로, 아마존과 비슷한 10억 달러에 1GW 원자력 데이터 센터를 구입하고 클라우드 제공 업체들에 임대하거나 재판매하여 이익을 올릴 수도 있지 않을까요?\n\n재정 격차는 경고를 넘어서 깨달음의 기회입니다.\n\n2017년 에아프스가 콜로케이션을 추구하는 대신 트렌디한 클라우드 솔루션을 택했다면, 오늘날 회사는 존재하지 않았을지도 모릅니다. 이익 창출은 물론이고 매번 클라우드 비용을 줄이기 위해 애쓰고, 클라우드에 특화된 최적화와 전략에 상당한 시간과 노력을 들일 것입니다. 그러나 위의 그래프에서 보여준 대로, Ahrefs의 인프라에서는 요금이 가장 비싼 온디맨드 서비스부터 \"할인율 최대 60%에 달하는\" 3년 선납 예약 인스턴스까지의 두 가지 최적화 방법이 장기적으로 큰 차이를 보이지 않는 것으로 나타납니다. 아마도 성능을 유지하기 위해 서버를 정기적으로 추가하고 수백 페타바이트의 빠른 SSD 스토리지를 활용하기 때문에 사전 예약 인스턴스의 할인 혜택이 드러나지 않을 수도 있나요?\n\n하지만 알아봅시다. 만약 인프라를 현재 상태로 유지하고 미래를 전망해보자면 어떨까요? 우리가 이전과 똑같은 구성 요소를 추가하거나 제거하지 않고, 2023년 6월 30일 현재의 월별 비용을 계속 지불한다고 가정해봅시다. 전체 범위를 보기 위해 좀 더 확대해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n서버 네이티브 방식으로 최적화하지 않은 거야!\n\n어떤 사람들은 \"사용한 만큼 지불하기\" 원칙을 광범위하게 홍보하는 서버리스 아키텍처로의 전환을 지지해왔습니다. 이 방식은 자주 사용되지 않는 자원이나 가벼운 부하를 갖는 자원에 효과적일 수 있습니다. 그러나 아마존 프라임 비디오 팀은 AWS 서버리스에서 EC2 및 ECS 플랫폼으로의 전환이 자체적 으로 무거운 부하를 갖는 애플리케이션의 비용을 90% 절감할 수 있었다는 것을 입증했습니다.\n\n<div class=\"content-ad\"></div>\n\nAhrefs에서는 서버리스로 전환하는 아이디어가 설득력이 없다고 생각합니다. 이전에 논의한 850대의 서버는 매달 데이터 홀에서 이용 가능한 총 전력의 86-92%를 사용하여 높은 이용률을 보여주고 있습니다. 이러한 서버는 AWS EC2+EBS와 비교했을 때 비용이 약 1/10 정도 되며, Prime Video의 급격한 비용 절감을 활용함으로써 Ahrefs의 인프라 비용이 서버리스 환경에서 100배 이상 급증할 수 있음이 명백합니다.\n\n또 다른 최적화 제안은 스팟 인스턴스의 사용이었습니다. 그러나 저희는 서버 부하가 계속 높으므로 일관된 안정적인 인스턴스가 필요하며 간헐적인 것이 아닙니다.\n\n마지막 제안은 클라우드 공급업체들과의 큰 규모 할인 협상을 하는 것이었습니다. 이 할인 혜택이 재정적으로 타당하려면 최소 90%의 할인율이 필요하며 비용을 원래의 지출의 10%로 줄여야 합니다. 이 글이 도움이 되어 더 나은 설명을 하는 데 도움이 되기를 바랍니다.\n\n# 그런데 사람들은 어떻게 될까요?!\n\n<div class=\"content-ad\"></div>\n\n이전 글에는 다음과 같이 요약할 수 있는 많은 댓글이 달렸습니다:\n\n\"사람 비용은 당신의 계산에 포함되지 않았습니다! 실패하는 하드웨어를 지원하기 위해 다양한 기술을 가진 많은 사람이 필요합니다! 그들 없이 당신의 수학과 결론은 완전히 틀렸습니다!\"\n\n저희는 인력 비용을 계산에 포함시키지 않았는데, 그들이 전체적인 재정 결과에 큰 영향을 미치지 않기 때문입니다. Ahrefs의 모든 서버는 다양한 콜로케이션 데이터 센터, 호스팅 제공업체, AWS 클라우드에 걸쳐 효과적으로 11명의 소규모 팀에 의해 관리됩니다. 이 그룹은 인프라 및 SRE 엔지니어, 데이터 센터 기술자, 그리고 이 글의 저자로 구성되어 있습니다. 이러한 숙련된 전문가들은 다양한 환경에서 여러 해 동안 서버, 네트워크, 운영 체제 및 다중 소프트웨어 시스템을 관리, 유지, 업그레이드 및 문제 해결해 왔습니다.\n\n2023년 6월에는 검토 기간 중 최대 서버 수를 가졌습니다. 그 달, 저희 팀은 3300대 서버에서 94건의 하드웨어 문제에 대응하여 매일 평균 약 네 건의 문제를 처리하는 능력을 보여주었습니다.\n\n<div class=\"content-ad\"></div>\n\n![How Ahrefs Gets a Billion-Dollar-Worth Infrastructure With a 90% Discount](/assets/img/2024-07-01-HowAhrefsGetsaBillionDollar-WorthInfrastructureWitha90Discount_1.png)\n\nBut hey, let's consider the idea that Ahrefs may not be managing things optimally. Picture a scenario where we have to significantly increase our workforce to maintain our 3300 physical servers, which are not cloud-based and are prone to issues. The theory is that by expanding our team to manage colocation servers, cloud solutions could become more beneficial compared to our current setup.\n\nImagine putting together a comprehensive team for server hardware support. This team would consist of DevOps specialists, hardware engineers, data center technicians, solution architects, NOC and SOC staff for network and security operations, along with procurement, project, capacity, asset, delivery, sustainability, and diversity managers. Add in team leads, vice presidents, senior vice presidents, recruiters, and HR business partners to oversee. Let’s say we overlook some essential roles and round up the hiring to 120 professionals solely focused on server support. Considering our company had around 120 employees as of June 2023, this hiring spree would double the company's size.\n\nNow, let’s be generous and say these new hires earn an average annual salary of $500,000 each. So, the total annual cost for this \"dream team\" would amount to $60 million, reaching $360 million over six years. Interestingly, this figure is triple what we've spent on our entire infrastructure so far. Well, that's how the math adds up.\n\n<div class=\"content-ad\"></div>\n\n이제 우리가 $122백만의 인프라 비용과 이 정말 비싼 팀을 합치면 합계가 $482백만이 됩니다. 이 광적으로 비싼 그리고 과도하게 자격이 높은 가상의 팀은 갖춰진 모든 기술을 가지고 있지만, 우리의 하드웨어를 소유하는 비용은 가장 저렴한 클라우드 옵션의 절반 비용에 불과합니다. 물론, 이에는 인력 비용이 포함되어 있지 않습니다. 클라우드 서비스도 인간의 감독을 필요로 합니다만, 우리는 우리의 계산에서 제외했습니다.\n\n우리가 코로케이션 설정을 지원하기 위해 스태프를 강화하는 것이 재정적으로 어렵고 클라우드가 더 유리하다는 우리의 가설은 틀렸음을 확인했습니다.\n\n우리의 클라우드, 호스팅 및 코로케이션을 처리하는 실제 팀은 훨씬 작아요. 여기에 덧붙여 확장을 위해 채용을 진행 중이니 곧 더 많은 서버를 처리할 수 있을 거에요.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n인프라에 대한 콜로케이션 선택은 Ahrefs에게 옳은 결정이었습니다. 지난 6년을 되돌아볼 때, 우리의 자사 서버와 네트워크를 갖춘 데이터 센터는 1억 2천만 달러가 들었는데, 이 금액은 가장 저렴한 AWS 클라우드 옵션을 선택했다면 견자흔한 110억 달러에 이르렀을 것입니다. 강력한 온프렘 서버 덕분에 우리 개발자들은 제품을 향상시키는 데 집중할 수 있었고, 클라우드 비용을 최적화하느라 어렵게 지치지 않았습니다.\n\n마음을 잘못 이해하지 마세요. 특히 AWS 같은 클라우드 기술은 빠른 배포에 뛰어나므로 프로토타입 생성, 신속한 테스트, 또는 글로벌 엣지 인프라 배포와 같은 긴급한 프로젝트를 위한 이상적인 선택입니다. 또 다른 중요한 장점은 시간과 위험을 최소화할 수 있는 능력으로, 즉시 서버 접속을 제공하며 물리적 설치의 관리절차와 지연을 피할 수 있습니다. 새 서버나 데이터 센터를 기다릴 수 없다면 클라우드는 여전히 유효한 옵션일지도 모릅니다.\n\n클라우드 서비스 제공업체들은 클라우드를 단일로서 유일한 인프라 솔루션으로 강력하게 마케팅하면서 제품 비교를 복잡하게 하고 지각된 이점을 강조합니다. 그러나 콜로케이션 인프라와의 장기 비교를 통해 지속적인 클라우드 사용이 지나치게 비쌉니다. 이는 보편적인 해결책으로서의 적합성을 의심시킵니다.\n\n아마 기업에게 클라우드는 사람에게 약물과 같이 고려되어야 할까요? 약물로서 클라우드는 단기적이고 좁은 적용 분야를 위해 극도로 유용할 수 있으며, 기업의 성과를 향상시키고 큰 이득을 가져올 수 있습니다. 그러나 장기적으로 너무 많은 비용을 소진할 수 있으며, 기업에 해를 끼칠 수 있고 파산으로 이어질 수도 있습니다. 어떤 약물이나 클라우드를 적당량으로 책임 있게 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n## 부록. 가정과 계산\n\n우선, 우리는 콜로케이션 데이터 센터에서의 송장을 통합하고 분석했습니다. 그런 다음 비교를 위해 가능한 최대한 AWS와 가장 비슷한 서비스를 선택했습니다. EC2 및 EBS 서비스의 가격은 검토 기간의 끝부분부터 AWS 요금을 사용했습니다. 우리는 Ahrefs 서버의 위치와 가장 가까운 지역 또는 가장 가까운 지리적 대체물을 선택하여 가격을 결정했습니다. 그런 다음 매달 우리 데이터 센터의 특정 서버 수에 기초하여 AWS 대안의 금액을 계산했습니다.\n\n저희 서버에 적합한 EC2 대안을 찾는 것은 항상 쉬운 일이 아니었습니다. 우리 서버 대부분은 3세대마다 듀얼 AMD 64코어/128스레드 CPU, 1.5TB 또는 2TB의 RAM 및 복수의 15TB NVMe SSD 드라이브로 구성되어 있습니다. AWS EC2에서 가장 가까운 옵션은 i3en.metal 인스턴스였으며, 주로 8개의 7.5TB NVMe SSD 드라이브로 선택되었습니다. 그럼에도 불구하고, 당사 서버 하나의 CPU, RAM 및 SSD 리소스와 일치시키기 위해서는 2배에서 3.5배의 i3en.metal 인스턴스가 필요했습니다.\n\n저장 공간에 대해서는 가능한 경우 EC2 인스턴스 내부 SSD 및 HDD를 사용하고 추가 스토리지 필요 사항은 가장 비용 효율적인 AWS gp2(SSD) 및 sc1(HDD) 스토리지 옵션으로 보충했습니다. 우리는 용량을 기반으로 드라이브를 매칭하고 IOPS 비용과 AWS EBS 스토리지의 상대적으로 느린 성능을 무시했습니다. 예를 들어, AWS gp2 볼륨의 처리량은 250MB/s로 제한되어 있으며, 이는 PCIe Gen3 및 Gen4 NVMe SSD 드라이브의 일반적인 3-7GB/s 속도와 비교했을 때 상당히 느립니다.\n\n<div class=\"content-ad\"></div>\n\n아래 표는 AWS에 대한 추가 고려 사항과 혜택을 설명하고 있습니다. 이러한 부분들은 정확하게 측정하기 어려워서 우리가 감안하여 계산했습니다. EC2와 EBS만을 고려한 AWS의 최소 가치를 추정했으나 실제 수치는 더 높을 것으로 예상됩니다.\n\n\n![링크](/assets/img/2024-07-01-HowAhrefsGetsaBillionDollar-WorthInfrastructureWitha90Discount_2.png)\n\n\nAWS 서버 비용은 서버가 전달된 시점부터 시작됩니다. Ahrefs가 서버를 처음 구입하고 수령을 기다리던 시간은 고려하지 않습니다. 예를 들어, 2023년 3월과 4월에 구매한 서버들은 2023년 8월에야 수령되었습니다. 따라서, 우리 분석에서의 동등한 AWS 지출은 2023년 8월부터 시작됩니다.\n\n\n![링크](/assets/img/2024-07-01-HowAhrefsGetsaBillionDollar-WorthInfrastructureWitha90Discount_3.png)\n\n<div class=\"content-ad\"></div>\n\n최근 피드백에 따르면, 3년 예약형 EC2 인스턴스에서 “모두 선결제”라는 용어가 혼란스러울 수 있다는 지적이 있었습니다. 이러한 인스턴스는 전액을 지불하지만 일반적으로 내부 저장 공간이 충분하지 않아 EBS에 대한 추가 월간 지불이 필요합니다. 따라서 위의 그래프에서 베타 각도가 알파보다 크게 나타나는 경우가 많습니다. 특히 저장 용량이 큰 서버를 포함할 때입니다.","ogImage":{"url":"/assets/img/2024-07-01-HowAhrefsGetsaBillionDollar-WorthInfrastructureWitha90Discount_0.png"},"coverImage":"/assets/img/2024-07-01-HowAhrefsGetsaBillionDollar-WorthInfrastructureWitha90Discount_0.png","tag":["Tech"],"readingTime":9},{"title":"상속보다 컴포지션을 선호해야 하는 이유 논란의 중심을 파헤치다","description":"","date":"2024-07-01 21:30","slug":"2024-07-01-CompositionOverInheritanceAControversialTake","content":"\n\n![Alt text](/assets/img/2024-07-01-CompositionOverInheritanceAControversialTake_0.png)\n\n어느 좋은 날, 새로운 게임을 개발하는 데 몰두하고 있는 당신을 발견합니다. 마음은 상쾌하고 열정적입니다. 여러분은 MonoBehaviours를 빠르게 탐색하며 옛날에 작성한 FPS 컨트롤러와 함께 속속들이 진행되고 있는 프로젝트를 보고 있습니다. 최소한 여러분의 관점에서는 프로젝트가 올바른 방향으로 진행되고 있는 것 같습니다. 그러나 코드를 리팩토링하기 위해 준비할 때, 당신의 복잡한 게임 로직이나 정교한 수학적 표현 내에서가 아니라 게임 디자인 내에서 미묘하지만 익숙한 문제가 발생합니다.\n\n여러분은 선택을 의심하기 시작합니다: “왜 여기에서 상속을 사용했을까?” 혹은 반대의 경우일 수도 있습니다. 사실, 그리고 잘 들어보세요, 모든 개발자는 새 프로젝트를 착수하거나 예전 저장소를 리팩토링할 때마다 이 결정과 마주치게 됩니다. 본 기사에서는 개발 초기 단계에서 직접 경험했던 문제 중 하나에 대해 다루고자 합니다: 상속 대 조립의 딜레마\n\n기본 아이디어\n\n<div class=\"content-ad\"></div>\n\n먼저 상속과 컴포지션의 기본적인 차이점에 대해 알아보겠습니다:\n\n상속은 한 클래스가 다른 클래스를 확장할 때 발생하며, 기능을 상속하고 선택적으로 재정의하거나 자체 기능을 추가합니다.\n\n컴포지션은 클래스가 인터페이스를 구현하고 해당 인터페이스에 정의된 각 메서드에 대한 자체 구현을 제공하는 것을 의미합니다.\n\n상속은 파생된 클래스가 기본 클래스의 동작을 빌드하거나 수정하는 유기적인 개념으로 자주 인식됩니다. 반면에, 컴포지션은 클래스가 다른 클래스나 인터페이스로 구성되어 기능을 달성하는 더 선형적인 개념으로 여겨집니다.\n\n<div class=\"content-ad\"></div>\n\n일부 어린이(파생 클래스)는 부모(베이스 클래스)와 크게 다를 수 있지만, 이러한 행동의 차이는 소프트웨어 아키텍처에 깊은 영향을 끼칠 수 있습니다.\n\n실제로, 상속과 합성 중 어떤 방식을 선택하느냐에 따라 소프트웨어 시스템의 아키텍처에 큰 영향을 줄 수 있습니다.\n\n큰 그림\n\n당신과 같은 상황에서 어떤 접근 방식 - 상속 또는 합성 - 이 더 적합할지 알아보기 위해 한 가지 예시를 살펴보겠습니다. 최근에 저는 Selection System을 구현해야 하는 프로젝트에 참여했습니다. 이 시스템은 플레이어 앞의 객체를 강조하고 선택된 객체를 기반으로 다양한 동작을 트리거하는 액션 버튼을 활성화하는 것이 목표였습니다.\n\n<div class=\"content-ad\"></div>\n\n우선, `Select`, `Deselect`, 그리고 `Take Action` 세 가지 메서드를 포함한 인터페이스를 만들었습니다.\n\n```java\npublic interface ISelectable {\n  public void Select();\n  public void Deselect();\n  public void TakeAction();\n}\n```\n\n그러나 곧 Interface Segregation Principle을 위반한다는 것을 깨달았고, 이를 해결하기 위해 두 개의 인터페이스로 나누었습니다: ISelectable과 IAction. 각 인터페이스에는 각각의 메서드 세트가 포함되어 있었는데, ISelectable에는 `Select`와 `Deselect`가 있고, IAction에는 `Take Action`이 있었습니다.\n\n```java\npublic interface ISelectable {\n  public void Select();\n  public void Deselect();\n}\n\npublic interface IAction {\n  public void TakeAction();\n}\n```\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 문을 선택하고 강조 표시한 후 열기 및 닫기와 같은 동작이 가능합니다. 모든 것이 순조롭게 진행되는 것처럼 보였지만 또 다른 문제가 발생했습니다. ISelectable 인터페이스를 구현하는 거의 모든 게임 오브젝트가 동일한 동작을 수행했습니다. 바로 아웃라인 셰이더에 대한 참조를 가져와 선택 시 활성화하는 것입니다.\n\n이 중복성으로 인해 제가 이러한 목적으로 인터페이스를 사용하는 것에 대해 의문을 품었습니다. 이러한 설계를 위해 추상 클래스를 선택했을 수도 있습니다.\n\n```csharp\npublic abstract class BaseSelect\n{\n\n  //일부 필드 및 속성\n\n  public virtual void Select()\n  {\n    //기본 동작\n  }\n\n  public virtual void Deselect()\n  {\n    //기본 동작\n  }\n}\n```\n\n일부 게임 오브젝트가 선택 시 다르게 작동할 수 있지만, 윤곽선 대신 투명해지는 등 이러한 문제를 상속을 사용하여 해결할 수 있을까요? 놀랍게도, 그 대답은 '아니요'입니다!\n\n<div class=\"content-ad\"></div>\n\n### 마법 같은 말\n\n다수의 상담과 연구 끝에 유산의 주요 문제는 \"물체가 무엇인가\"라는 개념을 중심으로 구축되어 있는 반면, 구성은 \"물체가 무엇을 할 수 있는가\"를 중심으로 구축되어 있다는 것을 발견했습니다.\n\n선택 시 문은 빨갛게 변할 수 있고, 유리는 윤곽을 가질 수 있으며, 무기는 선택 시 빛날 수 있습니다.\n\n다른 관점으로 볼 때 유산은 \"IS A\" 관계를 구성하고, 구성은 \"HAS A\" 관계를 사용한다고 할 수 있지만, 이 해부학은 다양한 예시에서 양쪽 방식으로 표현될 수 있습니다. 예를 들어 남자이므로 나는 인간 클래스에 속한다(유산)고 할 수 있지만, 귀나 머리카락도 가지고 있다(구성)고 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nComposition은 코드 재사용성을 장려하는데, 상속의 경우 대부분 어렵다고 말하기 어려운 부분이 있습니다.\n\n요약\n\n이제 우리 소프트웨어 프로젝트에서 따를 가장 좋은 방법은 무엇인가라는 질문이 제기됩니다. 대부분의 다른 소프트웨어 엔지니어들과 마찬가지로 저는 Composition을 더 선호합니다. 왜냐하면 이는 애플리케이션 아키텍처를 향상시키며 더 유연하며 유닛 테스트에서는 단순히 이길 수 없기 때문입니다. 그러나 더 빠른 구현이 필요할 때, 필드 및 메소드에 암시적으로 액세스 한정자를 제공하고 사용자 지정 생성자 및 소멸자를 작성하고 추상 클래스를 사용하는 경우가 있습니다. 문제는 여러 클래스에서 파생해야 하는 경우 발생합니다(모든 언어가 그것을 지원하는 것은 아닙니다). 상속을 일반적으로 참을 수 없는 이유는 미래를 예측하도록 강요하기 때문입니다. 인간은 항상 변화를 원하고 소프트웨어도 마찬가지이기 때문에 Composition은 코드 변경을 쉽게하고 소프트웨어에서 어떤 중단도없이 변화할 수 있게 합니다.","ogImage":{"url":"/assets/img/2024-07-01-CompositionOverInheritanceAControversialTake_0.png"},"coverImage":"/assets/img/2024-07-01-CompositionOverInheritanceAControversialTake_0.png","tag":["Tech"],"readingTime":4},{"title":"토탈 워 ROME II와 크리에이티브 어셈블리  10년 후 나의 성명서","description":"","date":"2024-07-01 21:21","slug":"2024-07-01-TotalWarROMEIIandCreativeAssemblyMyStatementTenYearsOn","content":"\n\n10년 전, 전체 전쟁: 로마 II의 참상적인 출시 후 커뮤니티에서 증오의 대상으로 여겨졌던 기회가 주어졌습니다. 이로 인해 막대한 개인적 비용을 치뤘습니다. 게임의 문제로 널리 비난을 받고 무능력으로 채용 해지된 것으로 여기는 사람도 많았습니다. 하지만 사실은 저는 게임을 수리하기 위한 노력을 주도했고, 생산과 디자인에 대한 변경을 위해 뒷말로 싸웠습니다. 또한 리더십이 같은 실수를 반복하려고 할 때 회사를 떠났습니다.\n\n최근 Creative Assembly를 둘러싼 사건은 몇 년이 지난 지금에도 제 경험이 여전히 중요하다는 것을 보여줍니다. 이제까지는 침묵을 지켰지만, 이제는 정확한 사실을 밝히는 때입니다.\n\n이 성명은 Creative Assembly나 Sega로부터 지지나 승인받은 바 없습니다. 이는 제 증언으로, 제 개인적 견해를 담고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 배경\n\n저는 소프트웨어 및 게임 개발자로 20년 이상 경력이 있으며, 여러 독립적인 작은 게임부터 대규모 \"AAA\" 게임까지 총 16개의 게임을 만들었습니다. 2009년부터 2014년까지 Creative Assembly에서 Total War 시리즈의 프로그래머로 일했습니다. 나폴레옹: 토탈 워부터 시작하여 작업한 작품은 조군 2, 사무라이의 몰락, 로마 2, 그리고 아틸라까지입니다. 이후 회사를 떠나기 전까지 다룬 작업입니다. 올해 10월에는 제가 떠난 지 10년이 되는데, 대부분의 시간 동안 Total War에 크게 관심을 두지 않았습니다. 그러나 지난 한 해 동안 회사와 관련된 사건들로 인해 곤욕을 겪었습니다. 이곳에서 모두 다 다루지는 않겠지만 쉽게 요약된 내용을 다른 곳에서 찾을 수 있습니다. Total War 제품과 커뮤니티 대우에 오류가 있었고, 플레이어와 코멘테이터들로부터 강한 비판을 받았습니다.\n\n또한 Creative Assembly의 모기업인 세가가 스튜디오에서 수년간 개발 중이었던 주요 1인칭 슈팅 게임 프로젝트인 하이에나스를 발매 직전에 중단했다는 사실을 알게 되었습니다. 이에 이어 회사 내에서 여러 차례의 정리 해고가 진행되었는데, 저를 포함한 일부 전 동료들을 포함한 개발자가 상당 수 해고되었다는 것으로 알려졌습니다.\n\n오랜 기간 Total War 플레이어들은 제 이름을 알 수 있을 것입니다. 왜냐하면 2013년 9월 출시된 Total War: 로마 2의 출시와 함께 대규모 플레이어 반발을 일으킨 게임으로 공개적으로 알려져 있습니다. 이 게임은 상당히 플레이할 수 없는 상태로 출시되었는데 이를 바탕으로 AI에 대한 작업을 논의하던 웹 시리즈 Rally Point 에피소드에 몇 달 전에 출연했었기 때문입니다. 그로 인해 AI와 게임 상태에 대한 많은 비판을 받았습니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-07-01-TotalWarROMEIIandCreativeAssemblyMyStatementTenYearsOn_0.png](/assets/img/2024-07-01-TotalWarROMEIIandCreativeAssemblyMyStatementTenYearsOn_0.png)\n\n안녕하세요! 암호화폐 업계 전문가입니다.\n\n게임의 상태가 제 인터뷰 톤과 대조되는 방식으로 전해짐에 따라 게임과 제가 한 작업을 고의로 왜곡했다는 것처럼 보였고, 'Rally Point' 비디오 자체의 시청자 수가 10만 명 정도로 비교적 적었지만, 일부 리뷰어와 코멘테이터들이 이를 이용하여 수백만 명의 관객들에게 저를 조롱하는 영상을 보여줬습니다. 이 모든 것이 나에게 개인적인 맹비난을 일으켰고, YouTube와 소셜 미디어 전역에서 수많은 분노에 가득한 댓글이나 저를 향한 협박과 폭력 위협을 포함했는데, 이 중 많은 것들은 사실상 \"미국 법 집행 기관적으로 신뢰할 수 있는\" 협박은 아니었지만 제 안전을 위협받을 이유가 있다고 생각한다고 명확히 말해야 합니다. 그 중 일부는 극도로 심각했는데, 한 영상에는 제 얼굴에 칼을 꽂고 불을 붙이는 장면이 포함되어 \"타라, 부도덕한 AI 천재!\"라는 단어가 화면에 깜박였습니다.\n\n제 참여에 대한 비판과 토론은 제가 회사를 떠난 뒤에도 계속되었습니다. 최근에 Creative Assembly의 최신 논란을 살펴보는 동안, 그들의 최근 게임 중 하나에 대한 온라인 리뷰에서 제게 대한 Rome II를 조롱하는 장면이 반복되어 있음을 발견했고, 이 비디오도 상당한 조회수를 기록하고 있습니다. 그래서 이 상황이 과거에 머무르는 것이 아니라, 몇 년이 지난 지금도 제게 계속되는 문제입니다.\n\nRome II 출시 이후 표적이 된 직원은 저만이 아니었지만, 회사에 대한 분노가 특히 제게 집중됐습니다. Creative Assembly 자체를 Rome II의 책임자로 지적해서는 안 된다는 이야기조차 나왔고, 바로 나 때문에 모든 것이 됐다는 싱글 로그 개발자라는 이야기가 나왔었습니다. 이 이야기는 실제로 Creative Assembly에겐 상당히 편리한 것이라고 생각하고, 프로젝트의 실패를 제 내지 않고는 개선될 것이라는 것을 과장한다고 생각합니다. 나를 대버려 버릴 계획을 근거하고 한 대화가 진행된 것이라고 주장하진 않겠지만, 그들은 나에게 올바른 일을 하려는 동기가 없었기 때문에 그 상황을 그냥 그대로 놔두기로 결정했을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그렇다고 해도 전례 없었던 일은 아니었습니다. 2009년에 출시된 Empire: Total War도 매우 안 좋은 상태였는데, 중요한 지도자가 포럼에 글을 올려 전투 AI 프로그래머의 이직이 프로젝트의 어려움 중 하나로 언급하기도 했습니다. 저는 회사에 합류하기 직전이어서 정확히 무슨 일이 있었는지는 설명할 수는 없지만, 이것이 공정하지 않았다는 것을 충분히 알고 있으며, 전투 AI 프로그래머로서 상당한 어려움을 겪은 사람이 단 한 명만은 아니었다는 것을 증명할 수 있습니다. 다른 개발자들을 대변할 자격은 없지만, 비슷한 이유로 퇴사한 사람들이 적어도 몇 명은 나와 비슷한 상황으로 인해 회사를 떠난 것으로 내세울 수 있습니다. 이러한 이유에 대해 자세히 논의할 것입니다.\n\n## 일부 면책 조항\n\n여기에 대한 발언을 신중히 고려한 결과라고 해도 과언이 아닙니다. 일반적인 상황에서는 전 사장에게 곤경을 겪게 하고 싶지 않습니다만, 이 상황은 극도로 극심했기 때문에 행동에 나섭니다. 크리에이티브 어셈블리에서 겪은 심각한 문제, 회사가 내 상황을 다루는 방식, 그리고 내 명예에 입힌 손상 때문입니다. 또한 이러한 문제에 대해 발언함으로써 스튜디오 내의 만성적인 경영 문제에 대해 알리고, 이를 공개에 명확하게 이바지할 수 있다고 믿습니다.\n\n나는 상황에 맞추어 이전 사업주에게 최대한의 예의를 갖추려고 노력할 것입니다. 필요한 주제에 대해 확실히 얘기하기 위해 발언을 한정할 것이며, 이름을 언급하지 않을 것이며, 직책에 대해 애매하게 언급할 것입니다. 미발표 프로젝트나 기업 기밀 같은 내용은 다루지 않을 것입니다. \"지도자\"나 \"경영진\"과 같은 집단을 언급하되, 구체적으로 관여한 개별 인물을 지정하지는 않을 것입니다. 지도자와 경영진은 시간이 흘러 변화하며, 나의 시절에는 없었고 이 발언과 관련된 문제와는 전혀 무관한 현재 회사 내의 지도자들이 분명 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 문장에서 강조된 문제들이 Creative Assembly가 세계 어디에서나 최고로 손꼽히는 재능있는 사람들을 고용한다고 생각합니다. 이런 점들이 이 발언에서 강조된 문제들로 인해 어떤 방식으로든 해치는 것을 의도하지 않습니다. 이 문제들은 주로 경영진의 책임으로 볼 사안이며, 넓은 의미의 개발팀의 책임으로 보지 않습니다. 또한, 여전히 Creative Assembly에서 일하고 있는 친구들도 있어 그들에게 어려움을 끼치고 싶지는 않지만, 제 행동 동기를 이해해 줄 것으로 믿습니다.\n\n이 문장에서는 AI에 대해 많은 논의가 되었고, 최근 몇 년 동안 ChatGPT와 같은 생성적 AI 시스템을 가리키는 \"AI\"에 대해 많은 토론이 있었습니다. 이들은 다른 주제입니다. 여기서 \"AI\"라고 말할 때 일반적인 게임 개발 분야에서 의미하는 것으로, 비 플레이어 캐릭터와 팩션을 제어하는 게임 코드를 의미합니다.\n\n마지막으로, Rome II와 게임의 문제에 대해 많이 언급할 것이지만, 플레이어들을 소왈려하고 싶지 않습니다. Rome II를 좋아하는 경우, 여전히 플레이하는 경우에는 괜찮습니다. 저는 여러분이 틀렸다고 말하러 온 것이 아니기 때문입니다. 그러나 그 게임이 자신의 목표를 기준으로 평가했을 때 여러 면에서 실패했으며, 의심할 여지없이 최악의 출시를 했으며, 그것이 이 글에서 주로 다룰 내용입니다.\n\n# Rally Point Episode 14\n\n<div class=\"content-ad\"></div>\n\n라리 포인트 인터뷰에 대해 이야기해보겠습니다. 대부분의 사람들이 보는 시선은, 개발자이기 때문에 모든 비밀 정보를 알고 있는 것으로 여겨지기 때문에, 그리고 그 결과물이 완전히 망가지기 때문에, 말하는 모든 내용이 사실이 아니라는 것을 알고 있었을 것이라고 생각합니다. 외부에서는 그 상황이 그렇게 보였을지도 모르겠지만, 사실은 그 인터뷰를 한 시점에서 우리가 무엇을 출시할지 전혀 알지 못했습니다. 게임 분야에서 일하시지 않는 사람들은 이런 프로젝트에 참여하고 있으면 실제로 출시까지 몇 달 남은 시점에도 최종 게임이 어떻게 보일지 확실하게 알 수 없다는 사실에 정말 놀랄 것입니다.\n\n저는 회사에서 근무할 당시에, Total War 게임들은 일반적으로 출시 직전 몇 주와 개월에만 완성되었습니다. 대부분의 개발 기간 동안 플레이할 수 없었으며, 로마 2는 거의 전체 기간이 플레이할 수 없는 상태였습니다. 저가 인터뷰한 시점에서는 아직 모든 부분이 조합되고 있었습니다. 주로 게임 내에서가 아닌 특정 테스트 맵에서 전투 AI를 테스트하고 있었으며, 그때 좋은 결과를 보았기 때문에 그 개선점에 대해 공개적으로 이야기할 자신감을 얻었습니다. 그 당시에는 프로젝트가 얼마나 일정이 뒤처진 상태인지 이해할 수 없었고, 팀이 마무리 지을 때 어떤 새로운 문제가 발생할지도 이해하지 못했습니다. 이전에 나폴레옹, 쇼군 2, 그리고 사무라이의 몰락에서 일했는데, 모두 꽤 잘 마무리된 프로젝트였습니다. 로마 2에는 몇 가지 명백한 제작 및 디자인 문제가 있었고, 수정해야 할 버그도 많았지만, 제가 일했던 이전 프로젝트들도 각자의 문제를 안고 많은 노력을 기울여 완성점에 이르렀습니다.\n\n일어난 일은 커뮤니티 팀이 AI 관련 질문을 많이 받아서 답변을 해주고 싶냐고 물어봤고, 저는 동의했습니다. 제가 인터뷰를 강요당했거나 강압당했다고 추측하는 사람들을 봤는데, 저는 전혀 그렇지 않았다는 점을 명확히 하고 싶습니다. 요청을 받았지만 거절할 수도 있었습니다. 저는 내 인식과 프로젝트 진행 상황에 대한 내부 커뮤니케이션을 기반으로, 우리가 쇼군 2와 같은 다른 게임을 출시할 것이라고 믿었습니다.\n\n또한 라리 포인트 출연과 개발의 중요 분야에 참여하는 것이 제가 팀 내에서 어느 정도의 지위를 가지고 있다는 인상을 줬을 수도 있지만, 실제로는 그렇지 않았습니다. 저는 팀 내에 있는 많은 프로그래머 중 한 명이었으며 Total War의 지도부는 아니었습니다 (로마 2 출시 후에야 한 번의 미미한 지도자 임명이 있었습니다). 저는 고위급 결정 사항에 거의 포함되지 않았으며 중요한 제작 또는 창작 결정이 내려지는 회의에는 보통 초대받지 않았습니다. 프로젝트에 영향을 미치는 많은 관리 결정은 제 업무 범위를 벗어나 있었으며, 프로젝트의 상태와 방향을 이해하기 위해 리더쉽에서 온 커뮤니케이션에 크게 의존했습니다.\n\n<div class=\"content-ad\"></div>\n\n프로덕션 이슈의 주요 원인으로 나중에 알게 된 것은 소통 부족이었고, 개발 중에 프로젝트 상태에 대해 전혀 알지 못하게 했다는 것이기도 했습니다. 내 판단으로 집중적인 개발자들에게서 상향식으로 진행 상황에 관한 정보가 흘러들어간 주요한 두 가지 방법이 있었습니다. 첫 번째로 프로덕션 마일스톤이 있었는데, 제 기억으로는 모든 마일스톤이 제 시일 내에 완료되었다고 보고되었지만, 나중에 이들이 QA 부서에 의해 승인되지 않았음을 알게 되었습니다. QA 부서는 게임 테스트 담당인 품질 보증(QA)팀이 마일스톤이 반영된 게임의 상태를 인정하지 않았다는 점을 명확히 보고했습니다. 다시 말해, QA 보고서에도 불구하고 프로덕션 담당자들이 놓친 마일스톤에 대한 보고가 있었다는 것입니다.\n\n두 번째 정보 전달 방식은 마케팅 업데이트로, 브랜드 및 마케팅 담당자들이 게임 비전, 예고편, 행사에서의 긍정적인 반응 등을 다룬 정제된 프레젠테이션을 전달했습니다. 외부 세계에게 게임의 상태와 진행 상황을 전달하는 회사의 동력이 개발자들에게도 방향을 제시했습니다. 이러한 업데이트는 항상 낙관적인 톤을 유지하며 프로젝트가 체계에 따라 진행 중이라는 잘못된 인상을 증폭시켰습니다.\n\n프로덕션, 마케팅 및 리더십이 일반적으로 프로젝트가 일정에서 뒤처진 정도를 이해하고 전달하는 데 계속해서 실패했다고 생각합니다. 제가 완전히 망가진 게임을 출시할 것을 알았다면 절대 인터뷰를 하지 않았을 거예요. 제 동기에 대한 온라인 논쟁이 있었고, 페라리에 타고 달아날 것이라는 장난도 있었습니다. 확실한 사실은 아닙니다. 영국에서 소프트웨어 개발자로 일하며 평균적인 급여를 받았습니다.\n\n모든 이야기를 해봤지만, 인터뷰를 하면서 리더십에 대한 신뢰를 가졌고 내가 해서는 안 될 가정을 했기 때문에 잘못했습니다. 누구를 속이려다니 원하진 않았지만, 분명히 그랬을 것입니다. Rome II를 대변할 결정은 제가 내렸으며, 이에 대해 사과드릴 수밖에 없습니다. 게임에 실망했다면, 그리고 제가 여러분을 속였다는 느낌을 받았다면 정말 죄송합니다. 잘못을 저질렀고, 그에 대해 높은 대가를 치르고 교훈을 얻었습니다. 이 발언이 조금이나마 상황을 개선하는 데 기여할 수 있기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 실제로 무슨 일이 있었나요?\n\n로마 II는 저질로 관리되었습니다. 사실 여기에 토탈 워 팀은 어떤 때보다도 기능이 장애가 있었고, 저는 라리 포인트 인터뷰에서 앉아 참여하는 순간, 팀이 운영되는 방식에 심각한 문제점이 있음을 알고 있었으며, 게임을 완성하기 위해서는 많은 노력과 근로가 필요하다는 것을 알고 있었습니다. 하지만 아직은 이 프로젝트가 추가적인 위험을 초래하는 여러 생산 및 디자인 문제로 고통받고 있음을 이해하지 못했습니다. 이 문제를 보다 깊게 이해한 후에는, 게임 또는 적어도 출시가 초기 계획 단계에서 실패했을 가능성이 있다고 생각하지만, 좋은 리더십 아래에서 프로젝트를 마지막 순간에 구해낼 수도 있었다고 생각합니다. 대신, 심각한 실수들이 나타나 재난으로 이어지게 만들어 마침내 우리를 낙마 궤도로 밀어넣었습니다.\n\n참고: 로마 II와 연관된 이 \"특별한\" 문제가 이전 프로젝트인 엠파이어에서도 발생했을 수 있거나, 저를 떠난 후에도 계속해서 발생했을 수 있지만, 제 경험에 직접 관련된 부분에 대해서만 언급할 수 있습니다.\n\n인터뷰를 한 순간에, 게임의 조각이 아직 결합 중이며 게임은 여전히 거의 플레이할 수 없는 상태였다고 설명했습니다. 이는 이러한 생산 방식이 많은 문제와 그 결과들이 긴 시간 동안 보이지 않은 채로 남아있게 했기 때문에 핵심적인 마지막 달에 한꺼번에 나타날 수 있었던 것이 중요한 요소입니다. 토탈 워 게임들은 보통 이런 식으로 개발되었지만, 로마 II가 플레이 가능해지기 시작한 시기가 다른 게임들에 비해 상당히 늦었기 때문에 우리가 마지막 단계에서 보통보다 적은 시간을 가지게 되었습니다. 이 자체만으로도 게임을 연기해야 할 이유가 충분했지만, Creative Assembly의 경영진은 게임의 런칭 날짜를 계획대로 유지하기로 선택했으며 게임이 거친 출시를 할 것을 알고 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n게임 프로젝트를 계획할 때 가끔 채택되는 방법론 중 하나는 가능한 한 많은 부분이 병렬로 제작되도록 생산 계획을 디자인하고, 그 후 모든 것을 개발 타임라인의 끝 부분에 통합하는 것이다. 이렇게 하면 버그를 수정하고 게임플레이를 균형있게 만들며 마무리를 추가할 충분한 시간이 확보될 수 있도록 한다. 론칭 날짜를 변경하기 어려운 만큼, 이 방법은 종종 \"비행기에서 뛰어내릴 때 낙하산을 중간에 조립해야하는 것\" 같다고 설명되곤 한다. 이론적으로는 이 방식이 더 효율적일 수 있지만, 실제로는 위험하고 오류가 발생하기 쉬울 수 있다. 개발 중 발생한 실수가 충분한 시간이 남아있지 않은 상황에서야 비로소 드러나는 경우가 있기 때문이다. 내 경험상 대부분의 개발자들은 더 이상 이런식으로 작업하지 않지만, 여전히 이 방법으로 진행되는 경우가 있고 많은 게임이 분명히 고장난 채로 출시되는 주된 이유 중 하나라고 생각한다.\n\n다른 대안은 게임이 초기에 플레이 가능하도록 만들고, 그 후 개발 과정에서 기능을 추가하고 변경하는 방식으로 정기적으로 반복하는 것이다. 이렇게 하면 전체 개발 팀이 게임의 상태를 유지하며 기능을 테스트하고 개발 중에 가치 있는 피드백을 제공할 수 있다. 내가 경험한 최고의 프로젝트들은 이렇게 진행되었는데, 디자인과 프로덕션에서 빈번한 반복이 강조되었다. 그러나 Creative Assembly에서는 이런 것이 일어나지 않았다. 어떤 리더십에서는 반복을 낭비라고 보기도 했고 원하지 않았다. 그들은 \"처음부터 바로 제대로 만들자\"고 생각했고, 실수를 바로 잡기 위한 여유를 거의 허용하지 않는 생산 계획이었다. 그래서 게임 개발 중에 만들어진 실수는 대개 게임이 출시된 이후에 패치로 처리되었다.\n\nTotal War의 리더십은 Rome II를 처음부터 제대로 만들 것으로 가정했지만, 많은 부분에서 크게 실패했다. 이 프로젝트는 이전 게임들보다 더 많은 시간과 자원을 가졌으며 Shogun 2라는 견고한 기반에서 시작했기 때문에 사랑받는 Rome: Total War의 후계작에 걸맞은 다듬어진 게임을 만들 수 있는 실질적인 기회가 있었다. 그러나 이 자원은 의심스러운 새로운 기능 목록과 공식 변경에 낭비되었고, 게임을 악화시키고 개발을 복잡하게 만들었으며, 이전 타이틀들의 어렵게 얻은 진전을 폐기하도록 강요했다. 게다가, 경영진은 개발 중에 마케팅 활동에 우선 순위를 두어 자원을 게임 개발보다는 트레일러 제작에 회전시켰다. 리더십이 개발팀의 경고와 조언을 따랐더라면 이러한 문제를 쉽게 피할 수 있었겠지만, 그 대신 중요한 결정들을 고립된 상황에서 내리고 나중에도 이에 대한 책임을 질 수 없었다.\n\n이러한 문제 중 가장 중요한 것들과 Total War 프로젝트에서 흔한 문제들뿐만 아니라 Rome II에만 유니크한 문제들에 대한 구체적인 내용을 공유할 것이다. 그리고 후속 조치에 대한 내 경험을 공유하고 어떻게 관리진이 이 실패를 다루었는지 설명할 것이다. 마지막으로 나는 Creative Assembly를 떠나게 된 Total War: Attila 개발 중 내 경험을 기술할 것이다.\n\n<div class=\"content-ad\"></div>\n\n# 도시 확장\n\n시작하기에 좋은 곳은 프로젝트 말기에 범한 최악의 생산 실수 중 하나입니다. 이 오류는 공성 및 무벽 정찰 전투에서 AI에 중대한 영향을 미쳤으며, 또한 생산, 디자인 및 커뮤니케이션 문제가 제어 불가능할 정도로 중대한 영향을 미쳤음을 보여줍니다. 로마 II는 이전 게임들에서 가지지 않았던 매우 복잡한 공성 및 정찰 전투 환경을 갖추고 있었습니다. 이전 게임에서는 게임 플레이와 AI가 정확하게 작동하기 위해 많은 넓은 공간이 필요했었습니다. 초기 경로 및 병목 현상이 많이 없었습니다. 더 복잡한 환경은 AI가 자신의 부대를 이동하고 배치하는 방법을 이해하는 데 더 어렵고, 그에 대한 계산 시간이 더 많이 필요할 것이라는 것을 의미했습니다.\n\n이를 실현하기 위해, 우리는 AI 메타데이터를 위한 엄격한 레벨 디자인 요구 사항을 합의했습니다. 이 데이터는 지도에 조리되어 AI 내비게이션 그래프를 생성하여 AI가 이러한 환경을 이해하고 직접적으로 관여하는 방법을 도와줍니다. 이는 AI가 사용하기 위해 각지도에 생성된 가시적이지 않은 기하학적 요소였으며, 게임 AI 개발에서 매우 표준적인 것이라고 말해야 합니다. 이는 속임수가 아니며, 복잡한 로마 II 지도를 우리가 가진 제한된 시간과 성능 제약 사항 하에 제공할 수 있는 유일한 방법이었습니다.\n\n[인용된 텍스트 이미지](/assets/img/2024-07-01-TotalWarROMEIIandCreativeAssemblyMyStatementTenYearsOn_1.png)\n\n<div class=\"content-ad\"></div>\n\n프로젝트 초창기에는 카운트가 1인 전투지도만 각 캠페인 도시 당 하나 있을 것으로 결정되었습니다. 사토시 곰노 이상(Shogun 2)에서는 각 도시 마다 여러 사이즈 변형이 있었습니다. 이것은 멋진 기능이었는데, 캠페인 지도에서 도시를 업그레이드하면 전투지도에서도 크기가 커지고 고대 벽과 활을 달수 있는 장소가 많아져서 방어가 더 쉬워졌습니다. 롬 2(Rome II) 개발 대부분의 시기에는 한 지도만으로 개발될 예정이었기 때문에 캠페인 측의 업그레이드 여부와 상관없이 도시 전투마다 동일한 지도가 나오게 될 것이었습니다. 그 결정의 이유는 모르겠지만, 더 많은 디테일이 들어간 수를 적게 하는 것보다 더 적은 수의 지도에 더 많은 시간을 들이는 것이 나을 것이라 판단했던 것 같습니다.\n\n한편, 캠페인 지도에 새롭게 추가되고 있는 주요 기능 중 하나는 도시 확장입니다. 이전 게임들에서는 캠페인 지도에서 도시를 업그레이드할 수 있었지만, 항상 한 개의 타일만 차지했습니다. 이제 롬 2 캠페인에서는 도시가 업그레이드되고 인구가 증가함에 따라 성장하며 점점 더 많은 타일을 차지하기 시작하여 도시가 캠페인 지도와 전투 지도 양쪽에서 성장하는 느낌을 받았습니다. 아쉽게도, 전투와 캠페인 디자인 팀 간에 이러한 변화에 대한 의사소통이 되지 않았고 두 팀이 서로 무엇을 하고 있는지 알지 못했습니다. 프로젝트 막바지에서 리드 캠페인 아티스트와 가 한 대화를 통해 그 사실을 알게되었고, 이 사실을 결정 기관에 알렸을 때 꽤나 당황한 분위기가 되었던 것 같습니다.\n\n이제 도시 확장이 주요 캠페인 기능으로 홍보되고 있지만, 플레이어들은 전투에서 그 변화를 느끼지 못할 것임이 발견되었습니다. 이는 과거 게임들에서 동작했던 방식인데, 이를 전투에까지 적용하기 위해 이미 존재하는 지도마다 세 개의 새 지도를 만들어야 했습니다. 작업량을 효과적으로 네 배로 늘리는 것이기 때문에 이미 초대 엔진 버그 수정과 게임 완성을 위해 초과근무 중이던 프로젝트 막바지에 이 변수들이 현재 유지되거나 제거된다면 어떤 결과를 가져올지는 알 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 결국 결투와 공성 전투에서의 AI는 종종 한 곳에 앉아서 아무 일도 하지 않았고, 플레이어의 행동에 거의 반응하지 않는 경우가 많았습니다. 제가 말하고 싶은 것은 이것이 비활성 AI의 유일한 원인이었다는 것은 아니었습니다. 여전히 AI에 대한 작업이 수행되어야 하고 많은 버그가 수정되어야 했습니다. 그러나 로마 II 출시 초반에 플레이했을 때 비활성 AI를 경험했다면, 이것이 그 이유일 가능성이 높습니다. 이러한 버그는 새로운 지도 변형이 작은 변형이었기 때문에 매우 흔했으며, 보통 캠페인 초기에 자주 마주쳤습니다. 결투와 공성 전투는 가장 일반적인 전투 유형 중 하나이기도 했으므로, 비활성 AI가 플레이어의 처음 경험할 전투일 가능성이 매우 높았습니다. 이러한 버그들을 찾고 수정하는 데는 수개월이 걸렸으며, 실제 지도 자체를 서두르는 데 소비된 시간보다 더 오랜 시간이 소요되었습니다. 랠리 포인트 인터뷰를 통해 이 상황이 내게 매우 안 좋게 비춰졌지만, 사실은 이는 출시일 근처에 많은 새로운 콘텐츠를 요구하는 중대한 디자인 변경으로 인한 결과였습니다. 이때 우리의 모든 노력은 버그 수정에 집중해야만 했던 것을 고려하면 이는 매우 불행한 일이었습니다.\n\n# 전투 AI 프로그래머의 저주\n\n프로젝트의 마지막 달에 레벨 디자인 작업 부담을 크게 증가시키기로 한 결정은 지연된 디자인 변경의 특히 나쁜 예다. 그러나 지연된 디자인 변경은 토탈 워 프로젝트에서 흔했으며, 출시를 목전에 둔 시점에서 많은 문제와 추가 작업을 야기했습니다. 요소들이 모여 게임이 천천히 플레이 가능해지는 과정에서 디자인 주도자들은 종종 피드백과 놀라움에 반응하여 게임의 디자인에 상당한 변경을 가할 때가 있었는데, 이로써 작업이 무효화되고 AI 코드가 새로운 요구를 충족하기 위해 추가 변경이 필요했습니다. 이 과정 자체는 문제가 아니었습니다. 본질적으로 반복이었기 때문인데요, 문제는 이 일들이 프로젝트에 매우 늦은 시점에 발생했으며, 때로는 출시일 직전까지 디자인 변경이 계속되었고, 패치와 업데이트를 통해 계속되기도 했습니다.\n\n지연된 디자인 변경은 우리가 버그 수정과 게임을 정비하는 데 집중해야만 했던 시기에 많은 새로운 문제를 야기했습니다. 팀 전반에 영향을 미쳤지만, 특히 AI 개발자들에게 그 영향이 가장 컸습니다. 왜냐하면 게임플레이에 상당한 변경사항이 필요한 경우 이를 직접 지원해야 했기 때문입니다. AI는 게임을 하는 것이므로, 게임이 변경되면 AI가 반드시 변경되어야 하는 경우도 많았습니다. 가능한 경우 유연하게 작동하고 다양한 가능성을 수용할 수 있는 시스템을 설계하려고 노력했으며, 이는 나의 랠리 포인트 인터뷰에서 언급한 내용 중 하나였습니다. 이는 지도, 유닛 데이터, 밸런싱 등에 대한 변경사항이 추가 AI 프로그래밍 작업 없이 수행될 수 있도록 했던 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 AI 시스템이 디자인 변경을 적절하게 지원하기 위해 변경되어야 하는 지점에는 한계가 있었습니다. 게임 로직에 근본적인 변경이 필요하거나 디자인 가정을 무효화하는 충분히 중요한 매개변수 변경이 있을 경우, 거의 항상 코드 지원이 필요했습니다. 유감스럽게도, 일부 리더십 구성원 사이에는 AI가 (또는 해야 할 만큼) 디자인 변경에 대응하는 방법을 자체적으로 찾을 수 있다고 오해하는 경향이 있었으며, 이는 종종 게임플레이 변경이 AI에 미치는 영향에 대한 우려를 무시하는 데 사용되곤 했습니다. 실제로 AI 코드는 구현 당시 알려진 기능을 지원하는 다른 게임 코드와 다르지 않습니다. 해당 기능 이상의 유연성을 원한다면 더 많은 개발과 투자가 필요합니다. 게임플레이의 변경 및 파생 효과에 대응해야 하는 AI 프로그래머들은 주로, 아이러니하게도 게임 속성 개발을 위한 시간이 부족해져서, 게임 규칙 또는 밸런싱에 대한 중대한 변경을 확실히 다루는데 필요한 AI 기술을 개발할 시간이 없었던 것이 대부분이었습니다.\n\n디자인 변경이 늦어지면 Total War 게임들은 대부분 초기 버전에서 좀 거친 AI로 출시되었지만 나중의 패치에서 개선되었습니다. 출시 후 개선된 것은 새 프로젝트로 진행될 때 팀이 전향하고 디자인이 안정화되면서 반응적인 작업을 중단하고 실제로 AI 개선에 집중할 수 있게 되었기 때문이며, AI 개발자들이 해고되고 나은 사람들로 대체되었기 때문이 아니라 제대로 일할 수 있는 환경이 구축되었기 때문입니다. 이는 내가 참여한 모든 Total War 게임에 영향을 주었지만, 프로젝트가 예정 대비 뒤처지면 문제가 더욱 심화되었습니다. 게임 출시에 가까워질수록 완성되지 않은 게임이 더 많고 자주 디자인 변경이 발생하며, 순조롭게 진행되는 프로젝트는 더 일찍 안정화되어 출시 시 어느 정도 괜찮은 결과를 기대할 수 있었습니다.\n\nTotal War와 같은 복잡한 전략 게임을 위해 유능한 AI를 개발하는 것은 최상의 조건에서도 어렵기 때문에, Total War 게임의 개발 방식은 AI에 있어서 특히 출시 당시 좋은 결과를 내기 어려운 것으로 나타났다. 앞서 언급한 것처럼 전투 AI 프로그래머들도 어려움을 겪었습니다. 내가 이 역할로 이동할 때에는 이미 팀의 개발자들이 일반적인 패턴에 대해 이야기하고 있었는데, 이역할을 맡은 프로그래머들이 한 두 번의 타이틀 뒤에 회사를 그만두는 반복패턴이라고 불리우곤 했습니다. 그것이 바로 \"전투 AI 프로그래머의 저주\"였습니다. 이 저주는 실제로 잘못된 관리와 기능하지 않는 팀 역학이 반복되어 갈등과 과로로 이어진 패턴에 지나지 않았습니다. 저의 경험도 예외는 아니었습니다. 늦게 이뤄진 디자인 변경은 문제 중 하나였지만, 다른 문제들도 있었습니다. 주로 우리는 결정 과정에 포함되지 않았으며, 게임 디자인 시 AI 개발 도전들이 고려되지 않았습니다. 게다가, 우리에게 영향을 미칠 중요한 디자인 및 제작 결정들은 종종 전달되지 않았기 때문에, 우리는 변경 사항이 시행되고 문제를 일으키기 시작한 후에야 해당 사항을 파악하고 대응해야 하는 상황이 자주 있었습니다.\n\n리더십은 AI를 ‘다른 누군가의 문제’로 취급했으며, 어려운 때와 때로는 불가능한 상황에서 최선을 다할 수 있도록 남겨두었습니다. 게임 디자인 및 제작 결정으로 인해 AI 개발 노력이 저해되는 경우가 많았습니다. 이 문제들은 수년간 신고된 사실이었지만, 내가 그곳에서 일하고 있는 동안 리더십은 그에 대한 책임을 지지 않았으며, 실제로 후에 보다 자세히 설명할 것이지만, 제 시절 동안 이러한 문제들은 더욱 악화되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 리더십 문화\n\n토탈 워 팀은 규모에 비해 매우 계층적이었고, 주요 디자인 및 경영 결정은 상위 소수 몇 명에 의해 내부 개발 팀의 실제 감독 없이 이루어졌습니다. 제가 함께 일해본 최고의 팀들은 중요한 결정을 팀 전체에 알리려고 노력하고 스스로를 검증에 여는 리더를 가졌습니다. 그러나 토탈 워의 리더들은 비판적인 피드백을 거부하고 환영받지 않는 것처럼 대표했으며, 중요한 결정이 중요하지 않은 임직원들에게 전달되었을 때 이미 최종 확정된 것으로 여겼습니다. 개발 중에 창의적이거나 경영적인 결정에 대한 피드백을 공유할 수 있는 형식적인 프로세스가 없었기 때문에 대부분의 직원들은 간단히 우려사항을 동료들이나 직속 상사에게 전달했고, 주도자들과의 대립을 피했습니다. 광범위한 팀이 의사를 표현할 수 있었다면 초기에 발견할 수 있었던 심각한 실수들이 발생할 수 있었던 것입니다.\n\n책임 있는 리더십 인물의 구체적인 신원을 보호하기 위해 노력하겠지만, 팀 내 개발 분야 간의 권력 동태에 대한 정보를 공유할 필요가 있다고 생각합니다. 이 문서에서 논의된 많은 문제들은 프로그래밍 팀에 의해 아주 잘 이해되었고, 프로그래밍 리드들은 주로 신중함과 우수한 엔지니어링 원칙을 증진하며 의문스러운 디자인 및 경영 결정에 대한 우려를 표명했습니다. 프로그래밍 리드들은 주로 출시 직전의 예상치 못한 결과에 대한 위험을 고려하고 고려했지만, 전체 팀을 지휘하는 것은 토탈 워에서 대부분 디자이너들의 결정이었습니다.\n\n디자이너들은 게임이 어떻게 플레이되어야 하는지, 어떤 기능을 가져야 하는지, 균형, 난이도 및 게임의 전반적인 창의적 비전을 결정하는 개발자들입니다. 그러나 게임 디자인 과제의 특성상 기술적 및 생산적 제약 내에서 작동해야 하므로, 일반적으로 좋은 경영은 디자인과 엔지니어링 노력뿐만 아니라 기타 분야들도 서로 보완하고 효과적으로 협력할 수 있도록 격려합니다. 특히 AI 개발을 포함한 상당한 엔지니어링 과제가 포함된 토탈 워와 같은 기술적으로 야심찬 게임 시리즈에서 이것은 특히 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n크리에이티브 어셈블리(Creative Assembly)에서는 그런 일이 일어나지 않았습니다. 디자이너들이 기술적으로는 우리 상사가 아니었지만, 프로그래머들은 자신들이 담당자라는 것을 이해했고, 프로그래밍 팀은 문제를 일으키는 변경 사항을 알고 있더라도 그를 뒤엎을 권리가 거의 없었습니다. 더 나쁜 일은 디자이너들이 구현 중에 디자인 작업의 세부 사항을 종종 프로그래머들에게 맡겼기 때문에, 실제로 프로그래머들은 많은 디자인 세부 사항의 책임이 있었지만, 그에 상응하는 영광이나 자유가 부여되지 않았습니다. 프로그래머로서, 제가 분명히 편향되어 있다는 점은 이해하겠지만, 저는 토탈 워(Total War) 팀에서 가장 숙련된 게임 개발자들이 주로 프로그래밍 부서에서 발견된 것으로 생각되고, 이들이 더 많은 영향력을 가지지 못한 것은 유감스럽다고 생각합니다. 특히, 실시간 전투의 규모 — 아마도 토탈 워의 주요한 차별화 요소라고 할 수 있는 부분은 대부분 프로그래머들의 노고에 귀속된다고 생각합니다.\n\n디자이너들이 결정을 내렸다는 것에 대해 언급할 때, 그것은 프로그래밍 팀에 대한 것뿐만이 아니라, 제작 팀이 또한 그들을 책임질 수 없는 것처럼 보였습니다. 제작 팀은 프로젝트의 관리와 팀이 마일스톤과 마감일을 준수할 수 있도록 책임이 있습니다. 예를 들어 중요한 디자인 변경 사항이 늦게 발생하는 것을 막는 것은 분명히 그들의 책임이어야 했지만, 제 경험 상 그들은 항상 프로그래밍 팀이나 기타 팀과의 갈등에서 디자인을 지지했습니다. 제 입장에서 보았을 때, 제작 리더십은 디자이너들이 원하는 대로 하도록 두었으며, 그것이 로마 II가 심각한 문제를 일으키게 된 주요 이유 중 하나라고 생각합니다.\n\n게임 디자인은 어렵습니다. 고수준의 창의적 결정을 내리는 것이 그들의 프로젝트 성공에 중요하며, 그것만으로 게임을 성공으로 이끌 수도 망칠 수도 있습니다. 그러한 입장에 있는 사람들을 비판할 때 전체적으로 디자인이 쉬운 일이라 생각하지는 않습니다. 토탈 워의 디자인 리더십의 문제는 그들이 그 책임을 별로 심각하게 받아들이지 않았다는 점입니다. 디자이너들은 대개 경험적 관찰 대신 직관에 의해 결정을 내렸으며, 아이디어를 테스트하거나 프로토타입을 만드는 일을 거의 하지 않았습니다. 신중히 생각해야 할 결정이 종종 대화 중간에 갑자기 선택된 것처럼 보였고, 우리와 같은 팀의 구성원이 디자인 선택의 동기나 이유에 대한 기본적인 질문을 할 때, 설득력이나 안심감을 줄만한 답변을 받기 힘들었습니다.\n\n분명히 팀에서 이 문제를 인식하고 최소한 비공개적으로 인정하는 좋은 디자이너들이 있었습니다. 나는 프로그래머로써 상급 디자이너에게 공식적으로 보고할 필요가 없었기 때문에 그들이 나로부터 받은 피드백을 제약할 수 있는 능력이 제한되었습니다. 그러나 하급 직급의 디자이너들은 때로는 상사의 결정에 대한 우려를 제기할 때 받는 대우를 나와 공유했는데, 이는 넓은 디자인 팀에서 비판이 나오지 않고 프로그래밍과 예술 부서에서 나오는 이유를 이해하는 데 도움이 되었습니다. 이것은 나를 놀라게하지 않았습니다. 왜냐하면 나 자신도 때로 상급 디자이너가 나나 다른 사람과 화를 내거나 거칠게 말을 하는 것을 경험했기 때문입니다. 어떤 리더들의 행동은 가치 있는 팀 피드백이 억압되도록 하는 독성 직장 환경을 만들어 냈을 수 있다고 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n프로그래머와 디자인 리더십 간의 관계를 보여주는 구체적인 예시를 알려드릴게요. 그 예시는 게임의 낮은 출시 상태에 기여한 문제들로 이어지죠. 로마 2에서 주요 새로운 기능 중 하나는 육지 전투와 해상 전투를 결합한 것이었습니다. 엠파이어부터 해상 전투가 있었지만, 육지 전투와 완전히 분리되어 있었고, 언젠가 통합될 것을 예상하지 않은 상태로 코드베이스가 개발되었습니다. 이는 육지 부대 및 육지 전투를 처리하는 코드베이스와 선박 및 해상 전투를 처리하는 코드베이스가 서로 관련이 없이 개발된 것을 의미합니다. 전투 프로그래밍 팀에게 로마 2에서 핵심 기능으로 육지와 해상 전투를 결합해야 한다는 요청이 있었고, 리드는 코드베이스의 이러한 부분을 결합하면 많은 코드를 변경해야 하며, 프로젝트의 대부분을 해결해야 하는 버그가 발생할 것이라고 경고했으며, 프로젝트 마감 시점까지 안정성이 보장되지 않을 수도 있다고 경고했습니다.\n\n그럼에도 리더십은 그렇게 하라고 했습니다. 그들은 이후 삼국 trailer를 제작하여 수상 공격을 보여주었고, 그 기능을 제공할 것으로 엮어버렸습니다. 게임이 출시될 때, 합성 전투는 버그로 가득 찼습니다. 우리는 배가 육지를 통과하거나 갇히거나 게임플레이를 망치는 등의 문제를 겪었어요. 이는 엉망이었고 해결하는 데 많은 패치가 걸렸습니다. 그래서 많은 사람들이 그걸 보고 로마의 후견선이 사막을 미끄러 지나가는 것을 보고, 이게 분명히 고질적인 프로그래밍이라고 생각할 겁니다. 하지만 제 생각으로는 그것은 명백히 디자인 리더십에 속합니다. 어려운 작업임을 경고했고 버그를 유발할 것임을 경고했는데, 그래도 해야 했습니다. 조심스럽게 접근할 수 있었고, 안정성과 게임 디자인 측면에서 증명될 때까지 몇 가지 프로젝트를 통해 작업할 수도 있었을 텐데요.\n\n디자인 리더십이 개발 대부분에 관해 통제했다는 사실은 게임 디자인 이상으로 많은 문제를 야기했습니다. 한 가지 중요한 문제는 프로그래밍 팀이 자신의 우선 순위를 결정하지 못한 채 엔진 개선, 도구 및 인프라 개선, 또는 증가하는 기술 부채를 해결할 수 없었다는 것이었습니다. 프로그래머들은 엔진, 게임플레이 및 AI와 관련된 오래된 기술적인 문제를 잘 알고 있었지만, 디자인 부서는 이러한 문제를 중요하게 생각하지 않았으며, 스케줄에 그 문제를 해결하기 위해 시간을 할당하기를 꺼렸을 때 이를 제대로 해결하는 것이 어렵다는 점이 있었습니다. 디자이너들은 이러한 문제를 전혀 알지 못했거나 때로는 엔진과 도구에 대한 불만을 표출하기도 했지만, 팀의 우선 순위를 세우는 데는 디자인 리더가 망설였기 때문에 그 문제를 적절히 해결하기 어려웠습니다. 프로그래머들이 기술적 부채에 대처하기 위해 작업을 할 때에는 종종 일정에 따라 진행되지 않았거나 디자이너의 기능 구현 부분으로 sneaked in 되었던 것이죠.\n\n# 너무 많은 신 기능들\n\n<div class=\"content-ad\"></div>\n\n크리에이티브 리더십은 Total War 게임에 새로운 기능이 추가된 횟수에 많은 중요성을 두는 것으로 보였습니다. 각 프로젝트에 사용 가능한 시간은 대부분 새로운 기능과 디자인 변경으로 가득 차는 경향이 있었는데, 이는 다른 작업보다 우선시되었습니다. 이는 프로그래머들의 일정 문제에 상당한 공헌을 했는데, 새로운 디자인 변경과 직접적으로 관련이 없는 특정 코드와 기능의 유지 및 개선에 작업시간이 거의 부족했습니다. 결과적으로 시리즈는 디자이너들에게 우선순위가 아니었기 때문에 게임플레이와 AI에서 문제가 지속되어 개선되지 않았으며, 더 많은 변경은 더 많은 미지와 문제를 의미했기 때문에 프로젝트 후반에 발생할 수 있는 문제의 위험을 증가시켰습니다.\n\nTotal War 프로젝트는 언제나 바쁘고 타이트한 일정 내에 많은 기능을 제공해야 했습니다. 그러나 이전 세 프로젝트는 비교적 간단했습니다. 나폴레옹, 세토쿠의 무술 2 및 사무라이의 몰락은 모두 약 1년 미만의 개발 시간을 가졌으며, 각각의 경우 새로운 설정이 적절한 방식으로 전달되도록 필요한 변경 및 새로운 기능만을 중점으로 한 집중적인 경험을 목표로 했습니다. 이러한 프로젝트들은 여전히 야심 차있었지만, 대부분의 경우 변경 사항과 새로운 기능은 새로운 설정을 흥미롭게 전달하기 위해 필요한 것에 그쳤습니다. 세토쿠의 무술 2는 엔진이 제작된 공간 무기에 대한 첫 번째 시도였기 때문에 세 프로젝트 중 가장 어려웠을 것으로 생각됩니다. 필요한 곳에 집중적인 노력이 집중되었습니다. 많은 노력과 몇 가지 패치로 우리는 튼튼한 게임을 만들어 냈습니다.\n\n세토쿠의 무술 2는 내 경력에서 가장 자랑스럽게 일한 게임 중 하나입니다. 완벽한 게임은 아니었으며, 이 문서에서 설명한 몇 가지 문제가 있었지만, 로마 II와 비교하면 흥미로운 대조점으로 생각합니다. 세토쿠의 무술의 후속작에서 잘 되었던 많은 요소들이 로마의 후속작에서 잘못되기도 했습니다. 나폴레온군의 소총 전술에서 펼쳐진 도성 시대의 전투로 이동하는 것만으로도 상당한 어려운 과제가 있었고, 새 엔진에서 그 변화들이 의미하는 바가 있었습니다. 또한, 도성 전투와 해상 전투를 도성 일본 상황에 맞게 개편해야 했기 때문에 새로운 역사적 설정으로 이동하는 것만으로도 많은 작업이 필요했으며, 게임을 발매할 시한인 11개월 동안에는 핵심 기능에 집중하고 리스크 수준을 최소화해야 했습니다. 또한, 스튜디오는 여전히 \"엠파이어\"로 인해 받은 평판 타격으로 회복 중이었기 때문에 일반적으로 리스크에 대한 열의가 많지 않았습니다.\n\n로마 II는 출시 전 약 2년 전에 본격적인 치열한 전제작이 시작되었으며, 나 포함 대부분의 팀은 2012년 3월 발매된 사무라이의 몰락 후에 로마 II로 이동했고, 그로부터 약 18개월 정도의 전체 개발 시간이 주어졌습니다. 이는 더 많은 시간이었지만, 이러한 야심 차고 철저한 프로젝트에 대한 여전히 타이트한 마감 기한이었습니다. 세토쿠의 무술 2와 정확히 같은 방법을 채택했다면 실제로는 로마 설정에 필요한 기능만 제공하는 것만으로도 이 시간 내에 도전이었을 것입니다. 세토쿠의 무술 2의 센고쿠 시대에서 캠페인 지도를 통합하고 모든 팩션에 대부분 동일한 유닛 로스터를 제공했어야 했지만, 로마 II는 서로 다른 문화, 비대칭적인 팩션 및 수백 가지 다른 유닛 유형을 포함했고, 이러한 모든 것들이 설계 및 구현 과제를 배가시켰습니다. 그러나 리더십은 명백히 더 많은 시간과 자원을 가졌기 때문에 새로운 기능을 추가할 여지가 많았다고 생각했고, 그러한 방향으로 나아갔습니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 기능들을 많이 추가했는데, 많은 기능이 도전적이고 위험하며 총체전식식(전쟁 게임)의 공식적인 변경 사항을 포함했습니다. 이미 전투에서 육해 작전 결합에 대해 언급했는데, 이것은 주요한 디자인 변경 중 하나였습니다. 여기 몇 가지 더 있습니다: 육상 전투에서의 점령 지점, 실제 시야 가시성 시스템, 매복 전투, 야영지 전투, 배치 방어 시스템, 영화적인 전투 카메라, 총공성 전투의 총 재설계, 새로운 항구 공성 전투, 무벽 정찰지 전투, 전술적 시점, 전투에서의 얼굴 표정 애니메이션, 전투 전투 규칙의 총 재설계; 물론 쇼파 세트 변경을 지원하는 기능들이 모두 포함되었습니다. 이상은 전투 측면에서만 언급한 것이고, 캠페인 맵에 대해 언급하지도 않았습니다. 그리고 개발 도중 게임에서 삭제된 것도 있기 때문에 설계에 시작으로 그려진 모든 기능들을 포함하지 않았습니다.\n\n로마 II의 경우, 이전 게임들보다 더 많은 시간과 자원을 투입했다. 그것은 사실이었습니다. 그러나 일정에 밀어 넣은 많은 새로운 기능들로 인해, 각 기능을 마무리하고 다듬는 데 사용할 수 있는 시간이 매우 제한적이었기 때문에 우리는 모든 다른 문제 없이도 완성도있는 게임을 출시할 수 없었을 것이라고 생각합니다. 예산을 늘렸음에도 불구하고 게임은 조급하게 보이고 느껴졌습니다. 그 이유는 기능별로 보면 그랬기 때문입니다.\n\n로마 II에서의 많은 새로운 기능들과 기본 디자인의 변경 목록은 저의 의견으로는 대부분 불필요했습니다. 쇼군 2는 좋은 게임이었으며, 핵심 게임플레이의 개선 여지가 있었지만, 대부분의 미완성 부분은 세부사항과 다듬음 부족 때문이었기 때문에 로마 시대를 위한 핵심 디자인을 재창조할 필요가 없다고 생각했습니다. 그렇게 함으로써 일정 지연과 발매 시 문제를 초래한 불필요한 위험과 개발 복잡성의 상당 부분이 만들어졌다고 생각됩니다.\n\n#결함있는 디자인\n\n<div class=\"content-ad\"></div>\n\n모든 것을 동시에 바꾸려는 것은 책임감이 없었고 팀 전체의 조언과는 반대되는 행동이었습니다. 실제론 변경사항이 가치 있는 것이었더라도 많은 문제를 야기했을 것이며, 많은 경우 게임에 거의 변화를 주지 않았거나 오히려 악화시키고 플레이어들에게 불호를 산 일부 경우도 있었습니다. 로마 II 개발 중에는 동의하지 않았던 많은 디자인 결정이 있었는데, 그 중에서도 프로젝트의 운명에 악영향을 미친 엉망으로 쏟아지는 디자인 방향을 명확하게 이끌어준 몇 가지 예를 중심으로 언급하겠습니다.\n\n아마도 가장 불호를 산 새로운 기능은 무법 광장 전투에서의 점령 지점이었는데, 이는 발매 전에 공개 행사에서 처음으로 공개되었을 때 즉각적인 논란을 빚었습니다. 로마 II의 전투에서 발견된 두 종류의 점령 가능한 승리 지점이 있었는데, 포대 전투와 비벽없는 정찰 전투에서 발견된 것이었는데 이들은 전투를 승리하기 위해 점령하고 유지해야 했습니다. 로마 II의 경우 포대 전투에서는 한 번에 하나의 승리 지점 대신 서 세 개의 승리 지점을 가질 수도 있었습니다. 그러나 로마 II에서는 일반 땅 전투에도 점령 지점이 추가되었는데, 이는 전투 게임플레이에 근본적인 변경이었습니다. 이것은 \"수송열차\"라고 불리웠으며 방어 군대의 보금자리를 표현하는 것이 목적이었는데, 주변에 수레와 텐트 모델이 놓이도록 할 계획이 있었지만, 저는 이 일이 결국 이루어지지는 않았다고 생각합니다.\n\n공개 데모에서 받은 강력한 부정적 피드백 이후, 이러한 요소들은 발매 시기 전의 일부 전투에만 확대되었습니다; 그러나 대부분의 개발 기간 동안 이 요소들은 모든 일반 땅 전투에서 사용될 예정이었습니다. 전쟁의 역사 속에서 처음으로 전투의 목표가 적군의 보금자리를 점령하고 유지하는 것이었고, 군대 자체를 맞서 싸우거나 격멸시키는 것이 아닌 새로운 방향을 제시하려 했습니다. 이는 믿기 어려울지 모르지만, 이것이 사실입니다. 이 변경의 동기에 대한 내 생각은 방어할 때 지도의 모퉁이를 사용하여 적의 플랭킹을 막는 \"코너 캠핑\" 전술을 방지하기 위한 것으로 생각됩니다. 물론 그것을 억제할 방법을 찾는 것이 좋았을 것이지만, 모든 지도에서 승리 지점을 끼워 넣는 것은 문제의 해결보다 더 큰 문제가 되었습니다. 개발 과정에서 제가 이에 대한 의견을 표명했고, 리더십 이외의 팀원들과 대화를 나누면서 이것이 엉터리 아이디어라는 것을 알았습니다. 반발이 시작될 때, 큰 놀라움은 없었습니다. \"전투에 혁명적인 영향을 미친다\"고 알리고 있던 일부 지도자들은 뒤늦게 항상 반대했던 척을 했습니다.\n\n심지어 높은 수준에서도 디자인 방향은 팀을 명확한 창의적인 비전으로 이끄는 데 실패했습니다. 프로젝트 초반에 확립된 로마 II 디자인의 주요 요소 중 하나는 \"셋업 전쟁의 인간적 면\" 이라고 불리웠으며, 이는 게임에 추가되는 많은 새로운 기능의 기초였습니다. 이것은 인간 드라마와 같은 것을 의미하는 모호한 개념으로, 전략 게임을 디자인할 때의 정확한 의미는 프로젝트의 대부분에 대해 명확하지 않았습니다. 때때로 이것은 실제 인간 얼굴의 세부사항을 의미했는데, 그 예로는 전투의 얼굴 표현 개선이 있었고, 다른 경우에는 카메라를 행동에 들어서게 해서 병사들의 행동을 보고 듣는 것을 의미했습니다 — 비록 이것이 Total War 게임의 핵심 기능이었더라도요.\n\n<div class=\"content-ad\"></div>\n\n기이하게도, 인간 드라마에 대한 개선을 추진하던 동일한 리더십 팀은 이미 그 목표를 달성했던 기존 기능들을 제거하기로 결정했습니다. 로마 II에서는 전투 전에 장군이 군대에 웅변을 쏟아내는 사전 전투 연설이 사라졌는데, 이 기능은 오직 쇼군 2에서 재도입된 후에 바로 제거되었습니다. 이 기능은 로마: 토탈 워에서 인기 있는 기능이었지만, 엠파이어와 나폴레옹에는 포함되지 않았습니다. 나는 쇼군 2에서 사전 전투 연설을 디자인하고 구현한 개발자로, 작가들과 시네마틱 스태프와 함께 일하며 로마 II에서 이 기능을 더 발전시키는 아이디어를 가지고 있었습니다. 그러나 나에게 이 기능을 제거한 이유로는 목소리 연기 비용이라고 전해졌습니다. 이는 게임의 예산과 예상 이익에 비추어 정말 불행한 결정으로 보였으며 특히 이제는 \"인간적인 표정\"이 중심적인 디자인 철학이었던 점을 감안하면 더 그랬습니다.\n\n![이미지](/assets/img/2024-07-01-TotalWarROMEIIandCreativeAssemblyMyStatementTenYearsOn_2.png)\n\n내가 아는 한 배틀에 \"인간적인 표정\" 게임 특징 중 유일하게 중요한 것은 플레이어가 개별 유닛을 근거리 3인칭 시점에서 조작할 수 있는 시네마틱 모드였습니다. 이것은 이전 토탈 워 게임에 존재했던 유닛 카메라와 유사했지만, 카메라를 유닛에 매우 가깝게 밀어 넣어 플레이어의 전술 인식을 줄였다는 점에서 논란이 있었습니다. 테스트 중에 이 기능을 전혀 사용하지 않았고, 디자인 리더들은 플레이어들이 소홀히 여기는 기능을 만들었음에도 불구하고 이를 무시한다는 사실에 불만을 느꼈습니다. 그래서 이 모드에서 유닛에게 전투 특전을 부여하기로 발표했으며, 이로 인해 프로그래머들과의 논쟁이 일어났는데, 카메라 모드가 전투 결과에 영향을 미쳐서는 안 된다는 주장이 있었습니다. 결국 디자인 리더십은 다음과 같은 타협안을 합의했습니다: 사용자 인터페이스가 전투 특전을 부여한다고 알려주지만, 실제로 전투 특전은 적용되지 않을 것입니다. 이들은 플레이어를 속일 목적으로 명백하게 거짓말을 하려는 것인데, 이는 인기 없는 기능을 사용하도록 유도하여 면목을 세우려는 것이었습니다. 정말로 전투 특전이 적용되었는지 여부를 정확히 모르겠으며, 아마 버튼이 오늘날까지도 거짓말을 하고 있을 가능성이 있습니다.\n\n## 디자인에 제한된 AI\n\n<div class=\"content-ad\"></div>\n\n그러나 이 토론에서 특히 중요한 디자인 방향 측면이 있습니다. 대부분의 사람들이 Total War 게임의 AI를 바라는 방식은 \"음, AI는 항상 문제가 있었고 실제로 훨씬 더 나아지지 않았다. 아마도 Creative Assembly의 프로그래머들은 그리 좋지 않고 AI를 어떻게 처리해야 하는지 모를 것 같다\"라고 말하는 것이라고 생각합니다. 저는 AI가 일부 의도적으로 그런 모습이라는 사실을 고려하는 사람이 많지 않다고 생각합니다. 최소한 저는 작업했던 당시 일부 AI 결함이 의도적으로 있었음을 증명할 수 있습니다. 즉, 디자이너들이 일부 방법으로 개선하지 말라고 지시했기 때문에 특정한 방식으로 AI가 있던 대로인 것이라고 할 수 있습니다. 그들은 플레이어가 AI를 제압할 수 있음을 즐기는 것이라 믿었기 때문에 우리는 그것을 방해해서는 안된다고 했습니다.\n\n또한 게임에 플레이어가 AI에게 이점을 줄 수 있는 기능이 추가되었지만, 해당 기능에 대한 AI 인식을 추가하지 말라는 지시를 받았거나 해당 기능 자체에 충분한 시간이 있지만 해당 기능에 대한 AI 작업에는 시간이 부족하다고 알려졌습니다. 따라서 이러한 기능은 단지 AI를 이기는 데 사용할 수 있는 도구가 된 것입니다. 내 견해는 Total War가 AI 중심의 싱글 플레이어 전략 게임이라는 것이며, 플레이어가 상대할 수 있는 어떤 기능이라도 AI가 대응할 수 없거나 회피하거나 대응하는 방법을 모르는 경우, 그것은 전략 게임의 핵심 가치 제안을 깨뜨리는 기능이 아니라고 주장할 수 있다는 것입니다. 확실히 디자인을 책임지고 있었다면 AI 지원 없이는 어떤 게임 특징도 추가되지 않았을 것입니다.\n\n로마 II의 예를 들어보겠습니다. 그들은 적군 유닛을 보지 못하게 하기로 결정했고, 즉 당신의 카메라 위치와 관계없이 전투터에서 적군 유닛을 보지 못할 것이라는 것입니다. 원칙적으로 이 기능은 흥미로운 게임플레이를 가능하게 해주어 플레이어들이 지형을 이용해 그들의 힘이나 움직임을 감추는 데 사용할 수 있을 것으로 보입니다. 그러나 디자인 단계에서 AI 개발을 위해 시간을 할당하지 않기로 결정되었습니다. 이는 AI가 기능을 활용하는 방법을 이해하지 못할 뿐만 아니라, 더 중요한 것은 플레이어의 유닛이 가려지고 나타나는 것에 대해 이성적으로 고려하지 못할 것입니다. 이것은 출시 당시 AI의 안좋은 상태에 기여했을 것으로 보이며, 이는 전적으로 의도된 것이었습니다. 우리는 이에 대한 우리의 의견을 분명히 했지만 \"플레이어들은 그 차이를 발견하지 못할 것\"이라고 말렸습니다.\n\nRome II에서의 이러한 사례가 유일한 것은 아닙니다. 앞서 언급한 수송열차도 전용 AI가 없었어야 했습니다. 비벽 없는 집무들과 공성전투는 특별한 경우로, 집무들의 점령 지점에 대한 전용 AI가 있었으며 — 적어도 작동했을 때 — 집무들에서의 포착 지점을 고려하기 위해 설계되었습니다. 그러나 밭 전투에서의 포착 지점에 대한 AI 개발을 진행하지 말라고 지시를 받았습니다. 왜냐하면 AI가 이미 우연히 처리하고 있었으며 디자인 리더십에 의해 충분히 효과적으로 처리되었다고 판단되었기 때문입니다. 여기서 '우연히'란, AI 유닛들이 인근에 포착 지점이 있고 더 중요한 타깃이 없는 경우 포착 지점을 향해 이동한다는 의미입니다. 하지만 이것은 보장되지 않았으며 특히 밭 전투에서는 이 포착 지점의 중요성에 대한 전술 수준의 인식이 없었기 때문에 플레이어가 AI를 제압하고 수송열차를 포착해 전투에서 승리할 수 있었던 것입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 출시 전 이 캡처 포인트들이 부정적인 반응을 받지 않았다면, 우리가 겪은 어려운 시간보다 더 어려웠을 것입니다. Total War는 전략 게임으로 마케팅되고 있으며, 여러 해 동안 AI가 중요시되고 있다는 진술과 약속이 있었지만, 내가 그곳에서 일했을 때 현실은 새로운 기능이 AI 개선보다 우선시되었다는 것이었습니다. 심지어 그러한 신기능이 직접적으로 AI를 악화시켰음에도 말이죠.\n\n# 마케팅 데모\n\n로마 II 이전에는 Creative Assembly에서 마케팅이 별로 없었습니다. PR 및 의사소통 업무를 담당한 소수의 사람들이 있었고, 브랜드 및 마케팅은 주로 세가의 관할이었습니다. 로마 II부터는 프로젝트에 직접 참여하는 내부 브랜드 부서가 생겼는데, 이들은 프로젝트에 상당한 영향력을 행사한 것으로 보였습니다. 처음으로 마케팅 데모를 위해 제작 일정이 계획되었는데, 이는 개발 중에 특정 시점에 발표될 일련의 마케팅 데모를 의미합니다. 여기서 말하는 마케팅 데모란 게임 플레이를 대중에 공개하여 마케팅 목적으로 보여주는 것을 말하는데, 이는 비디오 트레일러 형태로든, 공개 이벤트에서 플레이어에게 제공되는 빌드 형태로든 이루어지곤 했습니다. 가장 유명한 것들은 \"카르타고 시련\" 트레일러, \"토이토부르크 숲\" 트레일러, 그리고 \"한니발 캠페인\" 트레일러였습니다. 2013년 E3 데모도 있었으며, 게임 리뷰를 위해 언론계 회원들에게 제공된 특별 리뷰 빌드도 있었습니다.\n\n이러한 데모들의 날짜가 우리의 프로덕션 마일스톤이 되었고, 게임의 일정은 데모에 필요한 순서대로 기능이 개발되도록 구성되었습니다. 내가 알기로 마케팅 데모들은 모두 제시된 시일 내에 제공되었으며, 게임에 대한 관심을 불러일으키는 원하는 효과를 정확히 갖고 있었습니다. 그러나 나는 이러한 딜레마가 프로젝트의 생산 문제에 상당 부분 기여했다고 생각합니다. 그 이유를 이해하기 시작하기 위해, 이 데모들이 공개될 당시 게임의 실제 상태를 전혀 대표하지 않았음을 설명할 필요가 있습니다. \"카르타고 시련\" 트레일러와 \"토이토부르크 숲\" 트레일러가 공개될 때, 실제로 할 게임은 없었습니다. 데모 자체는 맞춤형 엔진을 사용하여 많은 스크립팅 및 특별 구성 요소를 사용해 만들어졌습니다. 스크립팅이 작동하는 방법을 이해하고 예상된 타이밍과 이벤트 순서를 따른다면 상호작용할 수 있었습니다. 이것들은 최종적으로 \"역사적 전투\"로 배포되었지만, 이들이 개발의 우선 순위를 받도록 이끈 것은 바로 마케팅 자산으로서의 중요성이었습니다.\n\n<div class=\"content-ad\"></div>\n\n각각의 데모는 실제 \"수직 슬라이스\"였습니다. 이는 게임 전체를 플레이어 경험이 시작부터 끝까지 모두 층을 이루는 요소들 - 사용자 인터페이스, AI, 경로 탐색, 레벨, 애니메이션 등 - 모두를 보여주는 게임의 작은 부분을 의미합니다. 본질적으로, 게임의 나머지 부분을 만들지 않고도 게임의 모습과 플레이 방식을 보여주기 위해 게임의 다섯 또는 십 분 정도를 만드는 것을 말합니다. 이들은 대부분 프로젝트 초기에 만들어지며, 팀에게 게임 컨셉을 증명하거나 이후 게임 자금을 확보하기 위해 사용됩니다. 내부적으로 팀의 비전을 일치시키거나 자금을 확보하는 데 도움이 되는 합리적인 개발 도구입니다. 문제는 마케팅 부서가 이를 가져가서 실제 게임 개발 단계에서의 게임을 대표하는 것으로 소비자에게 보여주는 경우입니다.\n\n몇 분짜리 게임을 제작하는 것이 몇 시간 또는 수백 시간이 걸리는 전체 게임을 만드는 것보다 간단할 수 있다고 생각되지만, 실제로 게임에는 많은 시스템과 구성 요소가 포함되어 있습니다. 다섯 분짜리 정교하게 가공된 게임 플레이는 대부분 혹은 모든 게임 시스템이 완성되어 있어야할 수 있습니다. 경로 탐색이 작동하거나 작동하지 않는 것은, 특히 최종 게임에서 요구되는 수준과 같은 수준으로 다섯 분짜리 경로 탐색을 만드는 것이 그리 쉽지는 않습니다. 스토리, 컷신, 레벨 디자인, 환경 아트와 같은 구성 요소는 시간이 지남에 따라 변경될 수 있는 것들이지만, 게임 메카닉스, AI, 사용자 인터페이스와 같은 모든 게임 시스템, 게임 내에서 재사용되는 모든 아트뿐만 아니라 엔진, 렌더링, 도구 등의 기술은 모두 게임 진행 기간 동안 거의 변하지 않는 \"수평적\"인 요소입니다.\n\n따라서 프로젝트 초기에 수직 슬라이스를 만드는 경우, 아직 시스템을 구축하지 않은 상태에서 어떻게 다섯 분짜리 게임 플레이를 보여줄 수 있을까요? 답은 할 수 있는 한 시간을 단축하고, 필요에 따라 가짜로 만드는 것입니다. 행동을 스크립팅하거나 유기적으로 발생해야 하는 이벤트를 나타내기 위해 고정된 애니메이션을 사용하거나, 실제 게임에서 발생할 일반적인 문제가 아니라 특정 경우에만 처리하는 코드를 작성하는 등의 방법을 사용합니다. 기본적으로 광고 속의 화면과 실제 게임 플레이를 구분하게끔 술책을 부리는 것이죠. 이것이 로마 II 개발 당시 발생한 일입니다. 그 당시 게임은 여전히 활발히 개발 중이었고 기본적인 기능들이 플레이 가능해지기 며칠 전이었음에도 불구하고, 우리는 많은 부분을 가짜로 만들어 정교한 게임 플레이처럼 보이게 제작한 것입니다. 그것을 당시의 게임 플레이 영상으로 대중에게 보여주어서는 안 되었고, 안타깝게도 이것이 이러한 데모에 우선순위를 두는 전체 목적이었습니다.\n\n“카르타고 공성전” 등의 데모가 어떤 부분이 가짜였는지 되도록 명확하게 설명해야 합니다. 우리는 새로운 전체 게임을 구축하고 있지 않았으며, 오로지 실제로는 수공 2에서 가져온 많은 게임 시스템이 쓰였습니다. 그래서 우리는 경로 탐색, 유닛 배치, 대포 등을 가지고 있었고, 실제 게임에 포함될 마일스톤의 데모를 향해 작업을 하며 많은 일이 성취되었습니다. 따라서 그것은 완전히 가짜일 것이라고 말하고 싶지는 않습니다. 그러나 인상적이고 수십 2와 구별되는 부분 중 상당 부분은 가짜였습니다. 우선, AI가 없었습니다. 모든 적 부대 유닛은 스크립트로 제어되었습니다. 그 당시 게임의 많은 부분은 제대로 동작하고 있지 않았습니다. 공성 탑과 배의 하선은 작동하는 것처럼 보였지만 프로젝트 진행 과정에서 여전히 많은 작업이 필요했습니다. 대포가 건물을 파괴하거나 건물들이 무너지는 장면들, 코끼리가 먼지 구름을 뚫고 돌진하는 장면들은 실제 게임플레이가 아닌 탈것이였습니다. 지휘관이 병사들에게 연설하거나 적에게 접근하기 전에 부하에게 지시하는 멋진 장면들도 스크립트 기반이었습니다. 실제로 모든 것이 그 데모에 보여준 액션들이 그 후에 출시되었던 “카르타고 전투\"를 완벽하게 대표하지 않았다고 해도, 여전히 로마 II의 상태를 대변하지는 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n이론상으로는 카르타고 포위전이 최종 게임의 목표였고 결국 그것을 만드는 것이었지만, 실제로는 실제로 정확하지 않았습니다. 왜냐하면 데모에 들어간 기능 중 프로젝트 계획에 실제로 없던 것들이 있었기 때문입니다. 때로는 데모에서 본 것에 대해 질문을 하고 그것을 실제 게임에 넣을 계획인지 물어보면 \"아, 우리가 정말로 멋지고 영화같이 보이기를 원했어\"와 같은 답변을 얻을 수 있었지만, 실제로 그 기능이 게임에서 실행 가능한지 또는 일정에 시간이 있는지 고려해보지 않았다는 것은 분명했습니다. 경우에 따라 누군가가 트레일러에 넣어 놓은 기능을 게임에 추가해야 했던 적도 있었고, 이제 우리는 그것을 제공해야 한다고 말받았기 때문에 강제로 게임에 기능을 추가해야 하는 경우도 있었죠.\n\n그럼 이 모든 것이 제작 문제와 어떻게 연관이 있는 걸까요? 그 모든 스크립트 작업을 하고 데모가 최대한 멋지게 보이도록 다듬는 데 드는 시간, 이 모든 것은 개발 시간을 소모하게 만들었습니다. 이러한 데모는 중요한 마감 기한이었고, 그것들에 이르기까지는 다른 모든 것보다 우선 순위가 되었고, 직원들은 때때로 자신의 기여물을 제시할 시간을 맞추기 위해 초과 근무를 해야 했습니다. 그래서 많은 개발자들이 전체 프로젝트의 작은 부분일 뿐인 면에 다듬지 않고 작동 중인 기능을 만들던가, 또는 다른 사람들이 작업한 것에 다듬는 데 많은 시간을 보냈습니다. 이러한 데모의 수와 그것들을 만드는 데 들어간 작업의 양을 고려할 때, 프로젝트의 개발 과정 중 상당한 부분에서 팀이 실제 게임을 만들기보다 마케팅 트레일러를 만들고 있음을 과장하지 않고 말할 수 있습니다.\n\n마케팅은 사업 현실이며, 그것을 지원하는 데 어느 정도의 노력이 기울여져야 하는 것은 공정하다고 생각합니다. 저는 이전 프로젝트인 쇼군 2의 2010년 E3 전투 시연을 비롯하여 일부를 목겓할 수 있었습니다. 그것도 본질적으로 수직 슬라이스이며 개발 팀의 시간을 몇 주 동안 소요했습니다. 그러나 로마 2의 경우, 이러한 데모에 할당된 시간과 우선 순위는 훨씬 더 컸으며, 마케팅 필요를 고려해도 매우 불균형했습니다. 마케팅 데모가 개발을 소요할 시간 뿐만 아니라 직접적으로 AI 개발에도 영향을 미쳤다고 확인할 수 있습니다. 한 사례로 전투 AI 프로그래머 중 한 명이 E3 데모를 위해 AI를 개발하는 데 몇 주 동안 전환되었는데, 이는 높은 우선 순위로 설정되었고 실제 발매일에서 단 몇 개월 전이었기 때문에 그 시간이 AI 버그를 수정하는 것이 더 나았을 것입니다. 그 일이 개발에 포함될 수도 있었지만, 그 데모의 프로세스는 매우 실험적이었고 개발자는 대부분이 점점 변화하는 디자인에 반응하느라 시간을 보내어, 실제 게임을 완성하는 관점에서는 그 일이 전혀 유용하지 않게 끝나는 일이었습니다.\n\n마케팅 트레일러를 완료하고 게임을 마무리하려고 할 때도, 발매일의 한 달 전에 프레스 이벤트용으로 집중해야 할 검토용 빌드가 있었습니다. 이 이벤트는 HBO의 로마 TV 시리즈 촬영 세트인 로마 자체에서 열렸고 세계 각국의 언론이 게임을 플레이하고 리뷰를 쓰고 가장 중요한 것은 리뷰 점수를 결정하는 이벤트였습니다. 하지만 그들이 플레이할 수 있도록 주어진 것은 단순히 게임 자체의 최신 안정적인 빌드가 아니라, 실제로 신중히 만들어진 캠페인 시나리오이기도 했고 실제 게임보다 리뷰어들에게 경험을 더 잘 가르치는 스크립트와 유형을 가지고 있었습니다. 그리고 다시 한 번, 이것은 마무리되는 동안 팀의 절대적인 우선 순위였습니다. 이 빌드는 카르타고 데모보다 훨씬 최종 게임을 잘 대표했죠. 즉, AI와 실제 게임 시스템을 실제로 사용했지만, 아직 제대로 작동하지 않는 것들을 감추기 위한 작업을 하며 모든 것이 코어 개발로 가는시간을 또한 소모시켰고 이미 일정이 크게 지연된 상황에서 실제 게임을 완성해야 하는 상황에서였습니다.\n\n<div class=\"content-ad\"></div>\n\n이 마케팅 데모와 특별 빌드는 개발자들의 시간을 차지했고, 이는 마케팅 부서에 서비스로 사용되었습니다. 그런 일이 허용되어서는 안 된다고 생각합니다. 리더십은 야 ambicieus 게임 프로젝트를 촉박한 일정으로 개발하면서도 게임을 홍보하기 위해 세련된 트레일러를 발표하기를 원했던 것 같습니다. 추가 리소스 투자 없이 그런 작업이 가능했어야 했던 것에 대해 이해를 받을 수 없다고 생각했습니다.\n\n# 로마 II 패치\n\n게임 출시 후의 몇 주 동안은 정말 이상한 경험이었습니다. 특히 개인적으로 저에게는 충격이 컸습니다. 랠리 포인트 비디오에 출연한 저로 인해 온라인에서 공격을 받았던 것인데, 스튜디오 전체에 영향이 있었습니다. 리더들 사이에는 마치 제국에서 겪은 경험으로 인해 아무 일도 없었던 것처럼 하는 이상한 분위기가 있었습니다. 성공에 대한 이야기가 많이 오가고 예약 주문과 매출이 높았다는 얘기도 있었습니다. 게임 홍보를 돕기 위해 출시 후 즉시 일부 주요 리더 인물들이 마케팅 행사에 참석한 후 바로 떠났습니다. 우리 프로젝트가 타작되고 리더들이 사라진 느낌을 받았고, 여전히 게임 완성보다 마케팅이 우선시되고 있었습니다.\n\n처음에는 로마 II 개발이 아직 베타 단계였던 것처럼 계속되는 것으로 보였습니다. 게임 플레이에 대한 기본적인 문제를 이해하고 디자이너들이 새로운 기능을 계획하는 상태였습니다. 그러나 잠시 후 대부분의 팀이 향후 프로젝트로 이동하도록 결정되었고 저는 프로그래머, 디자이너, QA 테스터들로 이뤄진 소규모 팀을 이끌 것을 제안받았습니다. 전체 인원은 10 ~ 12명 정도였습니다. 이후로 게임을 완성하려고 노력했지만, 큰 변화를 느낄 때까지 오랜 시간이 걸렸습니다. 그때쯤 되면 제가 해고당했다는 소문이 퍼지고 있었고, 게임이 개선되면서 이를 많은 사람들이 제 무능력의 증거로 받아들였습니다. 이러한 상황이 얼마나 낙천적인지 설명할 수 없습니다. 사직 허락도 떠올랐지만, 우선 게임을 작동시키고자 했습니다.\n\n<div class=\"content-ad\"></div>\n\n결국 우리는 시즈 전투에서 게임플레이에 영향을 주는 가장 심각한 문제 중 마지막을 해결한 Patch 14를 출시했습니다. 많은 플레이어가 이를 긍정적으로 받아들였습니다. 내 의견으로는, 이것이 로마 II가 완전히 플레이 가능해진 첫 번째 시점이었지만, 아직 미완성이었고 개선할 수 있는 많은 게임플레이, 균형조정 및 AI 문제가 있었습니다. 그러나 곧 로마 II의 상태가 그 당시 리더십에게는 충분히 좋았다고 여겨졌으며, 패치 프로세스가 종료되고 게임이 황제 에디션으로 재판매되며, 저와 다른 일동이 새로운 프로젝트로 이동하기로 결정되었습니다. 이 결정은 제 희망과는 달랐습니다. 로마 II에 계속 열정적으로 참여하고 싶었고, 스튜디오에게 계속해서 중요한 게임으로 지원되어야 한다고 믿었습니다. 로마 II는 판매가 잘 되었으며, 추가 DLC 개발에 대한 방대한 계획이 있었기 때문에 합리적으로 생각했던 것입니다. 게임 핵심 자체를 지원하고 향상시키는 것이 바람직하다고 생각했습니다.\n\n프로젝트를 담당할 소규모 개발팀을 유지하는 비용은 쉽게 정당화할 수 있었지만, 이제 동시에 여러 개의 새로운 토탈 워 프로젝트가 진행 중이었고, AI 프로그래머도 필요했습니다. 뿐만 아니라, 리더십은 아틸라가 로마 II와 너무 유사하게 인식될 것을 우려했고, 따라서 향상된 AI가 그것을 차별화하고 소비자들에게 더 매력적으로 보이게 할 것이라 설명했습니다.\n\n## 사후 평가\n\n로마 II 출시 후, 게임을 왜 늦출 필요가 없었는지에 대한 논의가 즉시 시작되었습니다. 한 명의 관리자가 게임을 플레이하고 출시에 충분히 좋다고 판단했다는 근거를 토대로 결정이 내려졌다는 점이 크게 논란이 되었으며, 관리진은 엠파이어: 토탈 워 출시 후에 일어났던 일과 유사한 반발이 있을 수 있다는 점을 알면서도 계속 진행하기로 결정했다고 인정했습니다. 이사실을 듣고 나는 매우 실망스러웠으며, 특히 개인적으로 경험하고 있는 결과를 고려할 때 더 그랬습니다.\n\n<div class=\"content-ad\"></div>\n\n결국 저희들은 프로젝트 후포장을 진행할 기회를 얻었습니다. 이는 개발 팀이 프로젝트에서 잘못되거나 올바르게 진행된 점들을 보고하고 토론하는 과정으로, 향후 프로젝트의 관리 방식을 개선할 참고 자료로 활용하기 위한 것입니다. 모든 프로젝트 이후에 표준으로 진행되었지만, 로마 II의 경우에는 많은 문제가 발생했으며 많은 사람들이 중요한 의견을 전달할 수 있는 것으로 간주되었습니다. 후포장은 개발자들이 경영진에게 의견을 제공할 수 있는 몇 안 되는 기회 중 하나였기 때문에 우리는 마음 속에 담아둔 것들을 솔직하게 털어놓을 수 있는 시간이었습니다. 그리고 그렇게 했습니다. 많은 피드백이 주어졌고, 운명적인 제작 및 디자인 결정에 대한 경영층의 많은 비판이 있었습니다.\n\n개발 중 우려를 표명했지만 제 의견이 들어들어지지 않았다고 느껴 시행에 문제가 생겼을 때 일종의 변명으로 간주했습니다, 비록 외부에서 비난을 받고 있었지만요. 그 기간 동안 느낀 고통과 좌절을 행동으로 전환하여 문제를 해결하고 같은 일이 다시 일어나지 않도록 했고, 이제 엠파이어와 로마 II 이후에 스튜디오에서 일이 바뀌게 될 것이라고 정말로 낙관적이었습니다. 그러나 그러지 않았습니다. 리더십이 결정에 강요하여 지적한 것은 신규 기능 도입에 대해 전투 프로그래밍 팀이 \"너무 보수적\"이었다는 비판이었습니다. 로마 II의 많은 미완성 및 결함이 있는 기능들이 출시되었을 때의 모든 문제, 무시된 경고들에도 불구하고, 우리는 이제 새로운 기능에 항상 반대했고 앞으로는 더 융통성 있게 대응해야 한다고 말을 들었습니다.\n\n후포장 피드백이 주어지고 토론된 후 중앙 리더십 인물에 의해 종합되어 전체 팀에 발송되어 공식 결론을 밝히는 팀 전체 보고서가 작성되었습니다. 그것은 속수무책이었습니다. 경영층의 제작 및 디자인 실패가 최소화되고 대부분 없었으며, 로마 II의 문제는 이전 게임이 만들어진 이후 새롭게 팀에 합류한 개발자들로 인해 발생했다는 대체 사실이 제시되었습니다. 입장에서 설명하기로는, 더 시니어 스태프들이 성공적인 토탈 워 게임 제작에 필요한 \"비밀 소스\"에 대한 더 넓은 개발 팀에게 지식을 전달하지 못했었다는 것이었습니다. 주장은 이전에 로마: 토탈 워와 같은 게임을 만들어낸 리더십이었다보니 로마 II의 문제가 정말로 그들의 잘못일 수 없다는 것이었습니다. 로마 II는 이제 선위작의 단지 리메이크일 뿐이라고 주장했으며 그 문제는 팀에 신규 합류한 이들로 인한 것이어야만 했습니다.\n\n이것은 리더십이 체면을 지키기 위한 명백한 시도로 보여졌으며, 제기된 주장은 분명히 거짓이었습니다. 우선, 세팅을 제외하면 로마 II의 디자인은 본질적으로 거의 모든 측면에서 로마: 토탈 워와는 다르며 개발 기간 동안 그것이 선배 작품의 단종이 되리라고 주장한 적이 없었습니다. 내부적으로나 외부로의 모든 의사 소통은 이가 지금까지 가장 크고 야심찬 토탈 워 게임이 될 것이며 로마: 토탈 워보다 범위와 복잡성 면에서 훨씬 뛰어나다는 것이었습니다. 둘째로, 가장 고위진들이 만약 모든 최악의 아이디어와 계획 의사 결정이 최상위 멤버로부터 나왔다는 것은 절대 논의할 여지가 없습니다. 개발 과정에서 그들이 이 아이디어를 우리에게 강요하고 우리의 우려를 무시했지만, 이제 그들은 우리를 그 선택들의 책임을 뒤집어 씌우고 싶어했습니다. 리더십으로부터 책임을 직접적으로 전가하는 결정이 나에게는 깊이 충격적이었고, 팀 전체와 내 정신에도 뚜렷한 영향을 미쳤습니다. 그 순간부터 리더십에 대해 의심하는 여지가 없게 된 것 같았습니다. 아마 제 생각에는 상황이 더 나빠질 수 없을 것 같았지만, 실상은 더 나빠질 것이었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 총 전쟁: ATTILA\n\n리더십은 우리가 경험하는 문제를 만들어낸 역할에 대해 대부분 부인했지만, 프로젝트 관리 변경에 대한 어떤 보장을 받은 적이 있었습니다. 전투 인공지능에 우선순위를 두고 디자인 변경 사항의 의사소통이 강조될 것이라는 것이었습니다. Attila에서 한 작업의 많은 부분이 로마 II에서 작업 중이던 것을 계속하는 것이었습니다. 포대와 전투 인공지능 개선이었는데, 프로젝트로 이동한 후 이 프로젝트에서도 똑같은 문제가 다시 나타나기 시작했습니다. 첫 번째 문제는 우리가 다시 한번 디자인 토론에 참여하지 않았다는 것이었습니다. 그리고 AI 개발에 영향을 미치는 기능들이 우리에게 사전 통보 없이 게임에 구현되고 있었습니다. 상황이 개선될 것이라는 보장을 받은 후라 발견할 때마다 이에 대해 발언하도록 했고, 그로 인해 Attila 리더십팀과 갈등이 생겼습니다. 그들은 우리에게 그러한 의사소통을 해야 한다고 생각하지 않았습니다. 디자인 변경에 대한 통보를 받지 못했기 때문에 그에 대한 AI를 개발할 기회가 없었지만, 리더십은 그냥 신경 쓰지 않았습니다.\n\nAI에 영향을 주는 기능을 논의하려는 회의에 초대받지 않게 되자, 그걸 불평했을 때, 회의에 참여하는 사람을 신중하게 선발해서 의사결정을 쉽게 하려는 것이라고 말했었습니다. 물론 특정 선택이 잘못된 선택일 수 있는 이유를 아는 사람을 배제하면 의사결정하기가 더 쉬워집니다. 그러나 잘못된 선택을 할 가능성이 크게 높아집니다. 디자인 리드는 유일하게 중요한 것은 결정을 가능한 빨리 내리는 것이라고 말했습니다.\n\n이러한 매우 기본적인 문제에 추가로 두 가지 논란이 발생했는데, 특히 AI를 관련시키는 것들이었습니다. 첫 번째는 앞에서 언급한 진정한 시야 가시성 시스템의 변경이었습니다. 이 기능은 디자인상 AI지원을 받지 않았기 때문에, 로마 II에서 이 기능에 대한 하드 거리 제한이 부과되었습니다. 100미터였던 것 같은데, 그래서 적 유닛들이 시야 범위 내에 있더라도 항상 보일 수 있도록 했습니다. 즉, 당신이 AI의 경각심 부족을 악용해서 당신의 유닛들을 바로 옆에서 솟아나오게 하는 것을 막을 수 있었습니다. 이 타협은 AI 지원 부족에 대한 우리의 우려에 반응하여 일부 결정되었지만, 안탈라에서 일어난 첫 번째 일 중 하나는 디자이너들이이 거리 임계값 설정을 발견하고 단지 5미터로 줄인다는 것이었습니다. 총 전쟁 전투에서 5미터는 사실상 0미터와 다를 바 없었으며, 이것은 플레이어가 AI 유닛들을 그림자에 끌어들이고 바로 그들 위에 등장할 수 있게 만들었습니다. 이에 대한 모든 문제점과 이로 인해 발생할 문제점을 설명했지만, 책임을 지고 있는 디자이너는 이것이 좋은 게임플레이라고만 생각한 것 같았고 제 불만을 듣지 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n아틸라에서 인공지능에게 불리한 기능을 설계하는 오래된 습관이 계속되고 있었고, 그 당시 진행 중이던 또 다른 게임인 워해머에서도 이는 계속되고 있었어요. 워해머의 경우 막대한 수의 주문과 복잡한 특수 능력들이 있었는데, 이는 당시의 AI가 참여할 수 있는 게임플레이를 만들어냈던 기획이 없었어요. 내 이해에 따르면 워해머는 보다 많은 시간을 투자하여 AI의 능력을 향상시켰고, 회사에 있을 당시에는 새로운 기능을 우선시하는 디자인 방식이었어요. 저는 두 게임에 대해서 그들이 고의적으로 안 좋은 AI를 갖춘 게임을 디자인하고 있다고 주장했지만, 디자이너들은 저를 무시하며 제 시간을 낭비하고 있다고 말했어요.\n\n아틸라에서 발생한 두 번째 이슈는 공성 전투에 영향을 미칠 새로운 기능이었어요. 우리는 방금 로마 II 출시 후 공성 전투를 플레이할 수 있게 하는 데 거의 1년을 투자했고, 그러한 부분의 안정성을 지켜야 한다고 느끼고 있었어요. 기능의 구체적인 부분은 언급하지 않겠지만, 핵심은 플레이어가 공성 전투 시에 도시 벽 안에 몇몇 유닛을 배치할 수 있는 것이었어요. 제 의견은 이것이 AI 뿐만 아니라 게임플레이까지 방해할 잠재력이 있다고 생각했고, 우리가 이 기능을 제공할 때 게임플레이와 공성 전투의 안정성 면에서 손해를 입을지도 모르겠다고 확신하지 못했어요. 중요하게 여기는 점은 아틸라가 짧은 프로젝트였고, 대부분의 시간을 로마 II를 패치하는 데 사용했기 때문에 이 시점에서 남은 시간이 많지 않았어요. 사실 알파 마일스톤에 거의 도달했던 시점이었는데, 그때에는 기능이 완료되어야 했어요.\n\n위험과 타이밍에 대한 우려를 제기했고, 로마 II 시대의 공성 전투를 염두에 두고 역행하지 않도록 하는 것이 얼마나 중요한지에 대해 진지하게 이야기했어요. 또한 해당 기능의 근거가 뭔지에 대해 설명을 요청하여 제가 도출한 위험을 가치 있게 여길 수 있는지에 대해 확인하고 싶었어요. 저의 경험 상 게임 개발에서 이는 매우 흔한 질문이에요. 만약 누군가가 위험하거나 비용이 많이 드는 일을 계획하고 있다면, 그것이 왜 좋은 아이디어인지 또는 어떤 문제를 해결하는 것인지 설명해 달라고 요청하는 것은 실수를 방지하는 좋은 방법입니다. 크리에이티브 어셈블리에서는 이 질문이 자주 묻히지 않았다고 생각해요. 처음에는 무시당했고, 그래서 다시 한 번 물어보았죠, 아마도 한 번 더 물어봤고, 결국 위험 평가와 근거에 대한 답변이 없음에도 불구하고 이 기능을 계속 진행 중이라고 지적할 필요가 있었어요.\n\n결국 이는 도시 내부에서 소환될 수 있는 유닛을 갖게 하는 것이 공성 전투 시 반드시 필요한 기능이라는 결론을 이끌어내고자 한 설계 리더가 제게 보낸 여러 페이지 분량의 이메일로 이어졌어요. 비록 토탈 워 게임에서 전에 그런 적이 있었던 적이 없다고 생각되지만 말이에요. 이것은 설계 리더와 내가 서로 대립하는 상황으로 이르렀어요. 이 문제는 최고 생산 및 설계 리더십으로 확대되었고, 그들은 설계 리더의 입장을 지지하며 제가 투덜거리는 대신 맡은 일을 해야 한다고 비판했어요. 또한 이 리더십 인물들에게 그들이 이 기능에 대한 근거를 제공할 수 있냐고 물어봤는데, 제게 얻은 최선의 대답은 \"이것은 게임을 더 좋게 만든다\"였어요.\n\n<div class=\"content-ad\"></div>\n\n# 최종 결전\n\n이 모든 일들이 하나의 전환점을 맞이한 날이 있었습니다. 디자인 리더가 이메일에서 나를 협업을 거부하는 사람으로 비난하며 내가 협업에 실패하고 있다고 시사했을 때 일이 심각해졌습니다. 나는 그에게 답장을 보내 협업을 강조했기 때문에 디자인팀을 비판했다고 말했습니다. 그들은 개발자들에게 의사소통을 거부하면서 게임을 개발하고 있었기 때문에 나는 비판을 했다. 이 답장으로 소란이 터졌지만, 그 상황에서는 매우 합리적이었다고 생각했습니다. 그리고 그 디자인 리더를 제외한 리더십 및 경영진과의 회의에 참석하게 되었습니다.\n\n그 디자인 리더로부터 받은 서한에는 나의 불만과 우려를 다룰 수 없다는 내용이 담겨 있었는데, 나는 아틸라 게임에서 발생한 문제점을 로마 II에서 범한 실수와 비슷하게 반복하고 있다고 지적했습니다. 나는 이러한 결정이 소통이 전혀 이루어지지 않는 상황에서 이루어졌음을 강조했습니다. 전쟁 인공지능(AI)에 영향을 미치는 변경 사항조차 알려주지 않고 있기 때문에 제 업무를 수행할 것으로 기대해서는 안 된다는 점을 다시 한 번 상기시켰습니다. 나는 디자인 프로세스에 참여하도록 요구하지 않았고, 그저 우리에게 영향을 미치는 변경 사항에 대해 통보받기 위해 싸웠을 뿐이었습니다.\n\n하지만 그 회의실에서 '토탈 워'의 고위 경영진들은 나에게 이 문제들을 지적하는 것을 그만두라고 많은 압력을 가했으며, 그 중 한 명은 내 입맛을 강요하면서 내가 하지 않은 발언을 내 입에 넣었습니다. 나는 명백하게 말하고 싶습니다. 이 분쟁 기간 동안 내 행동은 전문적이었습니다. 단지 제 주장을 정중하게 펼치고 사람들이 내린 결정과 그것이 이전에 약속했던 것과 어떻게 일치하지 않았는지, 그리고 프로젝트에 대한 결과를 두려워했던 점을 지적했을 뿐입니다.\n\n<div class=\"content-ad\"></div>\n\n나는 낮은 순위의 프로그래머로서 경영진에게 매우 합리적인 우려를 표현했더니 비난을 받는 회의는 분명히, 다른 사람들에게 무슨 일이 일어나든 상관없이 자기들의 방식대로 계속하고 싶어하는 경영진들을 위해 나를 침묵시키기 위한 의도가 있었다고 생각한다. 아마도 그것이 성공했던 것 같아, 그 순간부터 나는 팀 리더쉽과 적으로 간주되었고, 내 승진 기회나 이와 같은 것들에 영향을 미칠 것으로 생각했다. HR과의 공식 불만 절차를 따르는 등 다양한 선택지를 고려했지만, 궁극적으로 나에게는 스튜디오를 떠나는 것이 최선이라고 판단했다. 충분한 예고를 하고, 문서 작성에 시간을 할애했으며, 나를 따르게 될 사람들을 도와 이직 과정을 도왔다. 적어도 HR은 내 행동에 대해 안심시켜주었고, 언제든지 다시 환영받을 것이라고 말해주었지만 (이 글이 게시된 후에는 사실일 수 없다).\n\n# 최종 소감\n\n크리에이티브 어셈블리(Creative Assembly)에서의 경험은 꽤 극심했다. 회사의 명예가 나와 얽히게 된 실수는 내 자신의 것이지만, 그 당시 스튜디오가 어떤 식으로 미래를 위협하는지 심각성을 이해했다면 결코 하지 않았을 실수였다. 많은 플레이어들과 코멘터들이 지난 몇 년간 회사를 심각하게 비판해왔지만, 적어도 토탈 워(Total War) 팀의 배경에서의 현실은 심지어 그것들의 가장 엄격한 비평가들이 상상했던 것보다 더 나쁘다고 생각한다. 로마 II 출시 후 내가 얻은 명성에도 불구하고, 나는 자신의 작업 품질에 자부심을 가지는 개발자이며, 그러한 마음가짐을 가지고 있던 나에게 크리에이티브 어셈블리는 적합하지 않았다. 다행히도, 산업에서 다른 곳에서 훨씬 더 나은 경험을 가졌다는 것을 자랑스럽게 생각한다.\n\n하나 의문을 제기해야 할 점은, 이러한 경험이 현재의 크리에이티브 어셈블리를 어떻게 대변하는가이다? 최근 스튜디오가 직면한 문제를 고려할 때, 스튜디오 경영진과 창의적 리더십이 여전히 심각한 문제의 근원인 것은 분명하지만, 내가 최근 경험한 것과 얼마나 유사한지에 대해서는 말할 수 없다는 점을 분명히 해야 한다. 하나 말하고 싶은 것은, 내가 이 글에서 묘사한 문제들에 책임이 있는 몇몇 개인들이 회사에서 아직 일하고 있거나, 최근 감축까지 일해왔다는 것은 스튜디오의 경영 문화에 대한 계속되는 문제를 무엇인가 말해주는 것이라고 생각한다.\n\n<div class=\"content-ad\"></div>\n\n다른 질문은, 왜 이러한 리더십 문제들이 그토록 오랫동안 지속되었을까요? Empire, Rome II, 그리고 이어지는 논란 이후에도 왜 변화가 이루어지지 않았을까요? 저는 답을 알고 있다고 믿습니다. 지속적인 게임 문제와 몇 가지 주목할 만한 창피한 일들에도 불구하고, 이 시리즈는 계속해서 수익을 올렸습니다. 이 사실은 저와 같은 개발자들에 의해 더 나은 실행 방안을 주장하는 데 사용되었으며, 종종 크리에이티브 리더십에 의해 성공적인 이전 프로젝트와 결정의 성공을 확인하는 지표로 사용되었습니다. 나는 이 시리즈의 지속적인 성공을 설명할 때, 토탈 워의 경영보다는 플레이어들의 인내심과 선의로 더 잘 설명된다고 생각합니다.\n\n이 문장으로 내 목표는 내가 근무한 기간 중 크리에이티브 어셈블리의 문제의 본질을 이해하도록 대중을 돕기 위함이었습니다. 이를 통해 Rome II 및 당시 토탈 워 게임에서 제가 개개인적으로 발생시킨 역할을 더 잘 이해할 수 있게 되었습니다. 이런 상황의 결과를 열흘간 버티며 살아온 후 이제 이를 털어놓는 것이 기분이 좋았습니다. 저와 같은 게임 개발자들은 게임을 만드는 것에 처음 나서면서 게임을 사랑하게 되는데, 제 경우에는 특히 토탈 워를 사랑했습니다 — 거기서 근무하기 전에는 이 시리즈의 모든 게임을 플레이했습니다. 저의 진심으로 바라는 것은, 크리에이티브 어셈블리가 이 문제를 넘어서 미래에는 더 나은 성과를 거둘 수 있기를 바랍니다. 언젠가는 꼭 메디아움 3을 플레이해보고 싶습니다.","ogImage":{"url":"/assets/img/2024-07-01-TotalWarROMEIIandCreativeAssemblyMyStatementTenYearsOn_0.png"},"coverImage":"/assets/img/2024-07-01-TotalWarROMEIIandCreativeAssemblyMyStatementTenYearsOn_0.png","tag":["Tech"],"readingTime":41},{"title":"게임 사운드 디자이너를 위한 버튼 상호작용 가이드","description":"","date":"2024-07-01 21:18","slug":"2024-07-01-Agamesounddesignersguidetobuttoninteractions","content":"\n\n## 게임에서 기본 상호 작용 패턴의 청각적 피드백 이해하기.\n\n![agamesounddesignersguidetobuttoninteractions](/assets/img/2024-07-01-Agamesounddesignersguidetobuttoninteractions_0.png)\n\n게임에서 대부분의 상호 작용은 물리적이든 가상적이든 버튼을 눌러 시작됩니다. 버튼을 누르는 행위는 속이 깊게 간단한 것으로 보일 수 있습니다. 이를 어떻게 수행하는지마다 다른 결과가 나타나며, 각각은 입증된 사용 사례와 인기 있는 메커니즘과 결합되어 있습니다. 이 글은 이러한 패턴들을 설명하고 그에 맞는 사운드를 지원하는 방법을 살펴봅니다.\n\n제 블로그에 처음 오신 분들을 환영합니다! 여기서는 사운드 디자인을 기능적인 관점에서 다루며, 소리를 창작하는 것보다 그 활용 및 맥락화에 초점을 맞춥니다. 대부분의 좋은 것들은 '왜?'로 시작되기 때문에, 이 글이 왜 쓰여졌는지부터 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n듣는 것은 인간 뇌에 많은 정보를 전달하는 독특한 감각입니다. 시각과는 다르게 작용하여 일부 측면에서는 더 효율적이고, 다른 면에서는 덜 효율적입니다. 저에게 있어 소리 디자이너의 큰 부분 역할은 음향이 시각과 동등한 가치 있는 정보를 플레이어에게 제공하도록 하는 것입니다. 이러한 방식으로 게임을 보다 접근하기 쉽고 재미있게 만들어주지만, 개발팀 내의 다양한 시너지를 유발할 수도 있습니다.\n\n소리 디자이너로서 상호작용 피드백에 대한 직관적인 이해력이 좋다고 생각했습니다. 그러나 의문을 제기할 만한 몇 가지 디자인 선택을 한 뒤 다른 게임에서 비슷한 선택으로 나타난 결과를 듣은 후, 해당 주제를 좀 더 심층적으로 탐구하기로 결심했고, 한 번 과하게 고민한 뒤 의문이 생길 때마다 참고할 모델을 만들어 돌아왔습니다. 그럼 이것이 바로 그것입니다.\n\n# 청각적 피드백 구성 요소\n\n상호작용에 대한 청각적 피드백은 최대 세 가지 선택적 구성 요소로 구성됩니다. 이를 \"결과 음\", \"입력 반응\", \"시스템 응답\"이라고 합니다. 이들이 무엇인지 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 결과적인 소리\n\n제품 소리 디자이너들은 결과적인 소리와 의도적인 소리를 구별합니다. 결과적인 소리는 물리적 장치의 이동 부분에서 나오는 소리입니다. 의도적인 소리는 소리 디자이너들이 제품에 고의로 추가하는 소리입니다. 우리가 비디오 게임을 위해 만드는 모든 소리는 의도적인데요, 그래서 보통 결과적인 소리에 대해서 생각하지 않고 이 용어를 사용하지 않습니다. 하지만 이들은 여전히 PC나 콘솔에서 게임을 할 때 플레이어가 듣는 소리의 일부입니다. 게이밍 입력 장치의 결과적인 소리에는 버튼 클릭 소리, 햅틱 액추에이터에서 나오는 소음, 그리고 어려운 게임 플레이 시퀀스 동안 장치를 세게 누르면 나는 플라스틱 파닥거림 등이 있습니다. 이 소리들에 대해 우리는 통제할 수 없지만, 그 존재와 감당할 수 있는 기능을 인정하는 것이 중요하다고 생각합니다.\n\n보통 물리적 버튼에서 나오는 결과적인 소리는 간단한 입력 확인의 형태입니다. 클릭 소리를 듣고 버튼 이동을 느끼면 플레이어는 명령을 하드웨어로 보냈다는 것을 확인할 수 있습니다. 이 피드백은 많은 의미를 전달하지는 않지만, 상호작용이 반응적이고 조절 가능하게 느껴지게 하는 정보의 일부입니다. 이 유형의 피드백은 특히 정밀한 타이밍이나 버튼을 순서대로 눌러야 하는 상호작용 패턴에서 특히 중요합니다.\n\n결과적인 소리는 자연스럽게, 그것들이 없을 때만 주목할 가치가 있지만 없어서는 안됩니다. 이것은 그들이 상호작용 패턴과 관련이 있지만 대상 장치의 입력 방법이 조용할 때 발생할 수 있습니다(터치 스크린과 모션 컨트롤러를 생각해보세요). 이 경우 입력 반응 메시지를 추가하고자 할 수 있으며, 이는 소리이거나 햅틱 신호 또는 둘 다일 수 있습니다. 아래에서 이에 대해 더 자세히 설명하겠습니다. 그 외의 경우에는 존재하는 결과적인 소리를 완전히 무시해도 안심하세요. 왜냐하면 이미 존재하는 결과적인 소리에 대해 제어할 수 있는 영역이 거의 없기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-07-01-Agamesounddesignersguidetobuttoninteractions_1.png)\n\n## 입력 반응\n\n버튼을 누르거나 놓을 때나 터치스크린을 탭할 때 재생되는 소리를 말합니다. 그 기능은 상호작용의 유형에 따라 다르지만, 일반적으로 입력을 강조하고 게임에서 수행한 동작을 나타냅니다. 가상 버튼을 누르거나 총을 쏘는 등의 행동을 표현합니다.\n\n## 시스템 반응\n\n<div class=\"content-ad\"></div>\n\n입력 반응은 동작을 나타내고, 시스템 반응은 결과를 전달해요. 상호작용이 다양한 의미 있는 결과를 초래하거나 결과가 시간적으로 지연될 때 특히 유용해집니다. 예를 들어, 플레이어가 앱 내 구매를 하면, 구매 버튼을 누른 직후가 아니라 서버에서 구매가 확인될 때 \"카징!\" 소리를 들어야 해요. 또 다른 예로 어떤 대상에 명중했는지, 목표를 맞췄는지를 알려주는 총알 피격 소리가 있어야 해요.\n\n이러한 피드백 요소가 항상 존재할 필요는 없지만, 기대되는 소리가 들리지 않는 것도 음성입니다. 이런 의미로, 응답이 없음 역시 자체적인 의미를 전달할 수 있어요. 예를 들어 캐릭터를 움직이려고 시도했지만 발소리가 들리지 않는다면, 그들이 움직이지 않았음을 알 수 있어요. 무기를 발사했는데 총알 피격 소리가 들리지 않는다면, 즉시 목표를 놓쳤음을 알 수 있어요. 하지만 게임이 어떤 이유로 인해 전혀 총알 피격 및 명중 사운드가 없다면, 이 소리들이 없음으로 인해 플레이어가 오해를 할 수 있어요. 이러한 유형의 피드백이 해당 상호작용에 필요한지 여부를 결정할 때 이것을 염두에 두세요.\n\n상호작용 패턴 설명으로 넘어가기 전에, 가상의 게임 플레이 시퀀스를 사용하여 세 가지 피드백 요소를 확인해 보죠:\n\n은밀한 액션 게임에서 플레이어는 은신처에서 활로 적 NPC를 공격합니다. 화살이 목표물을 죽입니다. 다른 적 NPC는 이를 목격하고 경보를 울립니다. 이제 여러 적이 플레이어를 찾기 시작해요.\n\n<div class=\"content-ad\"></div>\n\n이 시나리오에서 플레이어는 다음과 같은 소리를 듣게 됩니다:\n\n1. 버튼 누르는 소리\n2. 활을 당기는 소리\n3. 버튼 놓는 소리\n4. 활을 놓을 때 나는 소리와 화살 휙 소리\n5. 적을 성공적으로 처치했음을 나타내는 명줄 소리\n6. 적 NPC 비명\n7. 쓰러지는 몸의 소리\n8. 경보 설정에 관한 NPC 목소리 대사\n9. 게임 속 사건으로서의 경보 소리\n10. 적들이 플레이어를 적극적으로 수색하고 있는 발소리 및 대화\n\n이 순서에서 1번과 3번 소리는 결과적인 것이며, 2번과 4번은 입력 반응 범주에 속합니다. 5번은 시스템 반응입니다. 다른 다섯 가지 소리(6~10번)는 명백히 상호작용 피드백으로 의도적으로 설계된 것은 아니지만 게임 플레이 맥락에서 그런 역할을 가정합니다. 저는 이러한 소리를 떠오르는 청각적 피드백으로 지칭하며, 이 글은 그것에 대한 것이 아닙니다. 그것들을 언급한 이유는 내가 내재화된 피드백과 떠오르는 청각적 피드백 사이의 경계를 어디에 그었는지 보여주기 위해서입니다.\n\n![2024-07-01-Agamesounddesignersguidetobuttoninteractions_2.png](/assets/img/2024-07-01-Agamesounddesignersguidetobuttoninteractions_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 게임에서의 버튼 상호작용 패턴\n\n저는 상호작용 디자인 전문가가 아니기 때문에, 게임에서의 단일 버튼 상호작용 기술을 탐구한 학술 논문을 참고했습니다. 그곳에서 제공된 목록을 약간 수정하여 QTE 상호작용을 별도의 항목으로 제거했습니다(음향 디자인 관점에서는 Precision Press와 다를 바 없기 때문입니다) 그리고 Release를 독립적인 상호작용 패턴으로 추가했습니다. 또한 제 개인적인 설명과 예시를 추가했습니다.\n\n- Press. 버튼을 누르면 상호작용이 실행됩니다. 마치 총성 같은 느낌.\n- Release. 버튼을 누르면 상호작용이 시작되고, 버튼을 놓으면 실행됩니다. UI 요소와 상호작용하는 일부 상호작용처럼.\n- Multipress. 리듬에 맞는 일련의 버튼 누르기가 상호작용을 실행합니다. 격투 게임의 콤보처럼.\n- Hold. 버튼을 누르면 상호작용이 반복 실행됩니다. 버튼을 놓으면 실행이 중지됩니다. 차량의 엑셀과 유사합니다.\n- Hold and Release. 버튼을 누르면 상호작용이 시작되고, 플레이어가 버튼을 일정 시간 동안 누르고 있으면 버튼 놓기로 실행됩니다. 충전된 공격처럼.\n- Time Limited Hold. 버튼을 누르면 상호작용이 시작됩니다. 플레이어가 버튼을 일정 시간 동안 누르고 있으면 실행됩니다. 실수로 클릭하여 실수로 수행하지 않을 중요한 작업에 사용됩니다. 예를 들어, 컷신을 건너뛰기.\n- Precision Press. 버튼을 누르면 지정된 시간 창 안에서만 상호작용이 실행됩니다. 완벽한 블록과 같이.\n- Pump. 버튼을 누르면 상호작용이 실행되고, 플레이어가 버튼을 계속 빠르게 누르고 있을 때 계속 반복 실행됩니다. 스크립트된 시퀀스에서 강력한 적으로부터 도망가는 것과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 버튼 상호 작용 패턴을 위에서 소개한 청각 피드백 구성 요소와 매칭해 보겠습니다.\n\n## Press\n\n결과음: 중요하지 않음\n입력 반응: 누름\n시스템 응답: 맥락적\n\n비디오 게임에서 가장 간단하고 일반적인 상호작용 패턴: 버튼을 누르면 무언가가 발생합니다. 이는 액션 게임에서 샷건 발사, 점프 또는 근접 공격을 수행할 때 경험할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그런 상호 작용에는 누르는 입력 반응과 선택적인 시스템 응답이 필요합니다. 버튼에서 나오는 소리는 중요하지 않지만, 누르는 입력 반응과의 지연이 전체 상호 작용의 느낌에 영향을 미칩니다. 우리가 듣는 소리는 시간을 체험하는 방식에 영향을 미치기 때문입니다. 상호 작용이 다른 결과를 일으키거나 결과가 즉시 나타나지 않는 경우 시스템 응답이 필요합니다. 이것은 대부분의 패턴에 적용되는 일반적인 원칙이며, 따라서 저는 다음 섹션에서 이를 반복하지 않겠습니다.\n\n## 릴리스\n\n결과음: 중요\n입력 반응: 누름 상태에서 가능, 릴리스 시 필수\n시스템 응답: 맥락적\n\n이전과 거의 동일한 패턴이지만 상호 작용은 버튼을 놓을 때 실행됩니다. 마우스나 터치스크린을 사용하여 UI 요소와 상호 작용할 때 자주 경험합니다. 동일한 상호 작용은 입력 장치에 따라 누름과 릴리스 패턴을 전환할 수 있습니다. 예를 들어, 마우스로 버튼을 놓을 때 실행되는 상호 작용은 컨트롤러로 전환하면 버튼을 누를 때 실행될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 경우, 중요한 소리, 입력 반응의 해제 및 선택적 시스템 응답의 조합은 이를 지원하는 데 충분하지만, 여기에 유명한 예외가 있습니다. 대상 장치가 중요한 소리를 내지 않을 때, 서체된 누름 입력 반응이 주관적 반응성과 상호 작용에 대한 통제 느낌을 증가시킵니다.\n\n제가 가장 좋아하고 가장 무시되는 예는 손가락을 놓을 때 실행되는 터치스크린 상호 작용에 누름 입력 반응을 추가하는 것입니다. 터치스크린은 본질적으로 조용하고 정적이며 사용자가 상호 작용함으로써 손가락으로 적어도 일부를 시각적 정보로 가립니다. 이로 인해 작은, 눈에 띄지 않는 불확실성의 순간이 발생합니다: 작동할까요? 제가 올바르게 눌렀을까요? 미묘하고 거의 들리지 않는 소리 또는 햅틱 자극이 이를 해결해 주어 더 자연스럽고 통제 가능하며 즐거운 경험으로 이어집니다. 게다가 플레이어가 손가락을 다른 곳으로 옮겨 상호 작용을 취소할 수 있다면, 누름 입력 반응은 그것이 가능하다고 시사합니다.\n\n## 다중 누름\n\n중요한 소리: 중요\n입력 반응: 시퀀스의 최종 누름\n시스템 응답: 맥락적\n\n<div class=\"content-ad\"></div>\n\n이 상호 작용 패턴은 플레이어가 버튼을 여러 번 누르면 특별한 동작을 수행하도록 게임에 알려줍니다. 가장 좋은 예는 대전게임에서의 콤보나 베트업 게임에서의 특별 공격입니다.\n\n이 경우 결과적인 소리에서 오는 피드백은 입력 단계에서 플레이어를 안내하는 의미 있는 정보가 됩니다. 상호작용별 누름 입력 반응 소리는 시퀀스의 마지막 누름에서만 재생됩니다. 시스템 반응이 존재하는 경우, 최종 누름 이후에 따라옵니다.\n\n소리를 출력하지 않는 입력 장치에서는 이 상호작용 패턴을 드물게 볼 수 있지만, 만약 이를 지원해야 할 경우 별도의 청각 또는 햅틱 누름 입력 반응으로 누름을 강조해보겠습니다.\n\n![img](/assets/img/2024-07-01-Agamesounddesignersguidetobuttoninteractions_3.png)\n\n<div class=\"content-ad\"></div>\n\n## 홀드\n\n**중요하지 않은 소리**\n입력 반응: 누름과 놓음\n시스템 응답: 맥락적\n\n이 유형의 상호작용은 버튼을 누르고 있는 한 계속 실행됩니다. 이는 자동차를 운전하거나 조준, 자동 소총을 발사하거나 액션 게임에서 질주할 때 느낍니다.\n\n이 경우에는 누름과 놓음 입력 반응 구성요소를 항상 사용해야 합니다 - 반복을 시작하고 중지하거나 원샷 소리를 재생하거나 둘 다 할 때입니다. 참고로, 제 블로그에서 \"반복 중지\"와 같은 것들을 소리로 부르며, 그 이유를 별도의 글에서 설명했습니다.\n\n<div class=\"content-ad\"></div>\n\n한 가지 중요한 소리가 여기서 흥미로운 역할을 합니다: 상호 작용 자체에 중요하지는 않지만, 누르는 입력에 반응이 느릴 때 게임이 둔하게 느껴질 수 있습니다. 저의 가장 좋아하는 해결책은 항상 매우 조용하지만 빠르고 날카로운 레이어를 포함하여 플레이어에게 입력에 대한 반응이 있음을 즉시 전달하는 것입니다.\n\n## 유지 및 놓음\n\n결과적인 소리: 중요하지 않음\n입력 반응: 누름 및 놓음\n시스템 응답: 상황에 따라\n\n이 상호 작용은 이전 것과 유사하며 동일한 피드백 구성 요소 요구 사항을 갖고 있습니다. 두 가지 사이의 주요 차이점은 유지 패턴이 버튼 놓음으로 상호 작용을 중지하는 것이라면, 유지 및 놓음 패턴은 유지 부분을 충전이나 준비에 사용하고 버튼 놓임으로 상호 작용을 실행합니다. 가장 좋은 예는 활을 쏘는 것과 같은 어떤 형태의 충전된 공격입니다. 경우에 따라 플레이어는 버튼을 얼마 동안 누르고 있어야만, 그렇지 않으면 상호 작용이 취소됩니다.\n\n<div class=\"content-ad\"></div>\n\n프레스 입력 리액션은 상호작용의 시작과 진행을 전달하기 위해 필요합니다. 반면 릴리스 입력 리액션은 두 가지 기능이 있습니다: 상호작용 실행을 강화하거나 플레이어가 버튼을 일찍 놓을 경우 취소함을 통보합니다. 당연히, 이러한 경우에는 각각 다른 릴리스 입력 반응이 필요합니다.\n\n## 시간 제한 홀드\n\n연상음: 중요하지 않음\n입력 리액션: 맥락적\n시스템 반응: 필수\n\n이 패턴을 사용하면 버튼을 일정 시간동안 길게 누르면 상호작용을 실행합니다. 버튼을 일찍 놓으면 상호작용이 취소되며, 제때와 지각적인 버튼 놓기는 영향을 미치지 않습니다. 대부분의 경우, 시간 제한 홀드는 실수로 발생시키고 싶지 않은 중요한 작업에 사용됩니다. 예를 들어, 구매하기, 컷신 건너뛰기 또는 게임 종료와 같은 상황입니다.\n\n<div class=\"content-ad\"></div>\n\n가장 중요한 피드백 구성 요소는 시스템 응답입니다. 상호 작용 실행과 함께 발생하며 버튼을 놓아도 된다는 신호를 주는 역할을 합니다. 놓아주기 반응은 상호 작용의 조기 취소를 효과적으로 전달하며 실행 후에는 피하는 것이 좋습니다. 누르기 반응은 상호 작용의 시작 진행을 전달하는 데 도움이 되지만 때로는 압도적으로 느껴질 수 있어 일부 디자이너들이 미려한 이유로 이를 생략하기도 합니다.\n\n**정밀 누름**\n\n- 결과적인 소리: 중요\n- 입력 반응: 누름\n- 시스템 응답: 필수\n\n이 상호 작용 패턴은 기본 누름과 유사하지만 사용자는 일정 시간 내에 실행해야 합니다. QTE 상호 작용, 완벽한 방어 동작 및 리듬 게임에서 하는 거의 모든 것이 이 범주에 속합니다.\n\n<div class=\"content-ad\"></div>\n\n시간을 주로 듣기로 탐색하기 때문에 적절한 타이밍이 실패로 이어질 수 있습니다. 음향적인 반응과 프레스 입력 반응은 플레이어에게 일정한 가치를 전달합니다: 둘 사이의 뚜렷한 시간차는 입력 지연을 나타냅니다. 플레이어는 상호작용이 성공적이었는지를 완전히 예측할 수 없기 때문에 시스템 반응이 결과를 전달하는 데 필수적입니다.\n\n**펌프**\n\n음향적인 반응: 중요\n입력 반응: 맥락적\n시스템 반응: 필요\n\n덜 일반적인 상호작용 패턴은 플레이어가 빠르게 버튼을 눌러야 함을 요구합니다. 이는 무거운 물체를 움직이거나 위험한 상황에서 도망가는 등의 중요한 행동을 수행하는데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 경우 입력 강도가 상당히 높기 때문에 \"조용한\" 장치조차 어떤 형태의 부차적인 소리를 내기 시작하며, 이는 이 상호 작용 패턴의 주요 청각적 피드백 구성 요소가 됩니다.\n\n이야기나 미적 이유로 누르는 입력 반응이 존재할 수 있지만, 이것이 상호 작용이 어떻게 진행되고 있는지에 대해 많은 정보를 전달해주지는 않습니다. 시스템 반응은 플레이어에게 버튼을 더 이상 눌러야 할 필요가 없다는 것을 알려줍니다.\n\n여기 이 글의 내용을 간단히 정리한 치트 시트가 있습니다. 기억하세요, 이것은 휴리스틱 — 단순한 규칙이 아닌 여러분을 돕기 위한 지침입니다. 이 문서를 발견한 곳에서 질문하거나 의견을 공유해 주세요!\n","ogImage":{"url":"/assets/img/2024-07-01-Agamesounddesignersguidetobuttoninteractions_0.png"},"coverImage":"/assets/img/2024-07-01-Agamesounddesignersguidetobuttoninteractions_0.png","tag":["Tech"],"readingTime":9},{"title":"당신의 생각을 뒤흔들 6개의 오픈소스 프로젝트 ","description":"","date":"2024-07-01 21:17","slug":"2024-07-01-6Open-SourceProjectsThatWillBlowYourMind","content":"\n\n![6 Open-Source Projects That Will Blow Your Mind](/assets/img/2024-07-01-6Open-SourceProjectsThatWillBlowYourMind_0.png)\n\n수백만 개의 오픈 소스 프로젝트가 Github에 있지만, 그 중 몇 가지는 정말 놀라울 만큼 멋지다.\n\n가장 좋은 점은 그들의 코드가 자유롭게 제공되어 언제든지 쉽게 접근하고 원하는 대로 수정할 수 있다는 것이다. 새로운 사이드 프로젝트나 스타트업을 준비해야 할 때라해도, 이…","ogImage":{"url":"/assets/img/2024-07-01-6Open-SourceProjectsThatWillBlowYourMind_0.png"},"coverImage":"/assets/img/2024-07-01-6Open-SourceProjectsThatWillBlowYourMind_0.png","tag":["Tech"],"readingTime":1},{"title":"라이브러리, 프레임워크, API를 처음 사용하는 사람을 위한 가이드","description":"","date":"2024-07-01 21:17","slug":"2024-07-01-IhaveneverusedalibraryframeworkoranAPIIdontknowwhattodo","content":"\n\n![2024-07-01-IhaveneverusedalibraryframeworkoranAPIIdontknowwhattodo_0.png](/assets/img/2024-07-01-IhaveneverusedalibraryframeworkoranAPIIdontknowwhattodo_0.png)\n\n","ogImage":{"url":"/assets/img/2024-07-01-IhaveneverusedalibraryframeworkoranAPIIdontknowwhattodo_0.png"},"coverImage":"/assets/img/2024-07-01-IhaveneverusedalibraryframeworkoranAPIIdontknowwhattodo_0.png","tag":["Tech"],"readingTime":1},{"title":"나쁜 UI 디자인이 내 프로젝트를 망친 이유","description":"","date":"2024-07-01 21:16","slug":"2024-07-01-BadUIDesignSabotagedMyProject","content":"\n\n![image](/assets/img/2024-07-01-BadUIDesignSabotagedMyProject_0.png)\n\nI was a solution architect helping businesses design cloud-based software solutions. Recently, I had a project with a national nonprofit organization aiming to modernize one of their key services.\n\nAbout six months ago, I presented a solution design to the client. I believed that the design effectively addressed the business requirements while...","ogImage":{"url":"/assets/img/2024-07-01-BadUIDesignSabotagedMyProject_0.png"},"coverImage":"/assets/img/2024-07-01-BadUIDesignSabotagedMyProject_0.png","tag":["Tech"],"readingTime":1},{"title":"VS Code 그만 사용하세요 새로운 코드 에디터 Zed 시대의 도래","description":"","date":"2024-07-01 21:16","slug":"2024-07-01-DitchVSCodeTheEraoftheNewCodeEditorZedHasArrived","content":"\n\n![image](/assets/img/2024-07-01-DitchVSCodeTheEraoftheNewCodeEditorZedHasArrived_0.png)\n\n지난 10년 동안 Microsoft의 Visual Studio Code(VS Code)가 개발자들에게 가장 인기있는 텍스트 에디터였습니다. TypeScript, NPM 패키지, GitHub, Azure 및 Edge 브라우저와의 원활한 통합은 개발자들에게 강력한 도구로 작용했습니다. 그러나 기술은 영원히 지배할 수 없다는 말처럼 언젠가는 오래된 기술에 변화가 옵니다. 빠르고 오픈 소스인 Zed가 나타났습니다.","ogImage":{"url":"/assets/img/2024-07-01-DitchVSCodeTheEraoftheNewCodeEditorZedHasArrived_0.png"},"coverImage":"/assets/img/2024-07-01-DitchVSCodeTheEraoftheNewCodeEditorZedHasArrived_0.png","tag":["Tech"],"readingTime":1},{"title":"ArgoCD를 사용해 App of Apps 패턴과 Helm Umbrella Charts로 Kubernetes에 Kube-Prometheus-Stack, Loki, Vault 설치하는 방법","description":"","date":"2024-07-01 00:23","slug":"2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD","content":"\n\n쿠버네티스 배포에서 GitOps 패턴을 사용하는 것은 현대 인프라 및 복잡한 응용 프로그램 배포에서의 게임 체인저입니다. argocd와 같은 도구를 사용하여 응용 프로그램을 git 저장소에 추적하여 저장소에 저장된 매니페스트와 동기화하여 DevOps 및 인프라 코드 관행을 향상시킵니다.\n\n이전 글에서 argocd가 무엇인지와 argo cd를 사용하여 클러스터를 부팅하는 방법을 설명했습니다. 이번 글에서는 argocd를 사용하여 helm 차트를 배포하는 데의 한계와 해결 방법을 살펴보겠습니다.\n\n또한 이 전략을 시연하기 위해 Argocd 앱 오브 앱스 전략을 사용하여 Prometheus, Grafana, Loki 및 Hashicorp의 Vault를 설치할 것입니다.\n\n# ArgoCD Recap\n\n<div class=\"content-ad\"></div>\n\nArgoCD 용어에서 이 용어는 무엇을 의미합니까? 그것에 들어가기 전에 우리가 먼저 ArgoCD가 무엇인지 간단히 소개하겠습니다. ArgoCD는 쿠버네티스 클러스터로의 지속적인 전달 및 배포를 보장하는 도구입니다. 이는 쿠버네티스 컨트롤러로 클러스터에 설치되어 쿠버네티스 리소스를 추적하고 해당 리소스의 상태를 미리 정의된 매니페스트와 비교합니다. 이러한 매니페스트는 응용 프로그램 상태의 단일 진실의 원천이며 ArgoCD는 응용 프로그램이 Git SCM에 정의된 것과 클러스터의 실제 상태와 동기화되도록 보장합니다.\n\n전형적인 예는 쿠버네티스 배포 파일을 git에 저장하고 해당 파일을 argo cd 앱에 연결할 때 발생합니다. ArgoCD는 클러스터에서 배포가 동기화되어 있고 깃허브 저장소에 미리 정의된 것과 일치하는지 확인합니다. 따라서 심지어 클러스터에서 해당 배포를 삭제해도 ArgoCD가 다시 생성하여 Git에 정의된 매니페스트와 동기화되도록 보장합니다.\n\n# 앱의 앱\n\n이전 기사에서 ArgoCD CLI 도구를 사용하여 샘플 ArgoCD 앱을 만들었습니다. 콘솔 UI를 사용하여 앱을 만들 수도 있지만 여러 애플리케이션을 만들어야 하는 상황을 생각해보십시오. UI를 사용하여 계속해서 앱을 만들어야 하거나 이러한 ArgoCD 앱을 만들기 위해 CLI 명령을 계속 실행해야 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\nAnother issue is that creating apps using UI or CLI doesn't align with GitOps practices. We need a method to generate our ArgoCD apps in a Git repository and deploy Kubernetes resources from there as well.\n\nThis is where the concept of \"app of apps\" shines. It's an approach introduced by the ArgoCD team, where you can create a single app using the UI or CLI. This app's sole purpose is to fetch other ArgoCD app manifests from a GitHub repository.\n\n![Screenshot](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_0.png)\n\nBy adopting this strategy, all your ArgoCD app configurations are stored in Git, ensuring adherence to GitOps practices. This way, all application configurations are fully managed within Git.\n\n<div class=\"content-ad\"></div>\n\n그래서 “우산 차트 전략”은 무엇일까요?\n\n## Helm 차트를 ArgoCD로 배포하는 것의 단점들\n\nArgoCD로 자체 관리되는 Helm 차트를 배포하는 것은 게임 체인저입니다. 그러나 한 가지 단점이 있습니다. ArgoCD는 직접 관리하지 않는 Helm 차트에 값을 전달하는 것을 허용하지 않습니다. 예를 들어 bitnami helm 차트를 설치하고자 할 때 자체 값 파일을 전달하려는 경우, ArgoCD 앱 구성에서 직접 지원하지 않습니다.\n\nHelm 값들을 전달하려면 argocd 앱 구성 내부에 직접 넣어야 합니다. 이것이 우리가 원하는 바가 아닙니다. 값이 많은 경우에는 들여쓰기를 어떻게 관리해야 할까요? 동일한 차트의 여러 가지 변형을 만들어야 하는 경우에는 어떻게 해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n# 해결책: 우산 헬름 차트 사용하기\n\n이 문제를 해결하기 위해 argocd에 값 파일을 전달하는 전략으로 헬름 차트 배포에서 사용되는 우산 차트라고 불리는 전략을 활용합니다. 이 전략을 사용하면 단일 헬름 차트를 생성하고 다른 차트를 레포지토리에서 종속성으로 추가하여 설치할 수 있습니다.\n\n![이미지](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_1.png)\n\n주 차트에 이러한 관리되는 외부 차트를 종속성으로 추가하면 값을 첨부할 수 있게 되고, 이후 우산 차트 아래의 해당 값을 argocd 앱으로 지정하여 이러한 앱을 관리할 때 회복력을 확보할 수 있으며, 사용자 지정 값 파일을 argocd 앱 매니페스트에 원활하게 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 개념을 실제로 보기 위해 데모를 배포해 보겠습니다. 함께 따라오려면 작동하는 쿠버네티스 클러스터가 필요합니다. 그런데 없는 경우 AWS EKS에서 클러스터를 생성하기 위한 테라폼 파일을 얻을 수 있는 프로젝트 저장소가 제공됩니다.\n\n# 준비물\n\n이 데모를 따라가려면 다음이 필요합니다.\n\n- 쿠버네티스 클러스터 (없는 경우 테라폼이 제공됩니다)\n- Kubectl 설치하기\n\n<div class=\"content-ad\"></div>\n\n현재 이미 실행 중인 클러스터가 없다면, 아래의 사전 준비물이 필요합니다:\n\n- Terraform 설치\n- AWS 자격 증명\n\n# 쿠버네티스 클러스터 프로비저닝 (옵션)\n\n이 단계에서는 이 기사의 소개 섹션에 제공된 저장소의 terraform 폴더에 있는 terraform 구성을 사용하여 AWS EKS에서 terraform을 사용하여 Kubernetes 클러스터를 프로비저닝합니다.\n\n<div class=\"content-ad\"></div>\n\n디렉토리로 이동한 후 다음 명령을 실행하세요:\n\n```js\nterraform init\nterraform apply --auto-approve\n```\n\n이 terraform 설정은 VPC, 서브넷, EKS 클러스터, 노드 그룹, 3개의 노드 (SPOT)를 생성합니다.\n\n완료하는 데는 약 20분 정도 소요됩니다.\n\n<div class=\"content-ad\"></div>\n\n![Kube-Prometheus](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_2.png)\n\n# ArgoCD 설치하기\n\n클러스터가 프로비저닝되면 다음 명령어를 사용하여 클러스터에 연결합니다.\n\n```js\naws eks update-kubeconfig --region us-east-1 --name realworld-cluster\n```\n\n<div class=\"content-ad\"></div>\n\n컨텍스트가 업데이트되면 다음 명령을 사용하여 kubectl을 사용하여 ArgoCD를 설치합니다:\n\n```shell\nkubectl create namespace argocd\n```\n\n```shell\nkubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\n```\n\n![ArgoCD Installation](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_3.png)\n\n<div class=\"content-ad\"></div>\n\n많은 리소스를 생성합니다. 아래 명령을 사용하여 성공적으로 생성되었는지 확인해 주세요.\n\n```js\nkubectl get pods -n argocd\n```\n\n모든 파드가 실행 중인지 확인해주세요.\n\n\n![이미지](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_4.png)\n\n<div class=\"content-ad\"></div>\n\n이 데모에서는 로드 밸런서가 비용이 많이 들기 때문에 쿠버네티스 서비스에서 로컬 머신으로 포트 포워딩을 사용하여 ArgoCD UI 대시보드에 액세스할 것입니다.\n\n# ArgoCD UI 대시보드에 액세스하기\n\n다음 명령을 사용하여 로컬 브라우저에서 ArgoCD UI에 액세스할 수 있습니다. 터미널을 실행한 채로 두고 다른 터미널을 열어 다른 명령을 실행해 주세요.\n\n\nkubectl port-forward svc/argocd-server -n argocd 8080:443\n\n\n<div class=\"content-ad\"></div>\n\n![2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_5.png](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_5.png)\n\n앞서 제시한 코드를 통해 localhost:8080에서 로컬 브라우저를 통해 argocd에 접속할 수 있습니다. SSL 인증서가 안전하지 않다는 오류가 발생할 경우, '고급'을 선택한 후 argoCD 사이트에 진입하십시오.\n\nArgoCD의 기본 비밀번호를 확인하려면 다음의 명령어를 다른 터미널에서 실행하십시오:\n\n```js\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\"\n```\n\n<div class=\"content-ad\"></div>\n\n비밀번호를 base64로 출력합니다\n\n![이미지](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_6.png)\n\n온라인 base64 도구 https://www.base64decode.org/ 를 사용하여 비밀번호를 디코딩할 수 있습니다.\n\n디코딩된 비밀번호를 사용하여 username으로 admin을 사용하여 argocd에 로그인하세요.\n\n<div class=\"content-ad\"></div>\n\n# 우산 차트 만들기\n\n이 섹션에서는 자식 차트가 포함된 우산 차트를 만들어보겠습니다. 작업 중인 디렉토리에서 다음 명령을 사용하여 helm 차트를 초기화하세요:\n\n```js\nhelm create 우산-차트\n```\n\n이 명령을 실행하면 샘플 nginx helm 차트가 초기화됩니다. 이 차트를 수정하고 다른 종속성을 추가할 것입니다. template 폴더와 values.yaml 파일을 삭제해도 괜찮습니다.\n\n<div class=\"content-ad\"></div>\n\n\napiVersion: v2\nname: umbrella-chart\ndescription: A Helm chart for Kubernetes\n\n\n\ntype: application\nversion: 0.1.0\nappVersion: \"1.16.0\"\ndependencies:\n- name: loki-stack\n  version: 2.10.2\n  repository: https://grafana.github.io/helm-charts\n- name: vault\n  version: 0.28.0\n  repository: https://helm.releases.hashicorp.com\n\n\nIn the dependencies block, you can see that we have added two external charts that we do not manage, the loki-stack and HashiCorp’s Vault. The loki-stack is a Grafana-managed chart that installs Grafana, Loki, Promtail, Prometheus, and some alerting managers.\n\n\n<div class=\"content-ad\"></div>\n\n그래서 재미있는 부분이 여기에 있어요! 동일한 우산 helm 차트 폴더에 loki와 vault용 값을 위한 values 파일을 만들어보세요.\n\n아래의 내용을 loki.yaml에 붙여넣기 해보세요.\n\n```js\ntest_pod:\n  enabled: true\n  image: bats/bats:1.8.2\n  pullPolicy: IfNotPresent\n```\n\n```js\nloki:\n  enabled: true\n  isDefault: true\npromtail:\n  enabled: true\n  config:\n    logLevel: info\n    serverPort: 3101\n    clients:\n      - url: http://{ .Release.Name }:3100/loki/api/v1/push\nfluent-bit:\n  enabled: true\ngrafana:\n  enabled: true\n  sidecar:\n    datasources:\n      label: \"\"\n      labelValue: \"\"\n      enabled: true\n      maxLines: 1000\n  image:\n    tag: 10.3.3\nprometheus:\n  enabled: true\n  isDefault: true\nfilebeat:\n  enabled: true\n  filebeatConfig:\n    filebeat.yml: |\n      # logging.level: debug\n      filebeat.inputs:\n      - type: container\n        paths:\n          - /var/log/containers/*.log\n        processors:\n        - add_kubernetes_metadata:\n            host: ${NODE_NAME}\n            matchers:\n            - logs_path:\n                logs_path: \"/var/log/containers/\"\n      output.logstash:\n        hosts: [\"logstash-loki:5044\"]\nlogstash:\n  enabled: false\n  image: grafana/logstash-output-loki\n  imageTag: 1.0.1\n  filters:\n    main: |-\n      filter {\n        if [kubernetes] {\n          mutate {\n            add_field => {\n              \"container_name\" => \"%{[kubernetes][container][name]}\"\n              \"namespace\" => \"%{[kubernetes][namespace]}\"\n              \"pod\" => \"%{[kubernetes][pod][name]}\"\n            }\n            replace => { \"host\" => \"%{[kubernetes][node][name]}\"}\n          }\n        }\n        mutate {\n          remove_field => [\"tags\"]\n        }\n      }\n  outputs:\n    main: |-\n      output {\n        loki {\n          url => \"http://loki:3100/loki/api/v1/push\"\n          #username => \"test\"\n          #password => \"test\"\n        }\n        # stdout { codec => rubydebug }\n      }\n# proxy is currently only used by loki test pod\n# Note: If http_proxy/https_proxy are set, then no_proxy should include the\n# loki service name, so that tests are able to communicate with the loki\n# service.\nproxy:\n  http_proxy: \"\"\n  https_proxy: \"\"\n  no_proxy: \"\"\n```\n\n<div class=\"content-ad\"></div>\n\n```yaml\nserver:\n  affinity: \"\"\n  ha:\n    enabled: true\n    raft: \n      enabled: true\n```\n\n폴더 구조가 아래 스크린샷과 일치해야 합니다. 기본 차트 구성의 템플릿 폴더와 값을 삭제한 경우 기준으로 합니다.\n\n![스크린샷](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_7.png)\n\n<div class=\"content-ad\"></div>\n\n여기서는 두 종속성을 가진 헬름 우산 차트를 성공적으로 생성했습니다.\n\n# ArgoCD 어플리케이션 생성하기\n\n이 섹션에서는 Loki 스택 및 Hashicorp Vault를 위한 ArgoCD 어플리케이션을 생성할 것입니다. /apps라는 폴더를 만들고, 그 안에 loki.yml 파일을 생성하십시오. 아래 내용을 붙여넣기 하세요:\n\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: loki\nspec:\n  destination:\n    name: ''\n    namespace: monitoring\n    server: 'https://kubernetes.default.svc'\n  source:\n    path: umbrella-chart\n    repoURL: 'https://github.com/philcz16/app-of-apps'\n    targetRevision: HEAD\n    helm:\n      valuesFiles:\n        - loki.yaml\n  project: default\n```\n\n<div class=\"content-ad\"></div>\n\nargocd 마니페스트를 확인하면 umbrella-chart 폴더의 깃허브 저장소를 가리킵니다. 그런 다음 앞서 생성한 loki.yml 값을 파일로 지정합니다. 이 방법을 사용하면 ArgoCD 앱에서 특별히 관리하지 않는 애플리케이션을 위해 값을 파일로 쉽게 지정할 수 있습니다.\n\n이제 HashiCorp Vault 차트에 대해 동일한 작업을 수행해보겠습니다. /apps 폴더에 vault.yml 파일을 생성하세요.\n\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: vault\nspec:\n  destination:\n    name: ''\n    namespace: default\n    server: 'https://kubernetes.default.svc'\n  source:\n    path: umbrella-chart\n    repoURL: 'https://github.com/philcz16/app-of-apps'\n    targetRevision: HEAD\n    helm:\n      valuesFiles:\n        - vault.yaml\n  project: default\n```\n\n마지막으로, 이 개념에 따라 다른 앱들을 만들어낼 ArgoCD 루트 앱을 생성합시다. ArgoCD UI(아직 포트포워드를 사용 중이라면 localhost:8080)로 이동하여 새로운 앱을 만들고 YAML 수정을 선택하세요. 아래의 YAML 내용을 붙여넣기하세요.\n\n<div class=\"content-ad\"></div>\n\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: app-of-apps\n  namespace: argocd\n\nspec:\n  destination:\n    namespace: argocd\n    server: https://kubernetes.default.svc\n  project: default\n  source:\n    path: apps\n    repoURL: https://github.com/philcz16/app-of-apps\n    targetRevision: HEAD\n```\n\nClick Save and click create. For this demo, the sync policy is set to manual, so we will sync the application using the ArgoCD UI. You can see that ArgoCD has picked up the two apps we created in git that will install the helm charts we specified.\n\n![Screenshot](https://example.com/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n로키 스택과 볼트 앱을 동기화하기 전에, 로키 스택이 리소스를 만들 네임스페이스를 미리 생성해주세요.\n\n```js\nkubectl create ns monitoring\n```\n\n로키 애플리케이션을 클릭하고 동기화를 선택해주세요. 서버 측 적용을 확인해주세요. 동기화를 클릭하면 쿠버네티스 클러스터에 모든 모니터링 리소스가 생성됩니다.\n\n![로키 앱](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_10.png)\n\n<div class=\"content-ad\"></div>\n\n한 번 동기화가 완료되면 \"동기화 완료\"라는 응답을 받아야 합니다.\n\n![이미지](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_11.png)\n\n아래 명령어를 사용하여 모니터링 리소스가 성공적으로 생성되었는지 확인할 수 있습니다:\n\n```js\nkubectl get all -n monitoring\n```\n\n<div class=\"content-ad\"></div>\n\n![InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_12](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_12.png)\n\n모든 Loki 리소스가 성공적으로 생성된 것을 확인할 수 있습니다. 이제 Vault 리소스를 생성해 봅시다. Vault 앱을 선택하고 동기화를 클릭하세요. 또한 서버 쪽 적용을 확인해주세요.\n\n![InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_13](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_13.png)\n\nVault 리소스가 성공적으로 생성되었는지 확인하려면 기본 네임스페이스에서 생성된 리소스를 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n마침내 GitOps 워크플로를 시연하기 위해, 우산 helm 차트에 그라파나와 프로메테우스를 배포할 하나의 더 앱을 추가해봅시다. 아래의 코드 블록을 dependencies 아래의 Chart.yml 파일에 추가하여 그라파나와 프로메테우스를 배포합니다.\n\n```js\n- name: kube-prometheus-stack\n  version: 59.1.0\n  repository: https://prometheus-community.github.io/helm-charts\n```\n\n또한 kube-prom.yml이라는 값 파일을 추가하세요. 해당 값 파일의 내용을 사용하거나 글의 저장소에 있는 것을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n`/apps` 폴더에 `kube-prom.yml` 파일을 생성하여 argocd 앱을 만들고 아래 내용을 붙여넣으세요.\n\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: kube-prometheus\nspec:\n  destination:\n    name: ''\n    namespace: monitoring\n    server: 'https://kubernetes.default.svc'\n  source:\n    path: umbrella-chart\n    repoURL: 'https://github.com/philcz16/app-of-apps'\n    targetRevision: HEAD\n    helm:\n      valuesFiles:\n        - kube-prom.yaml\n  sources: []\n  project: default\n```\n\n이 앱은 `umbrella-chart` 폴더의 `kube-prom.yaml` 값을 가리킵니다. 변경 사항을 저장하고 git 저장소에 푸시하세요.\n\n새로운 변경 사항을 푸시하면 ArgoCD에 있는 앱을 동기화하며, 추가한 kube-prometheus 앱이 argocd가 새로 선택한 것을 알 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![Install Kube-Prometheus-Stack Loki and Vault on Kubernetes using App of Apps Pattern and Helm Umbrella Charts with ArgoCD_15.png](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_15.png)\n\nArgoCD UI에서 모든 애플리케이션을 개별적으로 동기화합니다.\n\n![Install Kube-Prometheus-Stack Loki and Vault on Kubernetes using App of Apps Pattern and Helm Umbrella Charts with ArgoCD_16.png](/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_16.png)\n\n# 정리작업\n\n<div class=\"content-ad\"></div>\n\n만약 리포지토리 코드베이스에 제공된 테라폼 스크립트를 따라오셨다면, /terraform 폴더로 이동한 뒤 아래 명령어를 실행해주세요:\n\n\nterraform destroy --auto-approve\n\n\n이 명령어는 테라폼을 사용해 생성된 모든 리소스를 제거합니다.\n\n# 마무리\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 ArgoCD를 사용하여 클러스터에 배포할 때 헬름 차트에 사용자 지정 값 파일을 지정하는 것의 단점을 확인했습니다. 어떤 경우에는 우산 차트 방법을 사용하면 ArgoCD를 사용하여 쿠버네티스 클러스터에 공개 helm 차트를 설치하는 데 완전한 제어력과 유연성을 확보할 수 있습니다.","ogImage":{"url":"/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_0.png"},"coverImage":"/assets/img/2024-07-01-InstallKube-Prometheus-StackLokiandVaultonKubernetesusingAppofAppsPatternandHelmUmbrellaChartswithArgoCD_0.png","tag":["Tech"],"readingTime":15}],"page":"1","totalPageCount":2,"totalPageGroupCount":1,"lastPageGroup":2,"currentPageGroup":0},"__N_SSG":true}