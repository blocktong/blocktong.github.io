{"pageProps":{"post":{"title":"ë£¨ìŠ¤íŠ¸ë¡œ ì›¹ 3 NFT APIë¥¼ êµ¬í˜„í•˜ê¸°","description":"","date":"2024-05-05 17:27","slug":"2024-05-05-ImplementingaWeb3NFTAPIinRust","content":"\n\n![ImplementingaWeb3NFTAPIinRust](/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png)\n\nì•ˆë…•í•˜ì„¸ìš” ëŸ¬ìŠ¤í…Œì´ì…˜ ë¶„ë“¤! ğŸ¦€\n\nì˜¤ëŠ˜ì˜ ê¸€ì—ì„œëŠ” ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ì„ í™œìš©í•˜ì—¬ NFTë¥¼ ë°œí–‰í•˜ëŠ” Rust APIë¥¼ êµ¬í˜„í•´ ë³´ê² ìŠµë‹ˆë‹¤. ë˜í•œ IPFSì™€ì˜ ë¶„ì‚° íŒŒì¼ ì €ì¥ì†Œ í†µí•©, ê·¸ë¦¬ê³  ì†”ë¦¬ë””í‹°ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ êµ¬í˜„ë„ ë‹¤ë£° ì˜ˆì •ì´ì—ìš”.\n\nì´ ê¸€ì„ ë§ˆì¹˜ë©´ swagger-uië¥¼ ì‚¬ìš©í•˜ì—¬ APIì™€ ìƒí˜¸ ì‘ìš©í•  ìˆ˜ ìˆê²Œ ë˜ë©°, Web3, RESTful Rust API, ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸, ê·¸ë¦¬ê³  ì†”ë¦¬ë””í‹°ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì„ ì–´ë–»ê²Œ í†µí•©í•˜ëŠ”ì§€ì— ëŒ€í•œ ê¸°ë³¸ ì§€ì‹ì„ ìŠµë“í•  ìˆ˜ ìˆì„ ê±°ì˜ˆìš”.\n\n\n\nê¸°ëŒ€í•˜ì‹œëŠ” ëŒ€ë¡œ, ëŸ¬ìŠ¤íŠ¸ NFT APIì— ëŒ€í•œ ì´ ê¹Šì€ íƒí—˜ì€ ì •ë³´ê°€ í’ë¶€í•˜ê³  í¥ë¯¸ë¡œìš¸ ê²ƒì…ë‹ˆë‹¤. ë‹¤ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ì“°ëŠ” ê¸€ë³´ë‹¤ ì¡°ê¸ˆ ë” ê¸¸ì–´ì ¸ì„œ ì£„ì†¡í•©ë‹ˆë‹¤. ë³´ë‹¤ ì‹¤ìš©ì ì¸ ì ‘ê·¼ì„ ì„ í˜¸í•˜ì‹œê±°ë‚˜ ì½”ë“œë¥¼ ë” íƒêµ¬í•˜ê³  ì‹¶ì–´í•˜ëŠ” ë¶„ë“¤ì„ ìœ„í•´ ì¢‹ì€ ì†Œì‹ì´ ìˆì–´ìš”!\n\nğŸš€ í”„ë¡œì íŠ¸ë¥¼ ì‹¤í–‰í•˜ê³  ìì„¸íˆ ì‚´í´ë³¼ ìˆ˜ ìˆëŠ” ì „ì²´ ì½”ë“œë² ì´ìŠ¤ì™€ ë‹¨ê³„ë³„ ì§€ì¹¨ì„ https://github.com/luishsr/rust-nft-api GitHub ì €ì¥ì†Œì— ê¹”ë”í•˜ê²Œ ì •ë¦¬í•´ ë†¨ìŠµë‹ˆë‹¤. ì–¸ì œë“ ì§€ ì°¸ì—¬í•˜ì…”ì„œ ì¦ê±°ìš´ ì½”ë”©í•˜ì„¸ìš”!\n\në°”ë¡œ ì‹œì‘í•´ë´…ì‹œë‹¤!\n\n# í”„ë¡œì íŠ¸ êµ¬ì¡° ê°œìš”\n\n\n\ní”„ë¡œì íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤:\n\n\nrust-nft-api/\nâ”œâ”€â”€ contract/\nâ”‚   â””â”€â”€ MyNFT.sol\nâ”œâ”€â”€ nft-images/\nâ”‚   â””â”€â”€ token.jpg\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ main.rs\nâ”‚   â”œâ”€â”€ error.rs\nâ”‚   â”œâ”€â”€ ipfs.rs\nâ”‚   â”œâ”€â”€ model.rs\nâ”‚   â”œâ”€â”€ utils.rs\nâ”‚   â””â”€â”€ web3client.rs\nâ”œâ”€â”€ static/\nâ”‚   â””â”€â”€ swagger-ui/\nâ”œâ”€â”€ .env\nâ””â”€â”€ Cargo.toml\n```\n\n- contract/: NFTì— ëŒ€í•œ Solidity ìŠ¤ë§ˆíŠ¸ ê³„ì•½(MyNFT.sol)ì„ í¬í•¨í•˜ë©°, NFTì˜ ë°œí–‰ ë° ì „ì†¡ ê·œì¹™ì„ ì •ì˜í•©ë‹ˆë‹¤.\n- nft-images/: ê° NFTì™€ ê´€ë ¨ëœ ì´ë¯¸ì§€ ë˜ëŠ” ìì‚°ì„ ì €ì¥í•˜ë©°, NFT ë©”íƒ€ë°ì´í„°ì—ì„œ ì°¸ì¡°ë©ë‹ˆë‹¤.\n- src/: ëŸ¬ìŠ¤íŠ¸ íŒŒì¼ì´ ìˆëŠ” ì†ŒìŠ¤ ë””ë ‰í† ë¦¬ì´ë©°, API ê¸°ëŠ¥ì—ì„œ íŠ¹ì • ëª©ì ì„ ì œê³µí•©ë‹ˆë‹¤:\n  - main.rs: APIì˜ ì§„ì…ì ìœ¼ë¡œ ì„œë²„ ë° ë¼ìš°íŠ¸ ì„¤ì •ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.\n  - error.rs: APIì— ëŒ€í•œ ì‚¬ìš©ì ì§€ì • ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.\n  - ipfs.rs: IPFSì™€ ìƒí˜¸ ì‘ìš©í•˜ì—¬ ì˜¤í”„ì²´ì¸ ë©”íƒ€ë°ì´í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.\n  - model.rs: APIì—ì„œ ì‚¬ìš©ë˜ëŠ” ë°ì´í„° ëª¨ë¸ì„ ì •ì˜í•˜ë©°, NFT ë° ë©”íƒ€ë°ì´í„° êµ¬ì¡°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.\n  - utils.rs: í”„ë¡œì íŠ¸ ì „ì²´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.\n  - web3client.rs: Web3ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ê³¼ì˜ í†µì‹ ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.\n- static/: API ë¬¸ì„œí™”ë¥¼ ìœ„í•œ Swagger UIì™€ ê°™ì€ ì •ì  íŒŒì¼ì„ í¬í•¨í•©ë‹ˆë‹¤.\n- .env: API í‚¤ ë° ë¸”ë¡ì²´ì¸ ë…¸ë“œ URLê³¼ ê°™ì€ í™˜ê²½ ë³€ìˆ˜ë¥¼ ê´€ë¦¬í•˜ëŠ” dotenv íŒŒì¼ì…ë‹ˆë‹¤.\n- Cargo.toml: ì˜ì¡´ì„± ë° í”„ë¡œì íŠ¸ ì •ë³´ë¥¼ ë‚˜ì—´í•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ íŒ¨í‚¤ì§€ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ íŒŒì¼ì…ë‹ˆë‹¤.\n\n# ì£¼ìš” êµ¬ì„± ìš”ì†Œ ë° ê¸°ëŠ¥\n\n\n\n# ìŠ¤ë§ˆíŠ¸ ê³„ì•½ (MyNFT.sol)\n\nì´ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì€ Solidityë¡œ ì‘ì„±ë˜ì–´ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ì— ë°°í¬ë˜ì—ˆìŠµë‹ˆë‹¤. ERC-721 í‘œì¤€ì— ë”°ë¼ NFTì˜ ë°œí–‰, ì´ì „ ë° ê´€ë¦¬ ê·œì¹™ì„ ì •ì˜í•©ë‹ˆë‹¤. ì´ëŠ” ì´ë”ë¦¬ì›€ì—ì„œ NFTì— ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” í‘œì¤€ì…ë‹ˆë‹¤.\n\n# IPFS í†µí•© (ipfs.rs)\n\nIPFS ë˜ëŠ” InterPlanetary File Systemì€ NFTì˜ ì˜¤í”„ì²´ì¸ ë©”íƒ€ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì´ë¯¸ì§€ì™€ ì„¤ëª… ì •ë³´ë¥¼ í¬í•¨í•œ ë©”íƒ€ë°ì´í„°ê°€ ë¶„ì‚°í™”ë˜ê³  ìœ„ë³€ì¡°ë˜ì§€ ì•ŠìŒì„ ë³´ì¥í•©ë‹ˆë‹¤. ipfs.rs ëª¨ë“ˆì€ IPFSë¡œë¶€í„° ë©”íƒ€ë°ì´í„°ë¥¼ ì—…ë¡œë“œí•˜ê³  ê²€ìƒ‰í•˜ëŠ” ì‘ì—…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n\n\n\n# ì›¹3 í´ë¼ì´ì–¸íŠ¸ (web3client.rs)\n\nì´ ëª¨ë“ˆì€ Web3 ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ì— ì—°ê²°ì„ ì„¤ì •í•©ë‹ˆë‹¤. ë¸”ë¡ì²´ì¸ê³¼ ìƒí˜¸ ì‘ìš©í•˜ë„ë¡ APIë¥¼ í™œì„±í™”í•˜ì—¬ NFT ë°œí–‰, NFT ì„¸ë¶€ ì •ë³´ ê²€ìƒ‰ ë° ë¸”ë¡ì²´ì¸ ì´ë²¤íŠ¸ ìˆ˜ì‹ ê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n# API ì—”ë“œí¬ì¸íŠ¸ (main.rs)\n\nmain.rs íŒŒì¼ì€ RESTful API ì„œë²„ë¥¼ ì„¤ì •í•˜ê³  NFT ìƒì„±, í† í° IDë¡œ NFT ì„¸ë¶€ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ë° ëª¨ë“  NFT ë‚˜ì—´ê³¼ ê°™ì€ ë‹¤ì–‘í•œ ì—”ë“œí¬ì¸íŠ¸ì— ëŒ€í•œ ê²½ë¡œë¥¼ ì •ì˜í•©ë‹ˆë‹¤. Actix-web í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•˜ì—¬ HTTP ìš”ì²­ê³¼ ì‘ë‹µì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n\n\n\n# ì—ëŸ¬ ì²˜ë¦¬ ë° ìœ í‹¸ë¦¬í‹° (error.rs, utils.rs)\n\nê°•ë ¥í•œ APIë¥¼ ìœ„í•´ì„œ ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤. error.rs ëª¨ë“ˆì€ ì‚¬ìš©ì ì •ì˜ ì—ëŸ¬ ìœ í˜•ê³¼ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ì„ ì •ì˜í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ëª…í™•í•˜ê³  ìœ ìš©í•œ ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ ë°˜í™˜ë˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤. utils.rs ëª¨ë“ˆì—ëŠ” ë°ì´í„° ìœ íš¨ì„± ê²€ì¦ ë° í˜•ì‹ ì§€ì›ê³¼ ê°™ì€ API ë‚´ì—ì„œ ë‹¤ì–‘í•œ ì‘ì—…ì„ ì§€ì›í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.\n\n# ë‹¨ê³„ 1. ìŠ¤ë§ˆíŠ¸ ê³„ì•½ êµ¬í˜„\n\nSolidityë¡œ ê°œë°œëœ MyNFT ê³„ì•½ì€ ì•ˆì „í•œ ë¸”ë¡ì²´ì¸ ê°œë°œì„ ìœ„í•œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì¸ OpenZeppelinì˜ ERC721URIStorage ê³„ì•½ì„ í™•ì¥í•©ë‹ˆë‹¤. ì´ëŠ” NFT ì†Œìœ ê¶Œì„ í‘œí˜„í•˜ëŠ” ì¸ê¸°ìˆëŠ” í‘œì¤€ì¸ ERC721 í”„ë¡œí† ì½œì„ í™œìš©í•˜ë©° NFTì— URI ê¸°ë°˜ ë©”íƒ€ë°ì´í„°ë¥¼ ì—°ê²°í•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•©ë‹ˆë‹¤.\n\n\n\n## ì£¼ìš” êµ¬ì„± ìš”ì†Œ\n\n- í† í° ì¹´ìš´í„°: OpenZeppelinì˜ Counters ìœ í‹¸ë¦¬í‹°ë¥¼ í™œìš©í•˜ì—¬ ë°œí–‰ëœ ê° NFTì— ëŒ€í•œ ê³ ìœ  ì‹ë³„ìë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.\n- í† í° ì„¸ë¶€ ì •ë³´ êµ¬ì¡°: ê° NFTì— ëŒ€í•œ ì¤‘ìš” ì •ë³´ì¸ ID, ì´ë¦„, ì†Œìœ ì ë° ê´€ë ¨ URIë¥¼ ë³´ìœ í•˜ëŠ” TokenDetails êµ¬ì¡°ì²´ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.\n- ë§¤í•‘: ì„¸ ê°€ì§€ ì£¼ìš” ë§¤í•‘ì´ ì‚¬ìš©ë˜ì–´ NFT ì†Œìœ ê¶Œ ë° ì„¸ë¶€ ì •ë³´ë¥¼ ì¶”ì í•©ë‹ˆë‹¤:\n  - _tokenDetailsëŠ” ê° í† í° IDë¥¼ í•´ë‹¹ TokenDetailsë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.\n  - _ownedTokensëŠ” ì†Œìœ ì ì£¼ì†Œë¥¼ ì†Œìœ í•œ í† í° ID ëª©ë¡ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.\n  - _ownedTokensIndexëŠ” í† í° IDë¥¼ ì†Œìœ ìì˜ í† í° ëª©ë¡ì—ì„œì˜ ìœ„ì¹˜ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract MyNFT is ERC721URIStorage {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    struct TokenDetails {\n        uint256 tokenId;\n        string tokenName;\n        address tokenOwner;\n        string tokenURI;\n    }\n\n    mapping(uint256 => TokenDetails) private _tokenDetails;\n    mapping(address => uint256[]) private _ownedTokens;\n    mapping(uint256 => uint256) private _ownedTokensIndex;  // í† í° IDë¥¼ ì†Œìœ ìì˜ í† í° ëª©ë¡ì—ì„œì˜ ìœ„ì¹˜ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤\n\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    function mintNFT(address recipient, string memory tokenName, string memory tokenURI) public returns (uint256) {\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _mint(recipient, newItemId);\n        _setTokenURI(newItemId, tokenURI);\n\n        _tokenDetails[newItemId] = TokenDetails({\n            tokenId: newItemId,\n            tokenName: tokenName,\n            tokenOwner: recipient,\n            tokenURI: tokenURI\n        });\n\n        _addTokenToOwnerEnumeration(recipient, newItemId);\n\n        return newItemId;\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokens[to].push(tokenId);\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length - 1;\n    }\n\n    function getAllTokensByOwner(address owner) public view returns (uint256[] memory) {\n        if (owner == address(0)) {\n            uint256 totalTokens = _tokenIds.current();\n            uint256[] memory allTokenIds = new uint256[](totalTokens);\n            for (uint256 i = 0; i < totalTokens; i++) {\n                allTokenIds[i] = i + 1;  // í† í° IDëŠ” ë°œí–‰ ë°©ì‹ì— ë”°ë¼ 1ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤\n            }\n            return allTokenIds;\n        } else {\n            return _ownedTokens[owner];\n        }\n    }\n\n    function getTokenDetails(uint256 tokenId) public view returns (uint256, string memory, address, string memory) {\n        require(_ownerOf(tokenId) != address(0), \"ERC721: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í† í°ì— ëŒ€í•œ ì¡°íšŒ\");\n\n        TokenDetails memory tokenDetail = _tokenDetails[tokenId];\n        return (tokenDetail.tokenId, tokenDetail.tokenName, tokenDetail.tokenOwner, tokenDetail.tokenURI);\n    }\n}\n```\n\n# ë‹¨ê³„ 2. Web3Client ì‘ì„±í•˜ê¸°\n\n\n\nThe `web3client.rs` file includes the implementation of the `Web3Client` struct, responsible for enabling interactions with smart contracts on the Ethereum network through the Rust programming language. Let's explore the main features of this implementation.\n\n## Web3Client Structure\n\nThe `Web3Client` struct comprises two primary fields:\n\n- `web3`: An object of the `Web3` type, establishing a link to an Ethereum node.\n- `contract`: A `Contract` instance, representing the smart contract on the Ethereum blockchain that the API will engage with.\n\n\n\n## êµ¬í˜„ ì„¸ë¶€ ì‚¬í•­\n\n- ìƒˆë¡œìš´ í•¨ìˆ˜: ì´ê²ƒì€ Web3Client êµ¬ì¡°ì²´ë¥¼ ìœ„í•œ ìƒì„±ìì…ë‹ˆë‹¤. ì œê³µëœ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ ì£¼ì†Œë¡œ ìƒˆ Web3 ì¸ìŠ¤í„´ìŠ¤ ë° ìƒˆ Contract ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.\n- ì´ë”ë¦¬ì›€ ë…¸ë“œ ì—°ê²°: ETH_NODE_URL í™˜ê²½ ë³€ìˆ˜ë¡œ ì§€ì •ëœ ì´ë”ë¦¬ì›€ ë…¸ë“œì— HTTP ì—°ê²°ì„ ì„¤ì •í•©ë‹ˆë‹¤. ì´ ì—°ê²°ì€ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ìœ¼ë¡œ íŠ¸ëœì­ì…˜ì„ ë³´ë‚´ê±°ë‚˜ í˜¸ì¶œí•˜ëŠ” ë° í•„ìˆ˜ì ì…ë‹ˆë‹¤.\n- ìŠ¤ë§ˆíŠ¸ ê³„ì•½ ABI: Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ê³„ì•½ê³¼ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ë°©ë²•ì„ ì´í•´í•˜ëŠ” ë° ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì˜ ABI(ì‘ìš© í”„ë¡œê·¸ë¨ ì´ì§„ ì¸í„°í˜ì´ìŠ¤)ê°€ í•„ìš”í•©ë‹ˆë‹¤. ABIëŠ” CONTRACT_ABI_PATH í™˜ê²½ ë³€ìˆ˜ë¡œ ì§€ì •ëœ íŒŒì¼ì—ì„œ ë¡œë“œë©ë‹ˆë‹¤. í•´ë‹¹ ABI íŒŒì¼ì€ ì¼ë°˜ì ìœ¼ë¡œ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì´ ì»´íŒŒì¼ë  ë•Œ Solidity ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìƒì„±ë©ë‹ˆë‹¤.\n- ê³„ì•½ ì´ˆê¸°í™”: ABI ë° ìŠ¤ë§ˆíŠ¸ ê³„ì•½ ì£¼ì†Œë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒˆ Contract ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë©ë‹ˆë‹¤. ì´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê±°ë‚˜ í•´ë‹¹ì—ì„œ ë°œìƒí•œ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ê³  ìƒíƒœë¥¼ ì¿¼ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n```rust\nuse std::env;\nuse std::error::Error;\nuse web3::contract::Contract;\nuse web3::transports::Http;\nuse web3::{ethabi, Web3};\n\npub struct Web3Client {\n    pub web3: Web3<Http>,\n    pub contract: Contract<Http>,\n}\n\nimpl Web3Client {\n    pub fn new(contract_address: &str) -> Result<Self, Box<dyn Error>> {\n        let http = Http::new(&env::var(\"ETH_NODE_URL\")?)?;\n        let web3 = Web3::new(http);\n\n        let contract_abi_path = env::var(\"CONTRACT_ABI_PATH\")?;\n        let contract_abi_file = std::fs::File::open(contract_abi_path)?;\n        let contract_abi: ethabi::Contract = serde_json::from_reader(contract_abi_file)?;\n\n        let contract = Contract::new(web3.eth(), contract_address.parse()?, contract_abi);\n\n        Ok(Web3Client { web3, contract })\n    }\n}\n```\n\n# ë‹¨ê³„ 3. ë°ì´í„° êµ¬ì¡°\n\n\n\nì•ˆë…•í•˜ì„¸ìš”! ì˜¤ëŠ˜ì€ Rust NFT API í”„ë¡œì íŠ¸ ë‚´ ëª¨ë¸.rs íŒŒì¼ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ë³´ë ¤ê³  í•´ìš”.\n\ní•´ë‹¹ íŒŒì¼ì€ Rustì˜ ê°•ë ¥í•œ íƒ€ì… ì‹œìŠ¤í…œì„ ì´ìš©í•˜ì—¬ ì£¼ìš” ë°ì´í„° êµ¬ì¡°ë¥¼ ì •ì˜í•˜ë©°, serdeë¥¼ í†µí•œ ì§ë ¬í™” ê¸°ëŠ¥ê³¼ utoipaì˜ API ë¬¸ì„œí™” ê¸°ëŠ¥ì„ ê²°í•©í•˜ê³  ìˆì–´ìš”.\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse utoipa::Component;\n\n#[derive(Serialize, Deserialize, Component)]\npub struct MintNftRequest {\n    pub(crate) owner_address: String,\n    pub(crate) token_name: String,\n    pub(crate) token_uri: String,\n    pub(crate) file_path: String,\n}\n\n#[derive(Serialize, Deserialize, Component)]\npub struct TokenFileForm {\n    file: Vec<u8>,\n}\n\n#[derive(Serialize, Deserialize, Component)]\npub struct ApiResponse {\n    pub(crate) success: bool,\n    pub(crate) message: String,\n    pub(crate) token_uri: Option<String>,\n}\n\n#[derive(Serialize, Deserialize, Component)]\npub struct NftMetadata {\n    pub(crate) token_id: String,\n    pub(crate) owner_address: String,\n    pub(crate) token_name: String,\n    pub(crate) token_uri: String,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct UploadResponse {\n    token_uri: String,\n}\n```\n\n## MintNftRequest\n\nì´ êµ¬ì¡°ëŠ” ìƒˆë¡œìš´ NFTë¥¼ ë°œí–‰í•˜ê¸° ìœ„í•œ ìš”ì²­ ë³¸ë¬¸ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì†Œìœ ì ì£¼ì†Œ, í† í° ì´ë¦„, í† í° URI(í•´ë‹¹ NFTì™€ ê´€ë ¨ëœ ë©”íƒ€ë°ì´í„° ë˜ëŠ” ìì‚°ì„ ê°€ë¦¬í‚´), ê·¸ë¦¬ê³  NFTì™€ ì—°ê²°í•  ìì‚°ì˜ íŒŒì¼ ê²½ë¡œì— ëŒ€í•œ í•„ë“œë¥¼ í¬í•¨í•˜ê³  ìˆì–´ìš”. pub (crate)ì˜ ì‚¬ìš©ì€ ì´ë“¤ í•„ë“œê°€ í¬ë ˆì´íŠ¸ ë‚´ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.\n\në” ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ë©´ ì–¸ì œë“ ì§€ ë¬¼ì–´ë³´ì„¸ìš”! ğŸ˜Š\n\n\n\n# TokenFileForm\n\nTokenFileFormì€ íŒŒì¼ ì—…ë¡œë“œ ì–‘ì‹ì˜ ë°ì´í„° êµ¬ì¡°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤. íŠ¹íˆ NFTì™€ ê´€ë ¨ëœ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê¸° ìœ„í•œ ê²ƒì…ë‹ˆë‹¤. íŒŒì¼ í•„ë“œëŠ” ì—…ë¡œë“œë˜ëŠ” íŒŒì¼ì˜ ë°”ì´ë„ˆë¦¬ ë‚´ìš©ì„ ë‚˜íƒ€ë‚´ëŠ” 'Vec u8'ì˜ ë°”ì´íŠ¸ ë²¡í„°ì…ë‹ˆë‹¤.\n\n## ApiResponse\n\në‹¤ì–‘í•œ API ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ì „ë‹¬í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì¼ë°˜ì ì¸ API ì‘ë‹µ êµ¬ì¡°ì…ë‹ˆë‹¤. ì‘ì—…ì´ ì„±ê³µí–ˆëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì„±ê³µ í”Œë˜ê·¸, ì¶”ê°€ ì •ë³´ ë˜ëŠ” ì˜¤ë¥˜ ì„¸ë¶€ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” ë©”ì‹œì§€, ê·¸ë¦¬ê³  NFTê°€ ê´€ë ¨ëœ ì‘ì—…ì—ì„œ íŠ¹íˆ ì¤‘ìš”í•œ ì˜µì…˜ì¸ token_uriê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” NFTì˜ ë©”íƒ€ë°ì´í„° ë˜ëŠ” ìì‚°ì„ ê°€ë¦¬í‚¤ëŠ” URIê°€ ë°˜í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n\n\n## NftMetadata\n\nNFTì™€ ê´€ë ¨ëœ ë©”íƒ€ë°ì´í„°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. í† í° ID, ì†Œìœ ì ì£¼ì†Œ, í† í° ì´ë¦„ ë° í† í° URIê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ ëª¨ë¸ì€ NFT ì„¸ë¶€ ì •ë³´ë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜ í‘œì‹œí•˜ëŠ” ì‘ì—…ì— ì¤‘ìš”í•©ë‹ˆë‹¤.\n\n## UploadResponse\n\níŒŒì¼ ì—…ë¡œë“œ ì‘ì—…ì— íŠ¹ë³„íˆ ë§ì¶˜ ì´ ëª¨ë¸ì€ ì—…ë¡œë“œ ì‘ì—…ì˜ ì‘ë‹µì„ ìº¡ì²˜í•˜ë©° ì£¼ë¡œ ì—…ë¡œë“œëœ íŒŒì¼ì˜ í† í° URIë¥¼ í¬í•¨í•©ë‹ˆë‹¤. ì´ URIëŠ” ê·¸ í›„ ë¯¼íŒ… í”„ë¡œì„¸ìŠ¤ë‚˜ ì—…ë¡œë“œëœ ìì‚°ì„ ì—°ê²°í•˜ëŠ” ë° í•„ìš”í•œ ë‹¤ë¥¸ ëª©ì ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n\n\n# ë‹¨ê³„ 4. IPFSì™€ ì¸í„°í˜ì´ìŠ¤\n\nëŸ¬ìŠ¤íŠ¸ NFT API í”„ë¡œì íŠ¸ ë‚´ ipfs.rs ëª¨ë“ˆì€ InterPlanetary File System (IPFS)ì™€ì˜ ìƒí˜¸ ì‘ìš©ì„ ì²˜ë¦¬í•˜ëŠ” ë° ì „ë…í•©ë‹ˆë‹¤. IPFSëŠ” ë¶„ì‚°í˜• ì €ì¥ ì†”ë£¨ì…˜ìœ¼ë¡œ, ì˜¤í”„ ì²´ì¸ NFT ë©”íƒ€ë°ì´í„°ë‚˜ ìì‚°ì„ ì €ì¥í•˜ëŠ” ë° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.\n\n```rust\nuse crate::model::ApiResponse;\nuse axum::Json;\nuse reqwest::Client;\nuse serde_json::Value;\nuse std::convert::Infallible;\nuse std::env;\nuse tokio::fs::File;\nuse tokio::io::AsyncReadExt;\n\npub async fn file_upload(file_name: String) -> Result<Json<ApiResponse>, Infallible> {\n    let client = Client::new();\n    let ipfs_api_endpoint = \"http://127.0.0.1:5001/api/v0/add\";\n\n    // í˜„ì¬ ë””ë ‰í† ë¦¬ ê°€ì ¸ì˜¤ê¸°\n    let mut path = env::current_dir().expect(\"Failed to get current directory\");\n    // ê²½ë¡œì— 'nft-images' í•˜ìœ„ ë””ë ‰í† ë¦¬ ì¶”ê°€\n    path.push(\"nft-images\");\n    // íŒŒì¼ ì´ë¦„ì„ ê²½ë¡œì— ì¶”ê°€\n    path.push(file_name);\n\n    //println!(\"Full path: {}\", path.display());\n\n    // íŒŒì¼ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì—´ê¸°\n    let mut file = File::open(path.clone()).await.expect(\"Failed to open file\");\n\n    // íŒŒì¼ ë°”ì´íŠ¸ ì½ê¸°\n    let mut file_bytes = Vec::new();\n    file.read_to_end(&mut file_bytes)\n        .await\n        .expect(\"Failed to read file bytes\");\n\n    // ê²½ë¡œì—ì„œ íŒŒì¼ ì´ë¦„ ì¶”ì¶œ\n    let file_name = path\n        .file_name()\n        .unwrap()\n        .to_str()\n        .unwrap_or_default()\n        .to_string();\n\n    let form = reqwest::multipart::Form::new().part(\n        \"file\",\n        reqwest::multipart::Part::stream(file_bytes).file_name(file_name),\n    );\n\n    let response = client\n        .post(ipfs_api_endpoint)\n        .multipart(form)\n        .send()\n        .await\n        .expect(\"Failed to send file to IPFS\");\n\n    if response.status().is_success() {\n        let response_body = response\n            .text()\n            .await\n            .expect(\"Failed to read response body as text\");\n\n        let ipfs_response: Value =\n            serde_json::from_str(&response_body).expect(\"Failed to parse IPFS response\");\n        let ipfs_hash = format!(\n            \"https://ipfs.io/ipfs/{}\",\n            ipfs_response[\"Hash\"].as_str().unwrap_or_default()\n        );\n\n        Ok(Json(ApiResponse {\n            success: true,\n            message: \"File uploaded to IPFS successfully.\".to_string(),\n            token_uri: Some(ipfs_hash),\n        }))\n    } else {\n        Ok(Json(ApiResponse {\n            success: false,\n            message: \"IPFS upload failed.\".to_string(),\n            token_uri: None,\n        }))\n    }\n}\n```\n\nì²˜ë¦¬ íë¦„\n\n\n\n### ì´ˆê¸° ì„¤ì •:\nReqwestë¡œ HTTP ìš”ì²­ì„ ë³´ë‚´ê¸° ìœ„í•´ Client ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë©ë‹ˆë‹¤.\n\n### íŒŒì¼ ê²½ë¡œ êµ¬ì„±:\ní•´ë‹¹ í•¨ìˆ˜ëŠ” í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬, nft-images í•˜ìœ„ ë””ë ‰í† ë¦¬ ë° ì œê³µëœ íŒŒì¼ ì´ë¦„ì„ ê²°í•©í•˜ì—¬ íŒŒì¼ ê²½ë¡œë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.\n\n### íŒŒì¼ ì½ê¸°:\nì§€ì •ëœ íŒŒì¼ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì—´ê³  ì½ì–´ì„œ í•´ë‹¹ ë°”ì´íŠ¸ë¥¼ ë²¡í„°ë¡œ ìˆ˜ì§‘í•©ë‹ˆë‹¤.\n\n### í¼ ì¤€ë¹„:\níŒŒì¼ ë°”ì´íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ë©€í‹°íŒŒíŠ¸ í¼ì„ ì¤€ë¹„í•˜ê³ , íŒŒì¼ ì´ë¦„ì„ í¼ ë°ì´í„°ì˜ ì¼ë¶€ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\n\n\n**IPFS API ìš”ì²­:** IPFS ë…¸ë“œì˜ add ì—”ë“œí¬ì¸íŠ¸ (/api/v0/add)ë¡œ ë©€í‹°íŒŒíŠ¸ í¼ì„ ì „ì†¡í•˜ëŠ” POST ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤.\n\n**ì‘ë‹µ ì²˜ë¦¬:**\n\n- ì„±ê³µ ì‹œ, IPFS ì‘ë‹µì„ êµ¬ë¬¸ ë¶„ì„í•˜ì—¬ íŒŒì¼ì˜ IPFS í•´ì‹œë¥¼ ì¶”ì¶œí•˜ê³ , í•´ë‹¹ íŒŒì¼ì„ IPFS ê²Œì´íŠ¸ì›¨ì´ë¥¼ í†µí•´ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆëŠ” URLì„ êµ¬ì„±í•œ í›„, ì´ URLì´ í¬í•¨ëœ ì„±ê³µì ì¸ ApiResponseë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\n- ì‹¤íŒ¨ ì‹œ, ì—…ë¡œë“œ ì‹¤íŒ¨ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ApiResponseë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\n\n**ë‹¨ê³„ 5. ì—ëŸ¬ ì²˜ë¦¬**\n\n\n\nì—ëŸ¬.rs íŒŒì¼ì€ ì‘ìš© í”„ë¡œê·¸ë¨ ì‘ë™ ì¤‘ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì—ëŸ¬ ìœ í˜•ì„ ì •ì˜í•˜ê³  ê´€ë¦¬í•˜ëŠ” ë° ì „ë…ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ ëª¨ë“ˆì€ ì‚¬ìš©ì ì •ì˜ ì—ëŸ¬ ìœ í˜•ì„ ì •ì˜í•˜ëŠ” ë° thiserror í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ê³  ì´ëŸ¬í•œ ì—ëŸ¬ë¥¼ ì ì ˆí•œ HTTP ì‘ë‹µìœ¼ë¡œ ë§¤í•‘í•˜ëŠ” axum í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ íŒŒì¼ ë‚´ì—ì„œ ì—ëŸ¬ ì²˜ë¦¬ê°€ ì–´ë–»ê²Œ êµ¬ì¡°í™”ë˜ì–´ ìˆëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:\n\n```rust\nuse axum::{\n    http::StatusCode,\n    response::{IntoResponse, Response},\n    Json,\n};\nuse serde_json::json;\nuse thiserror::Error;\n\n// `thiserror`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš©ì ì •ì˜ ì‘ìš© í”„ë¡œê·¸ë¨ ì—ëŸ¬ ìœ í˜• ì •ì˜\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"ì˜ëª»ëœ ìš”ì²­: {0}\")]\n    BadRequest(String),\n\n    #[error(\"ë‚´ë¶€ ì„œë²„ ì—ëŸ¬: {0}\")]\n    InternalServerError(String),\n\n    #[error(\"Web3 ì—ëŸ¬: {0}\")]\n    Web3Error(#[from] web3::Error),\n\n    #[error(\"ì§ë ¬í™” ì—ëŸ¬: {0}\")]\n    SerdeError(#[from] serde_json::Error),\n\n    #[error(\"ë‚´ë¶€ ì—ëŸ¬: {0}\")]\n    GenericError(String),\n\n    #[error(\"ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì—ëŸ¬: {0}\")]\n    NotFound(String),\n}\n\nimpl From<Box<dyn std::error::Error>> for AppError {\n    fn from(err: Box<dyn std::error::Error>) -> Self {\n        AppError::GenericError(format!(\"ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {}\", err))\n    }\n}\n\n// `AppError`ë¥¼ `IntoResponse`ì— êµ¬í˜„í•˜ì—¬ HTTP ì‘ë‹µìœ¼ë¡œ ë³€í™˜\nimpl IntoResponse for AppError {\n    fn into_response(self) -> Response {\n        let (status, error_message) = match &self {\n            AppError::BadRequest(message) => (StatusCode::BAD_REQUEST, message.clone()),\n            AppError::InternalServerError(message) => {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.clone())\n            }\n            AppError::Web3Error(message) => {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.to_string())\n            }\n            AppError::SerdeError(message) => {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.to_string())\n            }\n            AppError::GenericError(message) => (StatusCode::INTERNAL_SERVER_ERROR, message.clone()),\n            AppError::NotFound(message) => (StatusCode::INTERNAL_SERVER_ERROR, message.clone()),\n        };\n\n        let body = Json(json!({ \"error\": error_message })).into_response();\n        (status, body).into_response()\n    }\n}\n\n// íŒŒì¼ ì—…ë¡œë“œ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ì‚¬ìš©ì ì •ì˜ UploadError ìœ í˜•\n#[derive(Error, Debug)]\npub enum UploadError {\n    #[error(\"IO ì—ëŸ¬: {0}\")]\n    IoError(#[from] std::io::Error),\n}\n\n#[derive(Error, Debug)]\npub enum SignatureError {\n    #[error(\"Hex ë””ì½”ë”© ì—ëŸ¬: {0}\")]\n    HexDecodeError(#[from] hex::FromHexError),\n}\n\nimpl From<SignatureError> for AppError {\n    fn from(err: SignatureError) -> AppError {\n        match err {\n            SignatureError::HexDecodeError(_) => {\n                AppError::BadRequest(\"ì˜ëª»ëœ hex í˜•ì‹\".to_string())\n            }\n        }\n    }\n}\n\n// `UploadError`ë¥¼ `IntoResponse`ì— êµ¬í˜„í•˜ì—¬ HTTP ì‘ë‹µìœ¼ë¡œ ë³€í™˜\nimpl IntoResponse for UploadError {\n    fn into_response(self) -> Response {\n        let (status, error_message) = match self {\n            UploadError::IoError(_) => (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                \"ë‚´ë¶€ ì„œë²„ ì—ëŸ¬\".to_string(),\n            ),\n        };\n\n        let body = Json(json!({ \"error\": error_message })).into_response();\n        (status, body).into_response()\n    }\n}\n```\n\n## ì‚¬ìš©ì ì •ì˜ ì‘ìš© í”„ë¡œê·¸ë¨ ì—ëŸ¬ ìœ í˜•\n\n- AppError: ì‘ìš© í”„ë¡œê·¸ë¨ì˜ ì£¼ìš” ì—ëŸ¬ ìœ í˜•ìœ¼ë¡œ, ì˜ëª»ëœ ìš”ì²­, ë‚´ë¶€ ì„œë²„ ì—ëŸ¬ ë° Web3 ìƒí˜¸ ì‘ìš©, ì§ë ¬í™” ë¬¸ì œ ë° ì¼ë°˜ì ì¸ ì—ëŸ¬ì™€ ê´€ë ¨ëœ íŠ¹ì • ì—ëŸ¬ì™€ ê°™ì€ ë‹¤ì–‘í•œ ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ í¬ê´„í•©ë‹ˆë‹¤. AppErrorì˜ ê° ë³€í˜•ì€ ì„¤ëª…ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì—ëŸ¬ ì‘ë‹µì˜ ë””ë²„ê¹… ë° ì‚¬ìš©ì ì¹œí™”ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.\n- UploadError ë° SignatureError: ì´ë“¤ì€ ê°ê° íŒŒì¼ ì—…ë¡œë“œ ì—ëŸ¬ ë° ì„œëª… ê´€ë ¨ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ íŠ¹ìˆ˜í™”ëœ ì—ëŸ¬ ìœ í˜•ì…ë‹ˆë‹¤. AppErrorì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë‹¤ì–‘í•œ ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤ì— ëŒ€í•´ íŠ¹ì • ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n\n\n\n## ì˜¤ë¥˜ ë³€í™˜\n\n- From íŠ¸ë ˆì´íŠ¸ëŠ” ë³´ë‹¤ ë„“ì€ ì˜¤ë¥˜ ìœ í˜•(std::io::Error ë° hex::FromHexErrorì™€ ê°™ì€)ì—ì„œ êµ¬ì²´ì ì¸ ì‘ìš© í”„ë¡œê·¸ë¨ ì˜¤ë¥˜(UploadError ë° SignatureError)ë¡œì˜ ë³€í™˜ì„ í—ˆìš©í•˜ê¸° ìœ„í•´ êµ¬í˜„ë©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ë‹¤ì–‘í•œ ì˜¤ë¥˜ ì›ì²œì„ ì˜ ì •ì˜ëœ ë²”ì£¼ë¡œ ìº¡ìŠí™”í•˜ì—¬ ì‘ìš© í”„ë¡œê·¸ë¨ì˜ ë‹¤ì–‘í•œ ë¶€ë¶„ì—ì„œ ì›í™œí•œ ì˜¤ë¥˜ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n\n## ì˜¤ë¥˜ ì‘ë‹µ\n\n- AppError, UploadError ë° SignatureErrorì— ëŒ€í•œ IntoResponse íŠ¸ë ˆì´íŠ¸ êµ¬í˜„ì€ ì´ëŸ¬í•œ ì˜¤ë¥˜ë¥¼ HTTP ì‘ë‹µìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ì˜¤ë¥˜ ìœ í˜• ë° í•´ë‹¹ ë©”ì‹œì§€ì— ë”°ë¼ ì í•©í•œ HTTP ìƒíƒœ ì½”ë“œ(ì˜ˆ: StatusCode::BAD_REQUEST ë˜ëŠ” StatusCode::INTERNAL_SERVER_ERROR)ê°€ ì„ íƒë©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ JSON ê°ì²´ë¡œ ì§ë ¬í™”ë˜ì–´ API ì†Œë¹„ìë¥¼ ìœ„í•œ ì¼ê´€ëœ ë° ì •ë³´ ì œê³µì´ ë˜ëŠ” ì˜¤ë¥˜ ì‘ë‹µ í˜•ì‹ì„ ì œê³µí•©ë‹ˆë‹¤.\n\n\n\n# Step 6. ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜\n\nutils.rs ëª¨ë“ˆì€ ì•”í˜¸í™” ë°©ì‹ìœ¼ë¡œ ê°œì¸ í‚¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ì— ì„œëª…í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ë¸”ë¡ì²´ì¸ íŠ¸ëœì­ì…˜ì´ë‚˜ ì•ˆì „í•œ ë°ì´í„° êµí™˜ê³¼ ê°™ì´ ë°ì´í„°ì˜ ì‹ ë¢°ì„±ê³¼ ë¬´ê²°ì„±ì„ í™•ì¸í•´ì•¼ í•˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ íŠ¹íˆ ìœ ìš©í•©ë‹ˆë‹¤.\n\n```rust\nuse secp256k1::{Message, Secp256k1, SecretKey};\nuse sha3::{Digest, Keccak256};\nuse std::error::Error;\n\npub fn mock_sign_data(data: &[u8], private_key_hex: &str) -> Result<String, Box<dyn Error>> {\n    // 16ì§„ìˆ˜ ê°œì¸ í‚¤ë¥¼ ë””ì½”ë“œí•©ë‹ˆë‹¤\n    let private_key = SecretKey::from_slice(&hex::decode(private_key_hex)?)?;\n\n    // ìƒˆë¡œìš´ Secp256k1 ì»¨í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤\n    let secp = Secp256k1::new();\n\n    // Keccak256ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° í•´ì‹±\n    let data_hash = Keccak256::digest(data);\n\n    // í•´ì‹œì— ì„œëª…í•©ë‹ˆë‹¤\n    let message = Message::from_digest_slice(&data_hash)?;\n    let signature = secp.sign_ecdsa(&message, &private_key);\n\n    // ì„œëª…ì„ 16ì§„ìˆ˜ë¡œ ì¸ì½”ë”©í•©ë‹ˆë‹¤\n    Ok(hex::encode(signature.serialize_compact()))\n}\n```\n\ní”„ë¡œì„¸ìŠ¤:\n\n\n\n### Hex Decoding: \nThe process kicks off with the hex::decode function, which decodes the hexadecimal private key into bytes.\n\n### Private Key Preparation: \nNext up, the decoded bytes are transformed into a SecretKey instance that aligns with the secp256k1 cryptographic library.\n\n### Hashing: \nThe data undergoes hashing through the Keccak256 algorithm, a variation of SHA-3 extensively utilized in Ethereum for hashing operations.\n\n### Signing: \nSubsequently, the hash gets enveloped in a Message type, and the secp256k1 library steps in to sign this message with the designated private key.\n\n\n\n16ì§„ìˆ˜ ì¸ì½”ë”©: ë§ˆì§€ë§‰ìœ¼ë¡œ, ì„œëª…ì€ ê°„ê²°í•œ í˜•ì‹ìœ¼ë¡œ ì§ë ¬í™”ë˜ì–´ ì‰¬ìš´ ì „ì†¡ê³¼ ì €ì¥ì„ ìœ„í•´ 16ì§„ìˆ˜ ë¬¸ìì—´ë¡œ ì¸ì½”ë”©ë©ë‹ˆë‹¤.\n\n## ì•”í˜¸ ë¼ì´ë¸ŒëŸ¬ë¦¬\n\n- ì´ ê¸°ëŠ¥ì€ secp256k1 ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•˜ì—¬ íƒ€ì› ê³¡ì„  ì•”í˜¸í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì´ë”ë¦¬ì›€ê³¼ ë¹„íŠ¸ì½”ì¸ì—ì„œ ì„œëª… ìƒì„± ë° í™•ì¸ì— ì‚¬ìš©ë˜ëŠ” secp256k1 ê³¡ì„ ì„ íŠ¹ë³„íˆ ì§€ì›í•©ë‹ˆë‹¤.\n- sha3 í¬ë ˆì´íŠ¸ëŠ” Keccak256 í•´ì‹œ ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„ì„ ì œê³µí•˜ì—¬, ë°ì´í„° ì„œëª… í”„ë¡œì„¸ìŠ¤ê°€ ë¸”ë¡ì²´ì¸ ê¸°ìˆ ì—ì„œ í”íˆ ì‚¬ìš©ë˜ëŠ” ì•”í˜¸í™” ê´€í–‰ê³¼ ì¼ì¹˜í•¨ì„ ë³´ì¥í•©ë‹ˆë‹¤.\n\n# ë‹¨ê³„ 7. í•µì‹¬ API êµ¬í˜„\n\n\n\n`main.rs` íŒŒì¼ì€ Rust NFT APIì˜ ì§„ì…ì  ì—­í• ì„ í•˜ë©°, ë‹¤ì–‘í•œ êµ¬ì„± ìš”ì†Œë¥¼ ì¡°ì •í•˜ì—¬ NFT ê´€ë¦¬ë¥¼ ìœ„í•œ í¬ê´„ì ì¸ ë°±ì—”ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ê° ì½”ë“œ ì„¹ì…˜ë³„ë¡œ ì„¤ëª…ê³¼ í•¨ê»˜ ì•„ë˜ì™€ ê°™ì´ ì½”ë“œë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:\n\n## OpenAPI ìŠ¤í‚¤ë§ˆ ìƒì„±\n\n```rust\n#[derive(utoipa::OpenApi)]\n#[openapi(\n    handlers(process_mint_nft, get_nft_metadata, list_tokens),\n    components(MintNftRequest, NftMetadata)\n)]\nstruct ApiDoc;\n\n// OpenAPI ìŠ¤í‚¤ë§ˆì˜ JSON ë²„ì „ ë°˜í™˜\n#[utoipa::path(\n    get,\n    path = \"/api/openapi.json\",\n    responses(\n        (status = 200, description = \"JSON íŒŒì¼\", body = Json)\n    )\n)]\nasync fn openapi() -> Json<utoipa::openapi::OpenApi> {\n    Json(ApiDoc::openapi())\n}\n```\n\nì´ í•¨ìˆ˜ëŠ” JSON í˜•ì‹ìœ¼ë¡œ OpenAPI ìŠ¤í‚¤ë§ˆë¥¼ ìƒì„±í•˜ë©°, ê°œë°œìë“¤ì—ê²Œ API ì—”ë“œí¬ì¸íŠ¸, ìš”ì²­ ë³¸ë¬¸ ë° ì‘ë‹µì˜ ëª…í™•í•œ ëª…ì„¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ëŠ” API ë°œê²¬ ë° ìƒí˜¸ ì‘ìš©ì„ ë•ëŠ” OpenAPI ë¬¸ì„œí™”ë¥¼ ìœ„í•´ utoipa í¬ë ˆì´íŠ¸ë¥¼ í™œìš©í•©ë‹ˆë‹¤.\n\n\n\n## NFT Minting Endpoint\n\n```js\nasync fn process_mint_nft(\n    Extension(web3_client): Extension<Arc<Web3Client>>,\n    Json(payload): Json<MintNftRequest>,\n) -> Result<Json<NftMetadata>, AppError> {\n#[utoipa::path(\npost,\n    path = \"/mint\",\n    request_body = MintNftRequest,\nresponses(\n    (status = 200, description = \"NFT minted successfully\", body = NftMetadata),\n    (status = 400, description = \"Bad Request\"),\n    (status = 500, description = \"Internal Server Error\")\n)\n)]\nasync fn process_mint_nft(\n    Extension(web3_client): Extension<Arc<Web3Client>>,\n    Json(payload): Json<MintNftRequest>,\n) -> Result<Json<NftMetadata>, AppError> {\n    let owner_address = payload\n        .owner_address\n        .parse::<Address>()\n        .map_err(|_| AppError::BadRequest(\"Invalid owner address\".into()))?;\n\n    // Retrieve the mock private key from environment variables\n    let mock_private_key = env::var(\"MOCK_PRIVATE_KEY\").expect(\"MOCK_PRIVATE_KEY must be set\");\n\n    // Simulate data to be signed\n    let data_to_sign = format!(\"{}:{}\", payload.owner_address, payload.token_name).into_bytes();\n\n    // Perform mock signature\n    let _mock_signature = mock_sign_data(&data_to_sign, &mock_private_key)?;\n\n    let upload_response = match ipfs::file_upload(payload.file_path.clone()).await {\n        Ok(response) => response,\n        Err(_) => unreachable!(), // Since Err is Infallible, this branch will never be executed\n    };\n\n    let uploaded_token_uri = upload_response.token_uri.clone().unwrap();\n\n    // Call mint_nft using the file_url as the token_uri\n    let token_id = mint_nft(\n        &web3_client.web3,\n        &web3_client.contract,\n        owner_address,\n        uploaded_token_uri.clone(),\n        payload.token_name.clone(),\n    )\n    .await\n    .map_err(|e| AppError::InternalServerError(format!(\"Failed to mint NFT: {}\", e)))?;\n\n    Ok(Json(NftMetadata {\n        token_id: token_id.to_string(),\n        owner_address: payload.owner_address,\n        token_name: payload.token_name,\n        token_uri: uploaded_token_uri.clone(),\n    }))\n}    \n\n\n}\n```\n\nìœ„ ì½”ë“œëŠ” NFT Minting Endpointì— ëŒ€í•œ ë‚´ìš©ì…ë‹ˆë‹¤. í•´ë‹¹ ì—”ë“œí¬ì¸íŠ¸ëŠ” ìƒˆë¡œìš´ NFTë¥¼ ë°œí–‰í•˜ëŠ” ìš”ì²­ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤. MintNftRequest í˜ì´ë¡œë“œë¥¼ í†µí•´ NFT ì†Œìœ ìì˜ ì£¼ì†Œ, í† í° ì´ë¦„ ë° íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥ë°›ìŠµë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ëª¨ì˜ ì„œëª… ì‘ì—…ì„ ìˆ˜í–‰í•˜ê³ , ì—°ê´€ëœ íŒŒì¼ì„ IPFSì— ì—…ë¡œë“œí•˜ë©°, ìŠ¤ë§ˆíŠ¸ ê³„ì•½ê³¼ ìƒí˜¸ì‘ìš©í•˜ì—¬ NFTë¥¼ ë°œí–‰í•˜ê³  ì„±ê³µ ì‹œ NFT ë©”íƒ€ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n\n## NFT Metadata Retrieval Endpoint\n\n\n\n```rust\n#[utoipa::path(\nget,\n    path = \"/nft/{token_id}\",\nparams(\n    (\"token_id\" = String, )),\nresponses(\n    (status = 200, description = \"NFT ë©”íƒ€ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤\", body = NftMetadata),\n    (status = 400, description = \"ì˜ëª»ëœ ìš”ì²­\"),\n    (status = 500, description = \"ë‚´ë¶€ ì„œë²„ ì˜¤ë¥˜\")\n)\n)]\nasync fn get_nft_metadata(\n    Extension(web3_client): Extension<Arc<Web3Client>>,\n    Path(token_id): Path<String>,\n) -> Result<Json<NftMetadata>, AppError> {\n    let parsed_token_id = token_id\n        .parse::<U256>()\n        .map_err(|_| AppError::BadRequest(\"ì˜ëª»ëœ í† í° ID\".into()))?;\n\n    match get_nft_details(&web3_client.contract, parsed_token_id.to_string()).await {\n        Ok((_, token_name, token_owner, token_uri)) => {\n            // í† í°ì„ ìœ„í•œ NftMetadata êµ¬ì„±\n            let nft_metadata = NftMetadata {\n                token_id: parsed_token_id.to_string(),\n                owner_address: format!(\"{:?}\", token_owner),\n                token_name,\n                token_uri,\n            };\n\n            Ok(Json(nft_metadata))\n        }\n        Err(AppError::NotFound(msg)) => Err(AppError::NotFound(msg)),\n        Err(_) => Err(AppError::InternalServerError(\n            \"NFT ì„¸ë¶€ ì •ë³´ë¥¼ ê²€ìƒ‰í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤\".into(),\n        )),\n    }\n}\n```\n\nì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” í† í° IDë¥¼ ì œê³µë°›ì•„ í•´ë‹¹ NFTì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤. í† í°ì˜ ì´ë¦„ ë° URIì™€ ê°™ì€ ì„¸ë¶€ ì •ë³´ë¥¼ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì—ì„œ ì¿¼ë¦¬í•˜ì—¬ NFTì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ì œê³µí•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì„ ì œê³µí•©ë‹ˆë‹¤.\n\n## NFT ë¦¬ìŠ¤íŠ¸ ì—”ë“œí¬ì¸íŠ¸\n\n```rust\n#[utoipa::path(\nget,\n    path = \"/tokens/{owner_address}\",\nparams(\n    (\"owner_address\" = Option<String>, description = \"í† í°ì„ ì†Œìœ ìë³„ë¡œ í•„í„°ë§í•  ì†Œìœ ì ì£¼ì†Œ. ëª¨ë“  í† í°ì„ ë‚˜ì—´í•˜ë ¤ë©´ ìœ í˜• 0ì„ ì…ë ¥í•˜ì‹­ì‹œì˜¤.\")\n),\nresponses(\n    (status = 200, description = \"í† í° ëª©ë¡ì´ ì„±ê³µì ìœ¼ë¡œ ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤\", body = [NftMetadata]),\n    (status = 400, description = \"ì˜ëª»ëœ ìš”ì²­\"),\n    (status = 500, description = \"ë‚´ë¶€ ì„œë²„ ì˜¤ë¥˜\")\n)\n)]\n\nasync fn list_tokens(\n    Extension(web3_client): Extension<Arc<Web3Client>>,\n    token_owner: Option<Path<String>>,\n) -> Result<Json<Vec<NftMetadata>>, StatusCode> {\n    let owner_address = match token_owner {\n        Some(ref owner) if owner.0 != \"0\" => match owner.0.parse::<Address>() {\n            // ì†Œìœ ìê°€ \"0\"ì´ ì•„ë‹Œì§€ í™•ì¸\n            Ok(addr) => addr,\n            Err(_) => return Err(StatusCode::BAD_REQUEST),\n        },\n        _ => Address::default(), // \"0\" ë˜ëŠ” ì—†ìŒì„ ëª¨ë“  í† í°ì„ ë‚˜ì—´í•˜ëŠ” í‘œì‹œë¡œ ì·¨ê¸‰\n    };\n\n    let token_ids =\n        match get_all_owned_tokens(&web3_client.web3, &web3_client.contract, owner_address).await {\n            Ok(ids) => ids,\n            Err(_) => return Err(StatusCode::INTERNAL_SERVER_ERROR),\n        };\n\n    let mut nft_metadata_list = Vec::new();\n    for token_id in token_ids {\n        match get_nft_details(&web3_client.contract, token_id.to_string()).await {\n            Ok((_, token_name, _onwer, token_uri)) => {\n                let nft_metadata = NftMetadata {\n                    token_id: token_id.to_string(),\n                    owner_address: _onwer.to_string(),\n                    token_name,\n                    token_uri,\n                };\n                nft_metadata_list.push(nft_metadata);\n            }\n            Err(e) => eprintln!(\"í† í° {}ì— ëŒ€í•œ ë©”íƒ€ë°ì´í„° ê²€ìƒ‰ ì‹¤íŒ¨: {:?}\", token_id, e), // í•„ìš”ì— ë”°ë¼ ë¡œê·¸ ë˜ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬\n        }\n    }\n\n    Ok(Json(nft_metadata_list))\n}\n```\n\n\n\n**list_tokens** ì—”ë“œí¬ì¸íŠ¸ëŠ” íŠ¹ì • ì£¼ì†Œê°€ ì†Œìœ í•œ ëª¨ë“  NFTë¥¼ ë‚˜ì—´í•˜ê±°ë‚˜ íŠ¹ë³„í•œ ë§¤ê°œë³€ìˆ˜ê°€ ì œê³µëœ ê²½ìš° ëª¨ë‘ ë°œí–‰ëœ NFTë¥¼ ë‚˜ì—´í•©ë‹ˆë‹¤. ì´ëŠ” ìŠ¤ë§ˆíŠ¸ ê³„ì•½ìœ¼ë¡œ ì†Œìœ í•œ í† í° IDë¥¼ ì¡°íšŒí•˜ê³  ê°ê°ì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê³¼ì •ì„ í¬í•¨í•©ë‹ˆë‹¤.\n\n## NFT ìƒì„± ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜\n\n```rust\n#[utoipa::path(\npost,\n    path = \"/mint\",\n    request_body = MintNftRequest,\nresponses(\n    (status = 200, description = \"NFTê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë¨\", body = NftMetadata),\n    (status = 400, description = \"ì˜ëª»ëœ ìš”ì²­\"),\n    (status = 500, description = \"ë‚´ë¶€ ì„œë²„ ì˜¤ë¥˜\")\n)\n)]\nasync fn process_mint_nft(\n    Extension(web3_client): Extension<Arc<Web3Client>>,\n    Json(payload): Json<MintNftRequest>,\n) -> Result<Json<NftMetadata>, AppError> {\n    let owner_address = payload\n        .owner_address\n        .parse::<Address>()\n        .map_err(|_| AppError::BadRequest(\"ìœ íš¨í•˜ì§€ ì•Šì€ ì†Œìœ ì ì£¼ì†Œ\".into()))?;\n\n    // í™˜ê²½ ë³€ìˆ˜ì—ì„œ ëª¨ì˜ ê°œì¸ í‚¤ ê°€ì ¸ì˜¤ê¸°\n    let mock_private_key = env::var(\"MOCK_PRIVATE_KEY\").expect(\"MOCK_PRIVATE_KEYê°€ ì„¤ì •ë˜ì–´ ìˆì–´ì•¼ í•¨\");\n\n    // ì„œëª…ë  ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜\n    let data_to_sign = format!(\"{}:{}\", payload.owner_address, payload.token_name).into_bytes();\n\n    // ëª¨ì˜ ì„œëª… ìˆ˜í–‰\n    let _mock_signature = mock_sign_data(&data_to_sign, &mock_private_key)?;\n\n    let upload_response = match ipfs::file_upload(payload.file_path.clone()).await {\n        Ok(response) => response,\n        Err(_) => unreachable!(), // Errì€ Infallibleì´ë¯€ë¡œ ì´ ë¶€ë¶„ì€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ\n    };\n\n    let uploaded_token_uri = upload_response.token_uri.clone().unwrap();\n\n    // íŒŒì¼ URLì„ í† í° URIë¡œ ì‚¬ìš©í•˜ì—¬ mint_nft í˜¸ì¶œ\n    let token_id = mint_nft(\n        &web3_client.web3,\n        &web3_client.contract,\n        owner_address,\n        uploaded_token_uri.clone(),\n        payload.token_name.clone(),\n    )\n    .await\n    .map_err(|e| AppError::InternalServerError(format!(\"NFT ìƒì„± ì‹¤íŒ¨: {}\", e)))?;\n\n    Ok(Json(NftMetadata {\n        token_id: token_id.to_string(),\n        owner_address: payload.owner_address,\n        token_name: payload.token_name,\n        token_uri: uploaded_token_uri.clone(),\n    }))\n}\n```\n\nì´ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ëŠ” ìŠ¤ë§ˆíŠ¸ ê³„ì•½ê³¼ ìƒí˜¸ì‘ìš©í•˜ì—¬ ìƒˆ NFTë¥¼ ìƒì„±í•˜ë©°, ì†Œìœ ì, í† í° URI ë° í† í° ì´ë¦„ì„ ì§€ì •í•©ë‹ˆë‹¤. ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ê±°ë˜ë¥¼ êµ¬ì„±í•˜ê³  ë³´ë‚´ëŠ” ì„¸ë¶€ì‚¬í•­ì„ ìº¡ìŠí™”í•©ë‹ˆë‹¤.\n\n\n\n## ì†Œìœ í•œ í† í° ê²€ìƒ‰ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜\n\n```rust\nasync fn get_all_owned_tokens<T: Transport>(\n    _web3: &Web3<T>,\n    contract: &Contract<T>,\n    owner: Address,\n) -> Result<Vec<u64>, Box<dyn Error>> {\n    let options = Options::with(|opt| {\n        opt.gas = Some(1_000_000.into());\n    });\n\n    let result: Vec<u64> = contract\n        .query(\"getAllTokensByOwner\", owner, owner, options, None)\n        .await?;\n\n    Ok(result)\n}\n```\n\nì´ í•¨ìˆ˜ëŠ” ì§€ì •ëœ ì£¼ì†Œê°€ ì†Œìœ í•œ í† í° ID ëª©ë¡ì„ ê°€ì ¸ì™€ ì‚¬ìš©ìê°€ ì†Œìœ í•œ NFT ëª©ë¡ì„ ë‚˜ì—´í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì„ ì¿¼ë¦¬í•˜ê³  ì‘ë‹µì„ ì‰½ê²Œ ì†Œë¹„í•  ìˆ˜ ìˆë„ë¡ í¬ë§·í•©ë‹ˆë‹¤.\n\n## ì„œë²„ ì´ˆê¸°í™” ë° ë¼ìš°íŠ¸ ì •ì˜\n\n\n\n## ì£¼ì†Œ ì§€ì • ë° ë“¤ì–´ì˜¤ëŠ” ìš”ì²­ ìˆ˜ì‹  ì‹œì‘\n\në©”ì¸ í•¨ìˆ˜ëŠ” Axum ì„œë²„ë¥¼ ì´ˆê¸°í™”í•˜ë©°, ì •ì˜ëœ ì—”ë“œí¬ì¸íŠ¸ì— ëŒ€í•œ ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  CORSì™€ ê°™ì€ ë¯¸ë“¤ì›¨ì–´ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤. ì„œë²„ë¥¼ ì§€ì •ëœ ì£¼ì†Œì— ë°”ì¸ë”©í•˜ê³  ë“¤ì–´ì˜¤ëŠ” ìš”ì²­ì„ ìˆ˜ì‹ í•˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤.\n\n## ì •ì  íŒŒì¼ ì œê³µ ì˜¤ë¥˜ ì²˜ë¦¬\n\n```rust\nasync fn handle_serve_dir_error(error: io::Error) -> (StatusCode, String) {\n    (\n        StatusCode::INTERNAL_SERVER_ERROR,\n        format!(\"ì •ì  íŒŒì¼ ì œê³µì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {}\", error),\n    )\n}\n```\n\n\n\nì´ ê¸°ëŠ¥ì€ ì •ì  íŒŒì¼ì„ ì œê³µí•˜ëŠ” ì¤‘ì— ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ ëª…í™•íˆ ë³´ê³ í•˜ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ì œê³µí•˜ì—¬ static/swagger-ui ë””ë ‰í† ë¦¬ì—ì„œ íŒŒì¼ì„ ì œê³µí•˜ëŠ” ë™ì•ˆ ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n\nmain.rs íŒŒì¼ì˜ ê° ì„¹ì…˜ì€ Rust NFT APIì˜ ì „ì²´ ê¸°ëŠ¥ì— ê¸°ì—¬í•©ë‹ˆë‹¤. ì—”ë“œí¬ì¸íŠ¸ ì •ì˜ ë° ìš”ì²­ ì²˜ë¦¬ë¶€í„° ì´ë”ë¦¬ì›€ ë° IPFSì™€ ìƒí˜¸ ì‘ìš©í•˜ì—¬ NFT ì‘ìš© í”„ë¡œê·¸ë¨ì— ê°•ë ¥í•œ ë°±ì—”ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n\nGitHub ë ˆí¬ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”! ğŸš€\n\nRust NFT APIì— ëŒ€í•œ ì´ ê¹Šì€ íƒêµ¬ê°€ ìœ ìµí•˜ê³  í¥ë¯¸ë¡œì› ê¸°ë¥¼ ë°”ëë‹ˆë‹¤. ìš°ë¦¬ ì¼ë°˜ì ì¸ ê¸€ë³´ë‹¤ ì¡°ê¸ˆ ë” ê¸¸ì–´ì§„ ê²ƒ ê°™ì•„ë„ ê°ì‚¬í•©ë‹ˆë‹¤.\n\n\n\nê·¸ ê²°ê³¼ì— ë§Œì¡±í•˜ì‹œëŠ” ë¶„ë“¤ì´ë‚˜ ì½”ë“œë¥¼ ë” íƒêµ¬í•˜ê³  ì‹¶ì€ ë¶„ë“¤ê»˜ ì¢‹ì€ ì†Œì‹ì´ ìˆì–´ìš”!\n\nì „ì²´ ì½”ë“œë² ì´ìŠ¤ ë° í”„ë¡œì íŠ¸ë¥¼ ì„¤ì •í•˜ëŠ” ë‹¨ê³„ë³„ ì§€ì¹¨ì„ ì°¾ì„ ìˆ˜ ìˆëŠ” GitHub ì €ì¥ì†Œë¥¼ ì†Œê°œí•©ë‹ˆë‹¤: [https://github.com/luishsr/rust-nft-api](https://github.com/luishsr/rust-nft-api). ì–¸ì œë“ ì§€ ì°¸ì—¬í•´ë³´ì„¸ìš”. ì¦ê±°ìš´ ì½”ë”© ë˜ì„¸ìš”!\n\n# ğŸš€ Luis Soaresì˜ ë” ë§ì€ ì •ë³´ í™•ì¸í•˜ê¸°\n\nğŸ“š í•™ìŠµ í—ˆë¸Œ: ëŸ¬ìŠ¤íŠ¸, ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ, í´ë¼ìš°ë“œ ì»´í“¨íŒ…, ì‚¬ì´ë²„ ë³´ì•ˆ, ë¸”ë¡ì²´ì¸, ë¦¬ëˆ…ìŠ¤ ë“± ë‹¤ì–‘í•œ ê¸°ìˆ  ë¶„ì•¼ì—ì„œ ì§€ì‹ì„ í™•ì¥í•  ìˆ˜ ìˆëŠ” ê´‘ë²”ìœ„í•œ ìë£Œ ëª¨ìŒìœ¼ë¡œ ì§€ì‹ì„ í–¥ìƒí•´ë³´ì„¸ìš”:\n\n\n\n- GitHub Reposì™€ í•¨ê»˜í•œ ì‹¤ì „ íŠœí† ë¦¬ì–¼: ë‹¨ê³„ë³„ íŠœí† ë¦¬ì–¼ë¡œ ë‹¤ì–‘í•œ ê¸°ìˆ ì— ëŒ€í•œ ì‹¤ìš©ì ì¸ ê¸°ìˆ ì„ ìŠµë“í•˜ê³  ì „ìš© GitHub ë¦¬í¬ì§€í† ë¦¬ë¥¼ ì´ìš©í•˜ì„¸ìš”. [íŠœí† ë¦¬ì–¼ í™•ì¸í•˜ê¸°](link)\n- ê¹Šì´ ìˆëŠ” ì•ˆë‚´ì„œ ë° ê¸°ì‚¬: Rust, ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ, í´ë¼ìš°ë“œ ì»´í“¨íŒ… ë“± í•µì‹¬ ê°œë…ì„ ìì„¸í•œ ì•ˆë‚´ì„œì™€ ì‹¤ìš©ì ì¸ ì˜ˆì‹œê°€ ê°€ë“í•œ ê¸°ì‚¬ë¡œ ê¹Šê²Œ ë“¤ì–´ê°€ ë³´ì„¸ìš”. [ë” ì½ê¸°](link)\n- E-Book ì»¬ë ‰ì…˜: \"Mastering Rust Ownership\"ì™€ \"Application Security Guide\"ì™€ ê°™ì€ ì œëª©ì˜ ë¬´ë£Œ E-Book ì‹œë¦¬ì¦ˆë¡œ ì—¬ëŸ¬ ê¸°ìˆ  ë¶„ì•¼ì— ëŒ€í•œ ì´í•´ë¥¼ ë†’ì´ì„¸ìš”. [E-Book ë‹¤ìš´ë¡œë“œ](link)\n- í”„ë¡œì íŠ¸ ì‡¼ì¼€ì´ìŠ¤: API ê²Œì´íŠ¸ì›¨ì´, ë¸”ë¡ì²´ì¸ ë„¤íŠ¸ì›Œí¬, ì‚¬ì´ë²„ ë³´ì•ˆ ë„êµ¬, í´ë¼ìš°ë“œ ì„œë¹„ìŠ¤ ë“± ë‹¤ì–‘í•œ ë„ë©”ì¸ì—ì„œ ì™„ì „íˆ ê¸°ëŠ¥í•˜ëŠ” í”„ë¡œì íŠ¸ë¥¼ ë°œê²¬í•˜ì„¸ìš”. [í”„ë¡œì íŠ¸ ë³´ê¸°](link)\n- LinkedIn ë‰´ìŠ¤ë ˆí„°: LinkedInì—ì„œ êµ¬ë…í•˜ë©´ Rust, ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ë° ì‹ ìƒ ê¸°ìˆ ì— ëŒ€í•œ ì •ê¸° ì—…ë°ì´íŠ¸ì™€ í†µì°°ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. [ì—¬ê¸°ì„œ êµ¬ë…í•˜ê¸°](link)\n\nğŸ”— ë‚˜ì™€ ì†Œí†µí•˜ê¸°:\n\n- Medium: Mediumì—ì„œ ì œê°€ ì“´ ê¸°ì‚¬ë¥¼ ì½ê³  ë„ì›€ì´ ëë‹¤ë©´ clapsë¥¼ ì£¼ì„¸ìš”. ì œê²Œ ê¸€ì“°ê³  Rust ì½˜í…ì¸ ë¥¼ ê³„ì† ê³µìœ í•˜ê²Œ í•˜ëŠ” ì›ë™ë ¥ì´ ë©ë‹ˆë‹¤. [Medium íŒ”ë¡œìš°í•˜ê¸°](link)\n- ê°œì¸ ë¸”ë¡œê·¸: ì œ ê°œì¸ ë¸”ë¡œê·¸ì—ì„œ ë” ë§ì€ Rust ê´€ë ¨ ì½˜í…ì¸ ë¥¼ ì°¾ì•„ë³´ì„¸ìš”. [ë¸”ë¡œê·¸ ë°©ë¬¸í•˜ê¸°](link)\n- LinkedIn: ë” ë§ì€ í†µì°°ì„ ì–»ê¸° ìœ„í•´ ì „ë¬¸ ë„¤íŠ¸ì›Œí¬ì— ì°¸ì—¬í•˜ì„¸ìš”. [LinkedInì—ì„œ ì ‘ì†í•˜ê¸°](link)\n- Twitter: Rust í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ë¹ ë¥¸ ì—…ë°ì´íŠ¸ì™€ ìƒê°ì„ ë³´ë ¤ë©´ Twitterë¡œ íŒ”ë¡œìš°í•˜ì„¸ìš”. [Twitter íŒ”ë¡œìš°í•˜ê¸°](link)\n\nëŒ€í™”í•˜ê³  ì‹¶ìœ¼ì„¸ìš”? ëŒ“ê¸€ì„ ë‚¨ê¸°ê±°ë‚˜ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì£¼ì„¸ìš”!\n\n\n\nëª¨ë‘ ì¢‹ì€ ì¼ ë˜ê¸¸ ë°”ë¼ë©°,\n\nLuis Soares  \nluis.soares@linux.com  \n\nì‹œë‹ˆì–´ ì†Œí”„íŠ¸ì›¨ì–´ ì—”ì§€ë‹ˆì–´ | í´ë¼ìš°ë“œ ì—”ì§€ë‹ˆì–´ | SRE | ê¸°ìˆ  ë¦¬ë“œ | Rust | Golang | Java | ML AI ë° í†µê³„ | Web3 & ë¸”ë¡ì²´ì¸","ogImage":{"url":"/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png"},"coverImage":"/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png","tag":["Tech"],"readingTime":29},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png\" alt=\"ImplementingaWeb3NFTAPIinRust\"></p>\n<p>ì•ˆë…•í•˜ì„¸ìš” ëŸ¬ìŠ¤í…Œì´ì…˜ ë¶„ë“¤! ğŸ¦€</p>\n<p>ì˜¤ëŠ˜ì˜ ê¸€ì—ì„œëŠ” ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ì„ í™œìš©í•˜ì—¬ NFTë¥¼ ë°œí–‰í•˜ëŠ” Rust APIë¥¼ êµ¬í˜„í•´ ë³´ê² ìŠµë‹ˆë‹¤. ë˜í•œ IPFSì™€ì˜ ë¶„ì‚° íŒŒì¼ ì €ì¥ì†Œ í†µí•©, ê·¸ë¦¬ê³  ì†”ë¦¬ë””í‹°ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ êµ¬í˜„ë„ ë‹¤ë£° ì˜ˆì •ì´ì—ìš”.</p>\n<p>ì´ ê¸€ì„ ë§ˆì¹˜ë©´ swagger-uië¥¼ ì‚¬ìš©í•˜ì—¬ APIì™€ ìƒí˜¸ ì‘ìš©í•  ìˆ˜ ìˆê²Œ ë˜ë©°, Web3, RESTful Rust API, ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸, ê·¸ë¦¬ê³  ì†”ë¦¬ë””í‹°ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì„ ì–´ë–»ê²Œ í†µí•©í•˜ëŠ”ì§€ì— ëŒ€í•œ ê¸°ë³¸ ì§€ì‹ì„ ìŠµë“í•  ìˆ˜ ìˆì„ ê±°ì˜ˆìš”.</p>\n<p>ê¸°ëŒ€í•˜ì‹œëŠ” ëŒ€ë¡œ, ëŸ¬ìŠ¤íŠ¸ NFT APIì— ëŒ€í•œ ì´ ê¹Šì€ íƒí—˜ì€ ì •ë³´ê°€ í’ë¶€í•˜ê³  í¥ë¯¸ë¡œìš¸ ê²ƒì…ë‹ˆë‹¤. ë‹¤ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ì“°ëŠ” ê¸€ë³´ë‹¤ ì¡°ê¸ˆ ë” ê¸¸ì–´ì ¸ì„œ ì£„ì†¡í•©ë‹ˆë‹¤. ë³´ë‹¤ ì‹¤ìš©ì ì¸ ì ‘ê·¼ì„ ì„ í˜¸í•˜ì‹œê±°ë‚˜ ì½”ë“œë¥¼ ë” íƒêµ¬í•˜ê³  ì‹¶ì–´í•˜ëŠ” ë¶„ë“¤ì„ ìœ„í•´ ì¢‹ì€ ì†Œì‹ì´ ìˆì–´ìš”!</p>\n<p>ğŸš€ í”„ë¡œì íŠ¸ë¥¼ ì‹¤í–‰í•˜ê³  ìì„¸íˆ ì‚´í´ë³¼ ìˆ˜ ìˆëŠ” ì „ì²´ ì½”ë“œë² ì´ìŠ¤ì™€ ë‹¨ê³„ë³„ ì§€ì¹¨ì„ <a href=\"https://github.com/luishsr/rust-nft-api\" rel=\"nofollow\" target=\"_blank\">https://github.com/luishsr/rust-nft-api</a> GitHub ì €ì¥ì†Œì— ê¹”ë”í•˜ê²Œ ì •ë¦¬í•´ ë†¨ìŠµë‹ˆë‹¤. ì–¸ì œë“ ì§€ ì°¸ì—¬í•˜ì…”ì„œ ì¦ê±°ìš´ ì½”ë”©í•˜ì„¸ìš”!</p>\n<p>ë°”ë¡œ ì‹œì‘í•´ë´…ì‹œë‹¤!</p>\n<h1>í”„ë¡œì íŠ¸ êµ¬ì¡° ê°œìš”</h1>\n<p>í”„ë¡œì íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤:</p>\n<p>rust-nft-api/\nâ”œâ”€â”€ contract/\nâ”‚   â””â”€â”€ MyNFT.sol\nâ”œâ”€â”€ nft-images/\nâ”‚   â””â”€â”€ token.jpg\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ main.rs\nâ”‚   â”œâ”€â”€ error.rs\nâ”‚   â”œâ”€â”€ ipfs.rs\nâ”‚   â”œâ”€â”€ model.rs\nâ”‚   â”œâ”€â”€ utils.rs\nâ”‚   â””â”€â”€ web3client.rs\nâ”œâ”€â”€ static/\nâ”‚   â””â”€â”€ swagger-ui/\nâ”œâ”€â”€ .env\nâ””â”€â”€ Cargo.toml</p>\n<pre><code>\n- contract/: NFTì— ëŒ€í•œ Solidity ìŠ¤ë§ˆíŠ¸ ê³„ì•½(MyNFT.sol)ì„ í¬í•¨í•˜ë©°, NFTì˜ ë°œí–‰ ë° ì „ì†¡ ê·œì¹™ì„ ì •ì˜í•©ë‹ˆë‹¤.\n- nft-images/: ê° NFTì™€ ê´€ë ¨ëœ ì´ë¯¸ì§€ ë˜ëŠ” ìì‚°ì„ ì €ì¥í•˜ë©°, NFT ë©”íƒ€ë°ì´í„°ì—ì„œ ì°¸ì¡°ë©ë‹ˆë‹¤.\n- src/: ëŸ¬ìŠ¤íŠ¸ íŒŒì¼ì´ ìˆëŠ” ì†ŒìŠ¤ ë””ë ‰í† ë¦¬ì´ë©°, API ê¸°ëŠ¥ì—ì„œ íŠ¹ì • ëª©ì ì„ ì œê³µí•©ë‹ˆë‹¤:\n  - main.rs: APIì˜ ì§„ì…ì ìœ¼ë¡œ ì„œë²„ ë° ë¼ìš°íŠ¸ ì„¤ì •ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.\n  - error.rs: APIì— ëŒ€í•œ ì‚¬ìš©ì ì§€ì • ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.\n  - ipfs.rs: IPFSì™€ ìƒí˜¸ ì‘ìš©í•˜ì—¬ ì˜¤í”„ì²´ì¸ ë©”íƒ€ë°ì´í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.\n  - model.rs: APIì—ì„œ ì‚¬ìš©ë˜ëŠ” ë°ì´í„° ëª¨ë¸ì„ ì •ì˜í•˜ë©°, NFT ë° ë©”íƒ€ë°ì´í„° êµ¬ì¡°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.\n  - utils.rs: í”„ë¡œì íŠ¸ ì „ì²´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.\n  - web3client.rs: Web3ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ê³¼ì˜ í†µì‹ ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.\n- static/: API ë¬¸ì„œí™”ë¥¼ ìœ„í•œ Swagger UIì™€ ê°™ì€ ì •ì  íŒŒì¼ì„ í¬í•¨í•©ë‹ˆë‹¤.\n- .env: API í‚¤ ë° ë¸”ë¡ì²´ì¸ ë…¸ë“œ URLê³¼ ê°™ì€ í™˜ê²½ ë³€ìˆ˜ë¥¼ ê´€ë¦¬í•˜ëŠ” dotenv íŒŒì¼ì…ë‹ˆë‹¤.\n- Cargo.toml: ì˜ì¡´ì„± ë° í”„ë¡œì íŠ¸ ì •ë³´ë¥¼ ë‚˜ì—´í•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ íŒ¨í‚¤ì§€ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ íŒŒì¼ì…ë‹ˆë‹¤.\n\n# ì£¼ìš” êµ¬ì„± ìš”ì†Œ ë° ê¸°ëŠ¥\n\n\n\n# ìŠ¤ë§ˆíŠ¸ ê³„ì•½ (MyNFT.sol)\n\nì´ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì€ Solidityë¡œ ì‘ì„±ë˜ì–´ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ì— ë°°í¬ë˜ì—ˆìŠµë‹ˆë‹¤. ERC-721 í‘œì¤€ì— ë”°ë¼ NFTì˜ ë°œí–‰, ì´ì „ ë° ê´€ë¦¬ ê·œì¹™ì„ ì •ì˜í•©ë‹ˆë‹¤. ì´ëŠ” ì´ë”ë¦¬ì›€ì—ì„œ NFTì— ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” í‘œì¤€ì…ë‹ˆë‹¤.\n\n# IPFS í†µí•© (ipfs.rs)\n\nIPFS ë˜ëŠ” InterPlanetary File Systemì€ NFTì˜ ì˜¤í”„ì²´ì¸ ë©”íƒ€ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì´ë¯¸ì§€ì™€ ì„¤ëª… ì •ë³´ë¥¼ í¬í•¨í•œ ë©”íƒ€ë°ì´í„°ê°€ ë¶„ì‚°í™”ë˜ê³  ìœ„ë³€ì¡°ë˜ì§€ ì•ŠìŒì„ ë³´ì¥í•©ë‹ˆë‹¤. ipfs.rs ëª¨ë“ˆì€ IPFSë¡œë¶€í„° ë©”íƒ€ë°ì´í„°ë¥¼ ì—…ë¡œë“œí•˜ê³  ê²€ìƒ‰í•˜ëŠ” ì‘ì—…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n\n\n\n# ì›¹3 í´ë¼ì´ì–¸íŠ¸ (web3client.rs)\n\nì´ ëª¨ë“ˆì€ Web3 ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ì— ì—°ê²°ì„ ì„¤ì •í•©ë‹ˆë‹¤. ë¸”ë¡ì²´ì¸ê³¼ ìƒí˜¸ ì‘ìš©í•˜ë„ë¡ APIë¥¼ í™œì„±í™”í•˜ì—¬ NFT ë°œí–‰, NFT ì„¸ë¶€ ì •ë³´ ê²€ìƒ‰ ë° ë¸”ë¡ì²´ì¸ ì´ë²¤íŠ¸ ìˆ˜ì‹ ê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n# API ì—”ë“œí¬ì¸íŠ¸ (main.rs)\n\nmain.rs íŒŒì¼ì€ RESTful API ì„œë²„ë¥¼ ì„¤ì •í•˜ê³  NFT ìƒì„±, í† í° IDë¡œ NFT ì„¸ë¶€ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ë° ëª¨ë“  NFT ë‚˜ì—´ê³¼ ê°™ì€ ë‹¤ì–‘í•œ ì—”ë“œí¬ì¸íŠ¸ì— ëŒ€í•œ ê²½ë¡œë¥¼ ì •ì˜í•©ë‹ˆë‹¤. Actix-web í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•˜ì—¬ HTTP ìš”ì²­ê³¼ ì‘ë‹µì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\n\n\n\n# ì—ëŸ¬ ì²˜ë¦¬ ë° ìœ í‹¸ë¦¬í‹° (error.rs, utils.rs)\n\nê°•ë ¥í•œ APIë¥¼ ìœ„í•´ì„œ ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤. error.rs ëª¨ë“ˆì€ ì‚¬ìš©ì ì •ì˜ ì—ëŸ¬ ìœ í˜•ê³¼ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ì„ ì •ì˜í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ëª…í™•í•˜ê³  ìœ ìš©í•œ ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ ë°˜í™˜ë˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤. utils.rs ëª¨ë“ˆì—ëŠ” ë°ì´í„° ìœ íš¨ì„± ê²€ì¦ ë° í˜•ì‹ ì§€ì›ê³¼ ê°™ì€ API ë‚´ì—ì„œ ë‹¤ì–‘í•œ ì‘ì—…ì„ ì§€ì›í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.\n\n# ë‹¨ê³„ 1. ìŠ¤ë§ˆíŠ¸ ê³„ì•½ êµ¬í˜„\n\nSolidityë¡œ ê°œë°œëœ MyNFT ê³„ì•½ì€ ì•ˆì „í•œ ë¸”ë¡ì²´ì¸ ê°œë°œì„ ìœ„í•œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì¸ OpenZeppelinì˜ ERC721URIStorage ê³„ì•½ì„ í™•ì¥í•©ë‹ˆë‹¤. ì´ëŠ” NFT ì†Œìœ ê¶Œì„ í‘œí˜„í•˜ëŠ” ì¸ê¸°ìˆëŠ” í‘œì¤€ì¸ ERC721 í”„ë¡œí† ì½œì„ í™œìš©í•˜ë©° NFTì— URI ê¸°ë°˜ ë©”íƒ€ë°ì´í„°ë¥¼ ì—°ê²°í•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•©ë‹ˆë‹¤.\n\n\n\n## ì£¼ìš” êµ¬ì„± ìš”ì†Œ\n\n- í† í° ì¹´ìš´í„°: OpenZeppelinì˜ Counters ìœ í‹¸ë¦¬í‹°ë¥¼ í™œìš©í•˜ì—¬ ë°œí–‰ëœ ê° NFTì— ëŒ€í•œ ê³ ìœ  ì‹ë³„ìë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.\n- í† í° ì„¸ë¶€ ì •ë³´ êµ¬ì¡°: ê° NFTì— ëŒ€í•œ ì¤‘ìš” ì •ë³´ì¸ ID, ì´ë¦„, ì†Œìœ ì ë° ê´€ë ¨ URIë¥¼ ë³´ìœ í•˜ëŠ” TokenDetails êµ¬ì¡°ì²´ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.\n- ë§¤í•‘: ì„¸ ê°€ì§€ ì£¼ìš” ë§¤í•‘ì´ ì‚¬ìš©ë˜ì–´ NFT ì†Œìœ ê¶Œ ë° ì„¸ë¶€ ì •ë³´ë¥¼ ì¶”ì í•©ë‹ˆë‹¤:\n  - _tokenDetailsëŠ” ê° í† í° IDë¥¼ í•´ë‹¹ TokenDetailsë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.\n  - _ownedTokensëŠ” ì†Œìœ ì ì£¼ì†Œë¥¼ ì†Œìœ í•œ í† í° ID ëª©ë¡ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.\n  - _ownedTokensIndexëŠ” í† í° IDë¥¼ ì†Œìœ ìì˜ í† í° ëª©ë¡ì—ì„œì˜ ìœ„ì¹˜ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract MyNFT is ERC721URIStorage {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    struct TokenDetails {\n        uint256 tokenId;\n        string tokenName;\n        address tokenOwner;\n        string tokenURI;\n    }\n\n    mapping(uint256 => TokenDetails) private _tokenDetails;\n    mapping(address => uint256[]) private _ownedTokens;\n    mapping(uint256 => uint256) private _ownedTokensIndex;  // í† í° IDë¥¼ ì†Œìœ ìì˜ í† í° ëª©ë¡ì—ì„œì˜ ìœ„ì¹˜ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤\n\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    function mintNFT(address recipient, string memory tokenName, string memory tokenURI) public returns (uint256) {\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _mint(recipient, newItemId);\n        _setTokenURI(newItemId, tokenURI);\n\n        _tokenDetails[newItemId] = TokenDetails({\n            tokenId: newItemId,\n            tokenName: tokenName,\n            tokenOwner: recipient,\n            tokenURI: tokenURI\n        });\n\n        _addTokenToOwnerEnumeration(recipient, newItemId);\n\n        return newItemId;\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokens[to].push(tokenId);\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length - 1;\n    }\n\n    function getAllTokensByOwner(address owner) public view returns (uint256[] memory) {\n        if (owner == address(0)) {\n            uint256 totalTokens = _tokenIds.current();\n            uint256[] memory allTokenIds = new uint256[](totalTokens);\n            for (uint256 i = 0; i &#x3C; totalTokens; i++) {\n                allTokenIds[i] = i + 1;  // í† í° IDëŠ” ë°œí–‰ ë°©ì‹ì— ë”°ë¼ 1ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤\n            }\n            return allTokenIds;\n        } else {\n            return _ownedTokens[owner];\n        }\n    }\n\n    function getTokenDetails(uint256 tokenId) public view returns (uint256, string memory, address, string memory) {\n        require(_ownerOf(tokenId) != address(0), \"ERC721: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í† í°ì— ëŒ€í•œ ì¡°íšŒ\");\n\n        TokenDetails memory tokenDetail = _tokenDetails[tokenId];\n        return (tokenDetail.tokenId, tokenDetail.tokenName, tokenDetail.tokenOwner, tokenDetail.tokenURI);\n    }\n}\n</code></pre>\n<h1>ë‹¨ê³„ 2. Web3Client ì‘ì„±í•˜ê¸°</h1>\n<p>The <code>web3client.rs</code> file includes the implementation of the <code>Web3Client</code> struct, responsible for enabling interactions with smart contracts on the Ethereum network through the Rust programming language. Let's explore the main features of this implementation.</p>\n<h2>Web3Client Structure</h2>\n<p>The <code>Web3Client</code> struct comprises two primary fields:</p>\n<ul>\n<li><code>web3</code>: An object of the <code>Web3</code> type, establishing a link to an Ethereum node.</li>\n<li><code>contract</code>: A <code>Contract</code> instance, representing the smart contract on the Ethereum blockchain that the API will engage with.</li>\n</ul>\n<h2>êµ¬í˜„ ì„¸ë¶€ ì‚¬í•­</h2>\n<ul>\n<li>ìƒˆë¡œìš´ í•¨ìˆ˜: ì´ê²ƒì€ Web3Client êµ¬ì¡°ì²´ë¥¼ ìœ„í•œ ìƒì„±ìì…ë‹ˆë‹¤. ì œê³µëœ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ ì£¼ì†Œë¡œ ìƒˆ Web3 ì¸ìŠ¤í„´ìŠ¤ ë° ìƒˆ Contract ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.</li>\n<li>ì´ë”ë¦¬ì›€ ë…¸ë“œ ì—°ê²°: ETH_NODE_URL í™˜ê²½ ë³€ìˆ˜ë¡œ ì§€ì •ëœ ì´ë”ë¦¬ì›€ ë…¸ë“œì— HTTP ì—°ê²°ì„ ì„¤ì •í•©ë‹ˆë‹¤. ì´ ì—°ê²°ì€ ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ìœ¼ë¡œ íŠ¸ëœì­ì…˜ì„ ë³´ë‚´ê±°ë‚˜ í˜¸ì¶œí•˜ëŠ” ë° í•„ìˆ˜ì ì…ë‹ˆë‹¤.</li>\n<li>ìŠ¤ë§ˆíŠ¸ ê³„ì•½ ABI: Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ê³„ì•½ê³¼ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ë°©ë²•ì„ ì´í•´í•˜ëŠ” ë° ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì˜ ABI(ì‘ìš© í”„ë¡œê·¸ë¨ ì´ì§„ ì¸í„°í˜ì´ìŠ¤)ê°€ í•„ìš”í•©ë‹ˆë‹¤. ABIëŠ” CONTRACT_ABI_PATH í™˜ê²½ ë³€ìˆ˜ë¡œ ì§€ì •ëœ íŒŒì¼ì—ì„œ ë¡œë“œë©ë‹ˆë‹¤. í•´ë‹¹ ABI íŒŒì¼ì€ ì¼ë°˜ì ìœ¼ë¡œ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì´ ì»´íŒŒì¼ë  ë•Œ Solidity ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìƒì„±ë©ë‹ˆë‹¤.</li>\n<li>ê³„ì•½ ì´ˆê¸°í™”: ABI ë° ìŠ¤ë§ˆíŠ¸ ê³„ì•½ ì£¼ì†Œë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒˆ Contract ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë©ë‹ˆë‹¤. ì´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê±°ë‚˜ í•´ë‹¹ì—ì„œ ë°œìƒí•œ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ê³  ìƒíƒœë¥¼ ì¿¼ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>\n</ul>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::env;\n<span class=\"hljs-keyword\">use</span> std::error::Error;\n<span class=\"hljs-keyword\">use</span> web3::contract::Contract;\n<span class=\"hljs-keyword\">use</span> web3::transports::Http;\n<span class=\"hljs-keyword\">use</span> web3::{ethabi, Web3};\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Web3Client</span> {\n    <span class=\"hljs-keyword\">pub</span> web3: Web3&#x3C;Http>,\n    <span class=\"hljs-keyword\">pub</span> contract: Contract&#x3C;Http>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Web3Client</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(contract_address: &#x26;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-keyword\">Self</span>, <span class=\"hljs-type\">Box</span>&#x3C;<span class=\"hljs-keyword\">dyn</span> Error>> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">http</span> = Http::<span class=\"hljs-title function_ invoke__\">new</span>(&#x26;env::<span class=\"hljs-title function_ invoke__\">var</span>(<span class=\"hljs-string\">\"ETH_NODE_URL\"</span>)?)?;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">web3</span> = Web3::<span class=\"hljs-title function_ invoke__\">new</span>(http);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">contract_abi_path</span> = env::<span class=\"hljs-title function_ invoke__\">var</span>(<span class=\"hljs-string\">\"CONTRACT_ABI_PATH\"</span>)?;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">contract_abi_file</span> = std::fs::File::<span class=\"hljs-title function_ invoke__\">open</span>(contract_abi_path)?;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">contract_abi</span>: ethabi::Contract = serde_json::<span class=\"hljs-title function_ invoke__\">from_reader</span>(contract_abi_file)?;\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">contract</span> = Contract::<span class=\"hljs-title function_ invoke__\">new</span>(web3.<span class=\"hljs-title function_ invoke__\">eth</span>(), contract_address.<span class=\"hljs-title function_ invoke__\">parse</span>()?, contract_abi);\n\n        <span class=\"hljs-title function_ invoke__\">Ok</span>(Web3Client { web3, contract })\n    }\n}\n</code></pre>\n<h1>ë‹¨ê³„ 3. ë°ì´í„° êµ¬ì¡°</h1>\n<p>ì•ˆë…•í•˜ì„¸ìš”! ì˜¤ëŠ˜ì€ Rust NFT API í”„ë¡œì íŠ¸ ë‚´ ëª¨ë¸.rs íŒŒì¼ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ë³´ë ¤ê³  í•´ìš”.</p>\n<p>í•´ë‹¹ íŒŒì¼ì€ Rustì˜ ê°•ë ¥í•œ íƒ€ì… ì‹œìŠ¤í…œì„ ì´ìš©í•˜ì—¬ ì£¼ìš” ë°ì´í„° êµ¬ì¡°ë¥¼ ì •ì˜í•˜ë©°, serdeë¥¼ í†µí•œ ì§ë ¬í™” ê¸°ëŠ¥ê³¼ utoipaì˜ API ë¬¸ì„œí™” ê¸°ëŠ¥ì„ ê²°í•©í•˜ê³  ìˆì–´ìš”.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> serde::{Deserialize, Serialize};\n<span class=\"hljs-keyword\">use</span> utoipa::Component;\n\n<span class=\"hljs-meta\">#[derive(Serialize, Deserialize, Component)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MintNftRequest</span> {\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) owner_address: <span class=\"hljs-type\">String</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) token_name: <span class=\"hljs-type\">String</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) token_uri: <span class=\"hljs-type\">String</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) file_path: <span class=\"hljs-type\">String</span>,\n}\n\n<span class=\"hljs-meta\">#[derive(Serialize, Deserialize, Component)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">TokenFileForm</span> {\n    file: <span class=\"hljs-type\">Vec</span>&#x3C;<span class=\"hljs-type\">u8</span>>,\n}\n\n<span class=\"hljs-meta\">#[derive(Serialize, Deserialize, Component)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ApiResponse</span> {\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) success: <span class=\"hljs-type\">bool</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) message: <span class=\"hljs-type\">String</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) token_uri: <span class=\"hljs-type\">Option</span>&#x3C;<span class=\"hljs-type\">String</span>>,\n}\n\n<span class=\"hljs-meta\">#[derive(Serialize, Deserialize, Component)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">NftMetadata</span> {\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) token_id: <span class=\"hljs-type\">String</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) owner_address: <span class=\"hljs-type\">String</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) token_name: <span class=\"hljs-type\">String</span>,\n    <span class=\"hljs-title function_ invoke__\">pub</span>(<span class=\"hljs-keyword\">crate</span>) token_uri: <span class=\"hljs-type\">String</span>,\n}\n\n<span class=\"hljs-meta\">#[derive(Serialize, Deserialize)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">UploadResponse</span> {\n    token_uri: <span class=\"hljs-type\">String</span>,\n}\n</code></pre>\n<h2>MintNftRequest</h2>\n<p>ì´ êµ¬ì¡°ëŠ” ìƒˆë¡œìš´ NFTë¥¼ ë°œí–‰í•˜ê¸° ìœ„í•œ ìš”ì²­ ë³¸ë¬¸ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì†Œìœ ì ì£¼ì†Œ, í† í° ì´ë¦„, í† í° URI(í•´ë‹¹ NFTì™€ ê´€ë ¨ëœ ë©”íƒ€ë°ì´í„° ë˜ëŠ” ìì‚°ì„ ê°€ë¦¬í‚´), ê·¸ë¦¬ê³  NFTì™€ ì—°ê²°í•  ìì‚°ì˜ íŒŒì¼ ê²½ë¡œì— ëŒ€í•œ í•„ë“œë¥¼ í¬í•¨í•˜ê³  ìˆì–´ìš”. pub (crate)ì˜ ì‚¬ìš©ì€ ì´ë“¤ í•„ë“œê°€ í¬ë ˆì´íŠ¸ ë‚´ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.</p>\n<p>ë” ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ë©´ ì–¸ì œë“ ì§€ ë¬¼ì–´ë³´ì„¸ìš”! ğŸ˜Š</p>\n<h1>TokenFileForm</h1>\n<p>TokenFileFormì€ íŒŒì¼ ì—…ë¡œë“œ ì–‘ì‹ì˜ ë°ì´í„° êµ¬ì¡°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤. íŠ¹íˆ NFTì™€ ê´€ë ¨ëœ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê¸° ìœ„í•œ ê²ƒì…ë‹ˆë‹¤. íŒŒì¼ í•„ë“œëŠ” ì—…ë¡œë“œë˜ëŠ” íŒŒì¼ì˜ ë°”ì´ë„ˆë¦¬ ë‚´ìš©ì„ ë‚˜íƒ€ë‚´ëŠ” 'Vec u8'ì˜ ë°”ì´íŠ¸ ë²¡í„°ì…ë‹ˆë‹¤.</p>\n<h2>ApiResponse</h2>\n<p>ë‹¤ì–‘í•œ API ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ì „ë‹¬í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì¼ë°˜ì ì¸ API ì‘ë‹µ êµ¬ì¡°ì…ë‹ˆë‹¤. ì‘ì—…ì´ ì„±ê³µí–ˆëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì„±ê³µ í”Œë˜ê·¸, ì¶”ê°€ ì •ë³´ ë˜ëŠ” ì˜¤ë¥˜ ì„¸ë¶€ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” ë©”ì‹œì§€, ê·¸ë¦¬ê³  NFTê°€ ê´€ë ¨ëœ ì‘ì—…ì—ì„œ íŠ¹íˆ ì¤‘ìš”í•œ ì˜µì…˜ì¸ token_uriê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” NFTì˜ ë©”íƒ€ë°ì´í„° ë˜ëŠ” ìì‚°ì„ ê°€ë¦¬í‚¤ëŠ” URIê°€ ë°˜í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>\n<h2>NftMetadata</h2>\n<p>NFTì™€ ê´€ë ¨ëœ ë©”íƒ€ë°ì´í„°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. í† í° ID, ì†Œìœ ì ì£¼ì†Œ, í† í° ì´ë¦„ ë° í† í° URIê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ ëª¨ë¸ì€ NFT ì„¸ë¶€ ì •ë³´ë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜ í‘œì‹œí•˜ëŠ” ì‘ì—…ì— ì¤‘ìš”í•©ë‹ˆë‹¤.</p>\n<h2>UploadResponse</h2>\n<p>íŒŒì¼ ì—…ë¡œë“œ ì‘ì—…ì— íŠ¹ë³„íˆ ë§ì¶˜ ì´ ëª¨ë¸ì€ ì—…ë¡œë“œ ì‘ì—…ì˜ ì‘ë‹µì„ ìº¡ì²˜í•˜ë©° ì£¼ë¡œ ì—…ë¡œë“œëœ íŒŒì¼ì˜ í† í° URIë¥¼ í¬í•¨í•©ë‹ˆë‹¤. ì´ URIëŠ” ê·¸ í›„ ë¯¼íŒ… í”„ë¡œì„¸ìŠ¤ë‚˜ ì—…ë¡œë“œëœ ìì‚°ì„ ì—°ê²°í•˜ëŠ” ë° í•„ìš”í•œ ë‹¤ë¥¸ ëª©ì ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>\n<h1>ë‹¨ê³„ 4. IPFSì™€ ì¸í„°í˜ì´ìŠ¤</h1>\n<p>ëŸ¬ìŠ¤íŠ¸ NFT API í”„ë¡œì íŠ¸ ë‚´ ipfs.rs ëª¨ë“ˆì€ InterPlanetary File System (IPFS)ì™€ì˜ ìƒí˜¸ ì‘ìš©ì„ ì²˜ë¦¬í•˜ëŠ” ë° ì „ë…í•©ë‹ˆë‹¤. IPFSëŠ” ë¶„ì‚°í˜• ì €ì¥ ì†”ë£¨ì…˜ìœ¼ë¡œ, ì˜¤í”„ ì²´ì¸ NFT ë©”íƒ€ë°ì´í„°ë‚˜ ìì‚°ì„ ì €ì¥í•˜ëŠ” ë° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> crate::model::ApiResponse;\n<span class=\"hljs-keyword\">use</span> axum::Json;\n<span class=\"hljs-keyword\">use</span> reqwest::Client;\n<span class=\"hljs-keyword\">use</span> serde_json::Value;\n<span class=\"hljs-keyword\">use</span> std::convert::Infallible;\n<span class=\"hljs-keyword\">use</span> std::env;\n<span class=\"hljs-keyword\">use</span> tokio::fs::File;\n<span class=\"hljs-keyword\">use</span> tokio::io::AsyncReadExt;\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">file_upload</span>(file_name: <span class=\"hljs-type\">String</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;Json&#x3C;ApiResponse>, Infallible> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">client</span> = Client::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">ipfs_api_endpoint</span> = <span class=\"hljs-string\">\"http://127.0.0.1:5001/api/v0/add\"</span>;\n\n    <span class=\"hljs-comment\">// í˜„ì¬ ë””ë ‰í† ë¦¬ ê°€ì ¸ì˜¤ê¸°</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">path</span> = env::<span class=\"hljs-title function_ invoke__\">current_dir</span>().<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"Failed to get current directory\"</span>);\n    <span class=\"hljs-comment\">// ê²½ë¡œì— 'nft-images' í•˜ìœ„ ë””ë ‰í† ë¦¬ ì¶”ê°€</span>\n    path.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-string\">\"nft-images\"</span>);\n    <span class=\"hljs-comment\">// íŒŒì¼ ì´ë¦„ì„ ê²½ë¡œì— ì¶”ê°€</span>\n    path.<span class=\"hljs-title function_ invoke__\">push</span>(file_name);\n\n    <span class=\"hljs-comment\">//println!(\"Full path: {}\", path.display());</span>\n\n    <span class=\"hljs-comment\">// íŒŒì¼ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì—´ê¸°</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">file</span> = File::<span class=\"hljs-title function_ invoke__\">open</span>(path.<span class=\"hljs-title function_ invoke__\">clone</span>()).<span class=\"hljs-keyword\">await</span>.<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"Failed to open file\"</span>);\n\n    <span class=\"hljs-comment\">// íŒŒì¼ ë°”ì´íŠ¸ ì½ê¸°</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">file_bytes</span> = <span class=\"hljs-type\">Vec</span>::<span class=\"hljs-title function_ invoke__\">new</span>();\n    file.<span class=\"hljs-title function_ invoke__\">read_to_end</span>(&#x26;<span class=\"hljs-keyword\">mut</span> file_bytes)\n        .<span class=\"hljs-keyword\">await</span>\n        .<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"Failed to read file bytes\"</span>);\n\n    <span class=\"hljs-comment\">// ê²½ë¡œì—ì„œ íŒŒì¼ ì´ë¦„ ì¶”ì¶œ</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">file_name</span> = path\n        .<span class=\"hljs-title function_ invoke__\">file_name</span>()\n        .<span class=\"hljs-title function_ invoke__\">unwrap</span>()\n        .<span class=\"hljs-title function_ invoke__\">to_str</span>()\n        .<span class=\"hljs-title function_ invoke__\">unwrap_or_default</span>()\n        .<span class=\"hljs-title function_ invoke__\">to_string</span>();\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">form</span> = reqwest::multipart::Form::<span class=\"hljs-title function_ invoke__\">new</span>().<span class=\"hljs-title function_ invoke__\">part</span>(\n        <span class=\"hljs-string\">\"file\"</span>,\n        reqwest::multipart::Part::<span class=\"hljs-title function_ invoke__\">stream</span>(file_bytes).<span class=\"hljs-title function_ invoke__\">file_name</span>(file_name),\n    );\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">response</span> = client\n        .<span class=\"hljs-title function_ invoke__\">post</span>(ipfs_api_endpoint)\n        .<span class=\"hljs-title function_ invoke__\">multipart</span>(form)\n        .<span class=\"hljs-title function_ invoke__\">send</span>()\n        .<span class=\"hljs-keyword\">await</span>\n        .<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"Failed to send file to IPFS\"</span>);\n\n    <span class=\"hljs-keyword\">if</span> response.<span class=\"hljs-title function_ invoke__\">status</span>().<span class=\"hljs-title function_ invoke__\">is_success</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">response_body</span> = response\n            .<span class=\"hljs-title function_ invoke__\">text</span>()\n            .<span class=\"hljs-keyword\">await</span>\n            .<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"Failed to read response body as text\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">ipfs_response</span>: Value =\n            serde_json::<span class=\"hljs-title function_ invoke__\">from_str</span>(&#x26;response_body).<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"Failed to parse IPFS response\"</span>);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">ipfs_hash</span> = <span class=\"hljs-built_in\">format!</span>(\n            <span class=\"hljs-string\">\"https://ipfs.io/ipfs/{}\"</span>,\n            ipfs_response[<span class=\"hljs-string\">\"Hash\"</span>].<span class=\"hljs-title function_ invoke__\">as_str</span>().<span class=\"hljs-title function_ invoke__\">unwrap_or_default</span>()\n        );\n\n        <span class=\"hljs-title function_ invoke__\">Ok</span>(<span class=\"hljs-title function_ invoke__\">Json</span>(ApiResponse {\n            success: <span class=\"hljs-literal\">true</span>,\n            message: <span class=\"hljs-string\">\"File uploaded to IPFS successfully.\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n            token_uri: <span class=\"hljs-title function_ invoke__\">Some</span>(ipfs_hash),\n        }))\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-title function_ invoke__\">Ok</span>(<span class=\"hljs-title function_ invoke__\">Json</span>(ApiResponse {\n            success: <span class=\"hljs-literal\">false</span>,\n            message: <span class=\"hljs-string\">\"IPFS upload failed.\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n            token_uri: <span class=\"hljs-literal\">None</span>,\n        }))\n    }\n}\n</code></pre>\n<p>ì²˜ë¦¬ íë¦„</p>\n<h3>ì´ˆê¸° ì„¤ì •:</h3>\n<p>Reqwestë¡œ HTTP ìš”ì²­ì„ ë³´ë‚´ê¸° ìœ„í•´ Client ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë©ë‹ˆë‹¤.</p>\n<h3>íŒŒì¼ ê²½ë¡œ êµ¬ì„±:</h3>\n<p>í•´ë‹¹ í•¨ìˆ˜ëŠ” í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬, nft-images í•˜ìœ„ ë””ë ‰í† ë¦¬ ë° ì œê³µëœ íŒŒì¼ ì´ë¦„ì„ ê²°í•©í•˜ì—¬ íŒŒì¼ ê²½ë¡œë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.</p>\n<h3>íŒŒì¼ ì½ê¸°:</h3>\n<p>ì§€ì •ëœ íŒŒì¼ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì—´ê³  ì½ì–´ì„œ í•´ë‹¹ ë°”ì´íŠ¸ë¥¼ ë²¡í„°ë¡œ ìˆ˜ì§‘í•©ë‹ˆë‹¤.</p>\n<h3>í¼ ì¤€ë¹„:</h3>\n<p>íŒŒì¼ ë°”ì´íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ë©€í‹°íŒŒíŠ¸ í¼ì„ ì¤€ë¹„í•˜ê³ , íŒŒì¼ ì´ë¦„ì„ í¼ ë°ì´í„°ì˜ ì¼ë¶€ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.</p>\n<p><strong>IPFS API ìš”ì²­:</strong> IPFS ë…¸ë“œì˜ add ì—”ë“œí¬ì¸íŠ¸ (/api/v0/add)ë¡œ ë©€í‹°íŒŒíŠ¸ í¼ì„ ì „ì†¡í•˜ëŠ” POST ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤.</p>\n<p><strong>ì‘ë‹µ ì²˜ë¦¬:</strong></p>\n<ul>\n<li>ì„±ê³µ ì‹œ, IPFS ì‘ë‹µì„ êµ¬ë¬¸ ë¶„ì„í•˜ì—¬ íŒŒì¼ì˜ IPFS í•´ì‹œë¥¼ ì¶”ì¶œí•˜ê³ , í•´ë‹¹ íŒŒì¼ì„ IPFS ê²Œì´íŠ¸ì›¨ì´ë¥¼ í†µí•´ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆëŠ” URLì„ êµ¬ì„±í•œ í›„, ì´ URLì´ í¬í•¨ëœ ì„±ê³µì ì¸ ApiResponseë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</li>\n<li>ì‹¤íŒ¨ ì‹œ, ì—…ë¡œë“œ ì‹¤íŒ¨ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ApiResponseë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</li>\n</ul>\n<p><strong>ë‹¨ê³„ 5. ì—ëŸ¬ ì²˜ë¦¬</strong></p>\n<p>ì—ëŸ¬.rs íŒŒì¼ì€ ì‘ìš© í”„ë¡œê·¸ë¨ ì‘ë™ ì¤‘ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì—ëŸ¬ ìœ í˜•ì„ ì •ì˜í•˜ê³  ê´€ë¦¬í•˜ëŠ” ë° ì „ë…ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ ëª¨ë“ˆì€ ì‚¬ìš©ì ì •ì˜ ì—ëŸ¬ ìœ í˜•ì„ ì •ì˜í•˜ëŠ” ë° thiserror í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ê³  ì´ëŸ¬í•œ ì—ëŸ¬ë¥¼ ì ì ˆí•œ HTTP ì‘ë‹µìœ¼ë¡œ ë§¤í•‘í•˜ëŠ” axum í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ íŒŒì¼ ë‚´ì—ì„œ ì—ëŸ¬ ì²˜ë¦¬ê°€ ì–´ë–»ê²Œ êµ¬ì¡°í™”ë˜ì–´ ìˆëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> axum::{\n    http::StatusCode,\n    response::{IntoResponse, Response},\n    Json,\n};\n<span class=\"hljs-keyword\">use</span> serde_json::json;\n<span class=\"hljs-keyword\">use</span> thiserror::Error;\n\n<span class=\"hljs-comment\">// `thiserror`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš©ì ì •ì˜ ì‘ìš© í”„ë¡œê·¸ë¨ ì—ëŸ¬ ìœ í˜• ì •ì˜</span>\n<span class=\"hljs-meta\">#[derive(Error, Debug)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">AppError</span> {\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"ì˜ëª»ëœ ìš”ì²­: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">BadRequest</span>(<span class=\"hljs-type\">String</span>),\n\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"ë‚´ë¶€ ì„œë²„ ì—ëŸ¬: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">InternalServerError</span>(<span class=\"hljs-type\">String</span>),\n\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"Web3 ì—ëŸ¬: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">Web3Error</span>(<span class=\"hljs-meta\">#[from]</span> web3::Error),\n\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"ì§ë ¬í™” ì—ëŸ¬: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">SerdeError</span>(<span class=\"hljs-meta\">#[from]</span> serde_json::Error),\n\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"ë‚´ë¶€ ì—ëŸ¬: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">GenericError</span>(<span class=\"hljs-type\">String</span>),\n\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì—ëŸ¬: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">NotFound</span>(<span class=\"hljs-type\">String</span>),\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">From</span>&#x3C;<span class=\"hljs-type\">Box</span>&#x3C;<span class=\"hljs-keyword\">dyn</span> std::error::Error>> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">AppError</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from</span>(err: <span class=\"hljs-type\">Box</span>&#x3C;<span class=\"hljs-keyword\">dyn</span> std::error::Error>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">Self</span> {\n        AppError::<span class=\"hljs-title function_ invoke__\">GenericError</span>(<span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {}\"</span>, err))\n    }\n}\n\n<span class=\"hljs-comment\">// `AppError`ë¥¼ `IntoResponse`ì— êµ¬í˜„í•˜ì—¬ HTTP ì‘ë‹µìœ¼ë¡œ ë³€í™˜</span>\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">IntoResponse</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">AppError</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">into_response</span>(<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> Response {\n        <span class=\"hljs-keyword\">let</span> (status, error_message) = <span class=\"hljs-keyword\">match</span> &#x26;<span class=\"hljs-keyword\">self</span> {\n            AppError::<span class=\"hljs-title function_ invoke__\">BadRequest</span>(message) => (StatusCode::BAD_REQUEST, message.<span class=\"hljs-title function_ invoke__\">clone</span>()),\n            AppError::<span class=\"hljs-title function_ invoke__\">InternalServerError</span>(message) => {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.<span class=\"hljs-title function_ invoke__\">clone</span>())\n            }\n            AppError::<span class=\"hljs-title function_ invoke__\">Web3Error</span>(message) => {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.<span class=\"hljs-title function_ invoke__\">to_string</span>())\n            }\n            AppError::<span class=\"hljs-title function_ invoke__\">SerdeError</span>(message) => {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.<span class=\"hljs-title function_ invoke__\">to_string</span>())\n            }\n            AppError::<span class=\"hljs-title function_ invoke__\">GenericError</span>(message) => (StatusCode::INTERNAL_SERVER_ERROR, message.<span class=\"hljs-title function_ invoke__\">clone</span>()),\n            AppError::<span class=\"hljs-title function_ invoke__\">NotFound</span>(message) => (StatusCode::INTERNAL_SERVER_ERROR, message.<span class=\"hljs-title function_ invoke__\">clone</span>()),\n        };\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">body</span> = <span class=\"hljs-title function_ invoke__\">Json</span>(json!({ <span class=\"hljs-string\">\"error\"</span>: error_message })).<span class=\"hljs-title function_ invoke__\">into_response</span>();\n        (status, body).<span class=\"hljs-title function_ invoke__\">into_response</span>()\n    }\n}\n\n<span class=\"hljs-comment\">// íŒŒì¼ ì—…ë¡œë“œ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ì‚¬ìš©ì ì •ì˜ UploadError ìœ í˜•</span>\n<span class=\"hljs-meta\">#[derive(Error, Debug)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">UploadError</span> {\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"IO ì—ëŸ¬: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">IoError</span>(<span class=\"hljs-meta\">#[from]</span> std::io::Error),\n}\n\n<span class=\"hljs-meta\">#[derive(Error, Debug)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">SignatureError</span> {\n    <span class=\"hljs-meta\">#[error(<span class=\"hljs-string\">\"Hex ë””ì½”ë”© ì—ëŸ¬: {0}\"</span>)]</span>\n    <span class=\"hljs-title function_ invoke__\">HexDecodeError</span>(<span class=\"hljs-meta\">#[from]</span> hex::FromHexError),\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">From</span>&#x3C;SignatureError> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">AppError</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from</span>(err: SignatureError) <span class=\"hljs-punctuation\">-></span> AppError {\n        <span class=\"hljs-keyword\">match</span> err {\n            SignatureError::<span class=\"hljs-title function_ invoke__\">HexDecodeError</span>(_) => {\n                AppError::<span class=\"hljs-title function_ invoke__\">BadRequest</span>(<span class=\"hljs-string\">\"ì˜ëª»ëœ hex í˜•ì‹\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>())\n            }\n        }\n    }\n}\n\n<span class=\"hljs-comment\">// `UploadError`ë¥¼ `IntoResponse`ì— êµ¬í˜„í•˜ì—¬ HTTP ì‘ë‹µìœ¼ë¡œ ë³€í™˜</span>\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">IntoResponse</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">UploadError</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">into_response</span>(<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> Response {\n        <span class=\"hljs-keyword\">let</span> (status, error_message) = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            UploadError::<span class=\"hljs-title function_ invoke__\">IoError</span>(_) => (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                <span class=\"hljs-string\">\"ë‚´ë¶€ ì„œë²„ ì—ëŸ¬\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n            ),\n        };\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">body</span> = <span class=\"hljs-title function_ invoke__\">Json</span>(json!({ <span class=\"hljs-string\">\"error\"</span>: error_message })).<span class=\"hljs-title function_ invoke__\">into_response</span>();\n        (status, body).<span class=\"hljs-title function_ invoke__\">into_response</span>()\n    }\n}\n</code></pre>\n<h2>ì‚¬ìš©ì ì •ì˜ ì‘ìš© í”„ë¡œê·¸ë¨ ì—ëŸ¬ ìœ í˜•</h2>\n<ul>\n<li>AppError: ì‘ìš© í”„ë¡œê·¸ë¨ì˜ ì£¼ìš” ì—ëŸ¬ ìœ í˜•ìœ¼ë¡œ, ì˜ëª»ëœ ìš”ì²­, ë‚´ë¶€ ì„œë²„ ì—ëŸ¬ ë° Web3 ìƒí˜¸ ì‘ìš©, ì§ë ¬í™” ë¬¸ì œ ë° ì¼ë°˜ì ì¸ ì—ëŸ¬ì™€ ê´€ë ¨ëœ íŠ¹ì • ì—ëŸ¬ì™€ ê°™ì€ ë‹¤ì–‘í•œ ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ í¬ê´„í•©ë‹ˆë‹¤. AppErrorì˜ ê° ë³€í˜•ì€ ì„¤ëª…ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì—ëŸ¬ ì‘ë‹µì˜ ë””ë²„ê¹… ë° ì‚¬ìš©ì ì¹œí™”ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.</li>\n<li>UploadError ë° SignatureError: ì´ë“¤ì€ ê°ê° íŒŒì¼ ì—…ë¡œë“œ ì—ëŸ¬ ë° ì„œëª… ê´€ë ¨ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ íŠ¹ìˆ˜í™”ëœ ì—ëŸ¬ ìœ í˜•ì…ë‹ˆë‹¤. AppErrorì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë‹¤ì–‘í•œ ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤ì— ëŒ€í•´ íŠ¹ì • ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì œê³µí•©ë‹ˆë‹¤.</li>\n</ul>\n<h2>ì˜¤ë¥˜ ë³€í™˜</h2>\n<ul>\n<li>From íŠ¸ë ˆì´íŠ¸ëŠ” ë³´ë‹¤ ë„“ì€ ì˜¤ë¥˜ ìœ í˜•(std::io::Error ë° hex::FromHexErrorì™€ ê°™ì€)ì—ì„œ êµ¬ì²´ì ì¸ ì‘ìš© í”„ë¡œê·¸ë¨ ì˜¤ë¥˜(UploadError ë° SignatureError)ë¡œì˜ ë³€í™˜ì„ í—ˆìš©í•˜ê¸° ìœ„í•´ êµ¬í˜„ë©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ë‹¤ì–‘í•œ ì˜¤ë¥˜ ì›ì²œì„ ì˜ ì •ì˜ëœ ë²”ì£¼ë¡œ ìº¡ìŠí™”í•˜ì—¬ ì‘ìš© í”„ë¡œê·¸ë¨ì˜ ë‹¤ì–‘í•œ ë¶€ë¶„ì—ì„œ ì›í™œí•œ ì˜¤ë¥˜ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.</li>\n</ul>\n<h2>ì˜¤ë¥˜ ì‘ë‹µ</h2>\n<ul>\n<li>AppError, UploadError ë° SignatureErrorì— ëŒ€í•œ IntoResponse íŠ¸ë ˆì´íŠ¸ êµ¬í˜„ì€ ì´ëŸ¬í•œ ì˜¤ë¥˜ë¥¼ HTTP ì‘ë‹µìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ì˜¤ë¥˜ ìœ í˜• ë° í•´ë‹¹ ë©”ì‹œì§€ì— ë”°ë¼ ì í•©í•œ HTTP ìƒíƒœ ì½”ë“œ(ì˜ˆ: StatusCode::BAD_REQUEST ë˜ëŠ” StatusCode::INTERNAL_SERVER_ERROR)ê°€ ì„ íƒë©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ JSON ê°ì²´ë¡œ ì§ë ¬í™”ë˜ì–´ API ì†Œë¹„ìë¥¼ ìœ„í•œ ì¼ê´€ëœ ë° ì •ë³´ ì œê³µì´ ë˜ëŠ” ì˜¤ë¥˜ ì‘ë‹µ í˜•ì‹ì„ ì œê³µí•©ë‹ˆë‹¤.</li>\n</ul>\n<h1>Step 6. ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜</h1>\n<p>utils.rs ëª¨ë“ˆì€ ì•”í˜¸í™” ë°©ì‹ìœ¼ë¡œ ê°œì¸ í‚¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ì— ì„œëª…í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ë¸”ë¡ì²´ì¸ íŠ¸ëœì­ì…˜ì´ë‚˜ ì•ˆì „í•œ ë°ì´í„° êµí™˜ê³¼ ê°™ì´ ë°ì´í„°ì˜ ì‹ ë¢°ì„±ê³¼ ë¬´ê²°ì„±ì„ í™•ì¸í•´ì•¼ í•˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ íŠ¹íˆ ìœ ìš©í•©ë‹ˆë‹¤.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> secp256k1::{Message, Secp256k1, SecretKey};\n<span class=\"hljs-keyword\">use</span> sha3::{Digest, Keccak256};\n<span class=\"hljs-keyword\">use</span> std::error::Error;\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">mock_sign_data</span>(data: &#x26;[<span class=\"hljs-type\">u8</span>], private_key_hex: &#x26;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">String</span>, <span class=\"hljs-type\">Box</span>&#x3C;<span class=\"hljs-keyword\">dyn</span> Error>> {\n    <span class=\"hljs-comment\">// 16ì§„ìˆ˜ ê°œì¸ í‚¤ë¥¼ ë””ì½”ë“œí•©ë‹ˆë‹¤</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">private_key</span> = SecretKey::<span class=\"hljs-title function_ invoke__\">from_slice</span>(&#x26;hex::<span class=\"hljs-title function_ invoke__\">decode</span>(private_key_hex)?)?;\n\n    <span class=\"hljs-comment\">// ìƒˆë¡œìš´ Secp256k1 ì»¨í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">secp</span> = Secp256k1::<span class=\"hljs-title function_ invoke__\">new</span>();\n\n    <span class=\"hljs-comment\">// Keccak256ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° í•´ì‹±</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">data_hash</span> = Keccak256::<span class=\"hljs-title function_ invoke__\">digest</span>(data);\n\n    <span class=\"hljs-comment\">// í•´ì‹œì— ì„œëª…í•©ë‹ˆë‹¤</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">message</span> = Message::<span class=\"hljs-title function_ invoke__\">from_digest_slice</span>(&#x26;data_hash)?;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">signature</span> = secp.<span class=\"hljs-title function_ invoke__\">sign_ecdsa</span>(&#x26;message, &#x26;private_key);\n\n    <span class=\"hljs-comment\">// ì„œëª…ì„ 16ì§„ìˆ˜ë¡œ ì¸ì½”ë”©í•©ë‹ˆë‹¤</span>\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(hex::<span class=\"hljs-title function_ invoke__\">encode</span>(signature.<span class=\"hljs-title function_ invoke__\">serialize_compact</span>()))\n}\n</code></pre>\n<p>í”„ë¡œì„¸ìŠ¤:</p>\n<h3>Hex Decoding:</h3>\n<p>The process kicks off with the hex::decode function, which decodes the hexadecimal private key into bytes.</p>\n<h3>Private Key Preparation:</h3>\n<p>Next up, the decoded bytes are transformed into a SecretKey instance that aligns with the secp256k1 cryptographic library.</p>\n<h3>Hashing:</h3>\n<p>The data undergoes hashing through the Keccak256 algorithm, a variation of SHA-3 extensively utilized in Ethereum for hashing operations.</p>\n<h3>Signing:</h3>\n<p>Subsequently, the hash gets enveloped in a Message type, and the secp256k1 library steps in to sign this message with the designated private key.</p>\n<p>16ì§„ìˆ˜ ì¸ì½”ë”©: ë§ˆì§€ë§‰ìœ¼ë¡œ, ì„œëª…ì€ ê°„ê²°í•œ í˜•ì‹ìœ¼ë¡œ ì§ë ¬í™”ë˜ì–´ ì‰¬ìš´ ì „ì†¡ê³¼ ì €ì¥ì„ ìœ„í•´ 16ì§„ìˆ˜ ë¬¸ìì—´ë¡œ ì¸ì½”ë”©ë©ë‹ˆë‹¤.</p>\n<h2>ì•”í˜¸ ë¼ì´ë¸ŒëŸ¬ë¦¬</h2>\n<ul>\n<li>ì´ ê¸°ëŠ¥ì€ secp256k1 ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•˜ì—¬ íƒ€ì› ê³¡ì„  ì•”í˜¸í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì´ë”ë¦¬ì›€ê³¼ ë¹„íŠ¸ì½”ì¸ì—ì„œ ì„œëª… ìƒì„± ë° í™•ì¸ì— ì‚¬ìš©ë˜ëŠ” secp256k1 ê³¡ì„ ì„ íŠ¹ë³„íˆ ì§€ì›í•©ë‹ˆë‹¤.</li>\n<li>sha3 í¬ë ˆì´íŠ¸ëŠ” Keccak256 í•´ì‹œ ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„ì„ ì œê³µí•˜ì—¬, ë°ì´í„° ì„œëª… í”„ë¡œì„¸ìŠ¤ê°€ ë¸”ë¡ì²´ì¸ ê¸°ìˆ ì—ì„œ í”íˆ ì‚¬ìš©ë˜ëŠ” ì•”í˜¸í™” ê´€í–‰ê³¼ ì¼ì¹˜í•¨ì„ ë³´ì¥í•©ë‹ˆë‹¤.</li>\n</ul>\n<h1>ë‹¨ê³„ 7. í•µì‹¬ API êµ¬í˜„</h1>\n<p><code>main.rs</code> íŒŒì¼ì€ Rust NFT APIì˜ ì§„ì…ì  ì—­í• ì„ í•˜ë©°, ë‹¤ì–‘í•œ êµ¬ì„± ìš”ì†Œë¥¼ ì¡°ì •í•˜ì—¬ NFT ê´€ë¦¬ë¥¼ ìœ„í•œ í¬ê´„ì ì¸ ë°±ì—”ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ê° ì½”ë“œ ì„¹ì…˜ë³„ë¡œ ì„¤ëª…ê³¼ í•¨ê»˜ ì•„ë˜ì™€ ê°™ì´ ì½”ë“œë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:</p>\n<h2>OpenAPI ìŠ¤í‚¤ë§ˆ ìƒì„±</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[derive(utoipa::OpenApi)]</span>\n<span class=\"hljs-meta\">#[openapi(\n    handlers(process_mint_nft, get_nft_metadata, list_tokens),\n    components(MintNftRequest, NftMetadata)\n)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ApiDoc</span>;\n\n<span class=\"hljs-comment\">// OpenAPI ìŠ¤í‚¤ë§ˆì˜ JSON ë²„ì „ ë°˜í™˜</span>\n<span class=\"hljs-meta\">#[utoipa::path(\n    get,\n    path = <span class=\"hljs-string\">\"/api/openapi.json\"</span>,\n    responses(\n        (status = 200, description = <span class=\"hljs-string\">\"JSON íŒŒì¼\"</span>, body = Json)\n    )\n)]</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">openapi</span>() <span class=\"hljs-punctuation\">-></span> Json&#x3C;utoipa::openapi::OpenApi> {\n    <span class=\"hljs-title function_ invoke__\">Json</span>(ApiDoc::<span class=\"hljs-title function_ invoke__\">openapi</span>())\n}\n</code></pre>\n<p>ì´ í•¨ìˆ˜ëŠ” JSON í˜•ì‹ìœ¼ë¡œ OpenAPI ìŠ¤í‚¤ë§ˆë¥¼ ìƒì„±í•˜ë©°, ê°œë°œìë“¤ì—ê²Œ API ì—”ë“œí¬ì¸íŠ¸, ìš”ì²­ ë³¸ë¬¸ ë° ì‘ë‹µì˜ ëª…í™•í•œ ëª…ì„¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ëŠ” API ë°œê²¬ ë° ìƒí˜¸ ì‘ìš©ì„ ë•ëŠ” OpenAPI ë¬¸ì„œí™”ë¥¼ ìœ„í•´ utoipa í¬ë ˆì´íŠ¸ë¥¼ í™œìš©í•©ë‹ˆë‹¤.</p>\n<h2>NFT Minting Endpoint</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">process_mint_nft</span>(\n    <span class=\"hljs-title class_\">Extension</span>(web3_client): <span class=\"hljs-title class_\">Extension</span>&#x3C;<span class=\"hljs-title class_\">Arc</span>&#x3C;<span class=\"hljs-title class_\">Web3Client</span>>>,\n    <span class=\"hljs-title class_\">Json</span>(payload): <span class=\"hljs-title class_\">Json</span>&#x3C;<span class=\"hljs-title class_\">MintNftRequest</span>>,\n) -> <span class=\"hljs-title class_\">Result</span>&#x3C;<span class=\"hljs-title class_\">Json</span>&#x3C;<span class=\"hljs-title class_\">NftMetadata</span>>, <span class=\"hljs-title class_\">AppError</span>> {\n#[<span class=\"hljs-attr\">utoipa</span>::<span class=\"hljs-title function_\">path</span>(\npost,\n    path = <span class=\"hljs-string\">\"/mint\"</span>,\n    request_body = <span class=\"hljs-title class_\">MintNftRequest</span>,\n<span class=\"hljs-title function_\">responses</span>(\n    (status = <span class=\"hljs-number\">200</span>, description = <span class=\"hljs-string\">\"NFT minted successfully\"</span>, body = <span class=\"hljs-title class_\">NftMetadata</span>),\n    (status = <span class=\"hljs-number\">400</span>, description = <span class=\"hljs-string\">\"Bad Request\"</span>),\n    (status = <span class=\"hljs-number\">500</span>, description = <span class=\"hljs-string\">\"Internal Server Error\"</span>)\n)\n)]\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">process_mint_nft</span>(\n    <span class=\"hljs-title class_\">Extension</span>(web3_client): <span class=\"hljs-title class_\">Extension</span>&#x3C;<span class=\"hljs-title class_\">Arc</span>&#x3C;<span class=\"hljs-title class_\">Web3Client</span>>>,\n    <span class=\"hljs-title class_\">Json</span>(payload): <span class=\"hljs-title class_\">Json</span>&#x3C;<span class=\"hljs-title class_\">MintNftRequest</span>>,\n) -> <span class=\"hljs-title class_\">Result</span>&#x3C;<span class=\"hljs-title class_\">Json</span>&#x3C;<span class=\"hljs-title class_\">NftMetadata</span>>, <span class=\"hljs-title class_\">AppError</span>> {\n    <span class=\"hljs-keyword\">let</span> owner_address = payload\n        .<span class=\"hljs-property\">owner_address</span>\n        .<span class=\"hljs-property\">parse</span>::&#x3C;<span class=\"hljs-title class_\">Address</span>>()\n        .<span class=\"hljs-title function_\">map_err</span>(|_| <span class=\"hljs-title class_\">AppError</span>::<span class=\"hljs-title class_\">BadRequest</span>(<span class=\"hljs-string\">\"Invalid owner address\"</span>.<span class=\"hljs-title function_\">into</span>()))?;\n\n    <span class=\"hljs-comment\">// Retrieve the mock private key from environment variables</span>\n    <span class=\"hljs-keyword\">let</span> mock_private_key = <span class=\"hljs-attr\">env</span>::<span class=\"hljs-title function_\">var</span>(<span class=\"hljs-string\">\"MOCK_PRIVATE_KEY\"</span>).<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"MOCK_PRIVATE_KEY must be set\"</span>);\n\n    <span class=\"hljs-comment\">// Simulate data to be signed</span>\n    <span class=\"hljs-keyword\">let</span> data_to_sign = format!(<span class=\"hljs-string\">\"{}:{}\"</span>, payload.<span class=\"hljs-property\">owner_address</span>, payload.<span class=\"hljs-property\">token_name</span>).<span class=\"hljs-title function_\">into_bytes</span>();\n\n    <span class=\"hljs-comment\">// Perform mock signature</span>\n    <span class=\"hljs-keyword\">let</span> _mock_signature = <span class=\"hljs-title function_\">mock_sign_data</span>(&#x26;data_to_sign, &#x26;mock_private_key)?;\n\n    <span class=\"hljs-keyword\">let</span> upload_response = match <span class=\"hljs-attr\">ipfs</span>::<span class=\"hljs-title function_\">file_upload</span>(payload.<span class=\"hljs-property\">file_path</span>.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span> {\n        <span class=\"hljs-title class_\">Ok</span>(response) => response,\n        <span class=\"hljs-title class_\">Err</span>(_) => unreachable!(), <span class=\"hljs-comment\">// Since Err is Infallible, this branch will never be executed</span>\n    };\n\n    <span class=\"hljs-keyword\">let</span> uploaded_token_uri = upload_response.<span class=\"hljs-property\">token_uri</span>.<span class=\"hljs-title function_\">clone</span>().<span class=\"hljs-title function_\">unwrap</span>();\n\n    <span class=\"hljs-comment\">// Call mint_nft using the file_url as the token_uri</span>\n    <span class=\"hljs-keyword\">let</span> token_id = <span class=\"hljs-title function_\">mint_nft</span>(\n        &#x26;web3_client.<span class=\"hljs-property\">web3</span>,\n        &#x26;web3_client.<span class=\"hljs-property\">contract</span>,\n        owner_address,\n        uploaded_token_uri.<span class=\"hljs-title function_\">clone</span>(),\n        payload.<span class=\"hljs-property\">token_name</span>.<span class=\"hljs-title function_\">clone</span>(),\n    )\n    .<span class=\"hljs-property\">await</span>\n    .<span class=\"hljs-title function_\">map_err</span>(|e| <span class=\"hljs-title class_\">AppError</span>::<span class=\"hljs-title class_\">InternalServerError</span>(format!(<span class=\"hljs-string\">\"Failed to mint NFT: {}\"</span>, e)))?;\n\n    <span class=\"hljs-title class_\">Ok</span>(<span class=\"hljs-title class_\">Json</span>(<span class=\"hljs-title class_\">NftMetadata</span> {\n        <span class=\"hljs-attr\">token_id</span>: token_id.<span class=\"hljs-title function_\">to_string</span>(),\n        <span class=\"hljs-attr\">owner_address</span>: payload.<span class=\"hljs-property\">owner_address</span>,\n        <span class=\"hljs-attr\">token_name</span>: payload.<span class=\"hljs-property\">token_name</span>,\n        <span class=\"hljs-attr\">token_uri</span>: uploaded_token_uri.<span class=\"hljs-title function_\">clone</span>(),\n    }))\n}    \n\n\n}\n</code></pre>\n<p>ìœ„ ì½”ë“œëŠ” NFT Minting Endpointì— ëŒ€í•œ ë‚´ìš©ì…ë‹ˆë‹¤. í•´ë‹¹ ì—”ë“œí¬ì¸íŠ¸ëŠ” ìƒˆë¡œìš´ NFTë¥¼ ë°œí–‰í•˜ëŠ” ìš”ì²­ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤. MintNftRequest í˜ì´ë¡œë“œë¥¼ í†µí•´ NFT ì†Œìœ ìì˜ ì£¼ì†Œ, í† í° ì´ë¦„ ë° íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥ë°›ìŠµë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ëª¨ì˜ ì„œëª… ì‘ì—…ì„ ìˆ˜í–‰í•˜ê³ , ì—°ê´€ëœ íŒŒì¼ì„ IPFSì— ì—…ë¡œë“œí•˜ë©°, ìŠ¤ë§ˆíŠ¸ ê³„ì•½ê³¼ ìƒí˜¸ì‘ìš©í•˜ì—¬ NFTë¥¼ ë°œí–‰í•˜ê³  ì„±ê³µ ì‹œ NFT ë©”íƒ€ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.</p>\n<h2>NFT Metadata Retrieval Endpoint</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[utoipa::path(\nget,\n    path = <span class=\"hljs-string\">\"/nft/{token_id}\"</span>,\nparams(\n    (<span class=\"hljs-string\">\"token_id\"</span> = String, )),\nresponses(\n    (status = 200, description = <span class=\"hljs-string\">\"NFT ë©”íƒ€ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤\"</span>, body = NftMetadata),\n    (status = 400, description = <span class=\"hljs-string\">\"ì˜ëª»ëœ ìš”ì²­\"</span>),\n    (status = 500, description = <span class=\"hljs-string\">\"ë‚´ë¶€ ì„œë²„ ì˜¤ë¥˜\"</span>)\n)\n)]</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_nft_metadata</span>(\n    <span class=\"hljs-title function_ invoke__\">Extension</span>(web3_client): Extension&#x3C;Arc&#x3C;Web3Client>>,\n    <span class=\"hljs-title function_ invoke__\">Path</span>(token_id): Path&#x3C;<span class=\"hljs-type\">String</span>>,\n) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;Json&#x3C;NftMetadata>, AppError> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">parsed_token_id</span> = token_id\n        .parse::&#x3C;U256>()\n        .<span class=\"hljs-title function_ invoke__\">map_err</span>(|_| AppError::<span class=\"hljs-title function_ invoke__\">BadRequest</span>(<span class=\"hljs-string\">\"ì˜ëª»ëœ í† í° ID\"</span>.<span class=\"hljs-title function_ invoke__\">into</span>()))?;\n\n    <span class=\"hljs-keyword\">match</span> <span class=\"hljs-title function_ invoke__\">get_nft_details</span>(&#x26;web3_client.contract, parsed_token_id.<span class=\"hljs-title function_ invoke__\">to_string</span>()).<span class=\"hljs-keyword\">await</span> {\n        <span class=\"hljs-title function_ invoke__\">Ok</span>((_, token_name, token_owner, token_uri)) => {\n            <span class=\"hljs-comment\">// í† í°ì„ ìœ„í•œ NftMetadata êµ¬ì„±</span>\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nft_metadata</span> = NftMetadata {\n                token_id: parsed_token_id.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n                owner_address: <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, token_owner),\n                token_name,\n                token_uri,\n            };\n\n            <span class=\"hljs-title function_ invoke__\">Ok</span>(<span class=\"hljs-title function_ invoke__\">Json</span>(nft_metadata))\n        }\n        <span class=\"hljs-title function_ invoke__\">Err</span>(AppError::<span class=\"hljs-title function_ invoke__\">NotFound</span>(msg)) => <span class=\"hljs-title function_ invoke__\">Err</span>(AppError::<span class=\"hljs-title function_ invoke__\">NotFound</span>(msg)),\n        <span class=\"hljs-title function_ invoke__\">Err</span>(_) => <span class=\"hljs-title function_ invoke__\">Err</span>(AppError::<span class=\"hljs-title function_ invoke__\">InternalServerError</span>(\n            <span class=\"hljs-string\">\"NFT ì„¸ë¶€ ì •ë³´ë¥¼ ê²€ìƒ‰í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤\"</span>.<span class=\"hljs-title function_ invoke__\">into</span>(),\n        )),\n    }\n}\n</code></pre>\n<p>ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” í† í° IDë¥¼ ì œê³µë°›ì•„ í•´ë‹¹ NFTì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤. í† í°ì˜ ì´ë¦„ ë° URIì™€ ê°™ì€ ì„¸ë¶€ ì •ë³´ë¥¼ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì—ì„œ ì¿¼ë¦¬í•˜ì—¬ NFTì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ì œê³µí•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì„ ì œê³µí•©ë‹ˆë‹¤.</p>\n<h2>NFT ë¦¬ìŠ¤íŠ¸ ì—”ë“œí¬ì¸íŠ¸</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[utoipa::path(\nget,\n    path = <span class=\"hljs-string\">\"/tokens/{owner_address}\"</span>,\nparams(\n    (<span class=\"hljs-string\">\"owner_address\"</span> = Option&#x3C;String>, description = <span class=\"hljs-string\">\"í† í°ì„ ì†Œìœ ìë³„ë¡œ í•„í„°ë§í•  ì†Œìœ ì ì£¼ì†Œ. ëª¨ë“  í† í°ì„ ë‚˜ì—´í•˜ë ¤ë©´ ìœ í˜• 0ì„ ì…ë ¥í•˜ì‹­ì‹œì˜¤.\"</span>)\n),\nresponses(\n    (status = 200, description = <span class=\"hljs-string\">\"í† í° ëª©ë¡ì´ ì„±ê³µì ìœ¼ë¡œ ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤\"</span>, body = [NftMetadata]</span>),\n    (status = <span class=\"hljs-number\">400</span>, description = <span class=\"hljs-string\">\"ì˜ëª»ëœ ìš”ì²­\"</span>),\n    (status = <span class=\"hljs-number\">500</span>, description = <span class=\"hljs-string\">\"ë‚´ë¶€ ì„œë²„ ì˜¤ë¥˜\"</span>)\n)\n)]\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">list_tokens</span>(\n    <span class=\"hljs-title function_ invoke__\">Extension</span>(web3_client): Extension&#x3C;Arc&#x3C;Web3Client>>,\n    token_owner: <span class=\"hljs-type\">Option</span>&#x3C;Path&#x3C;<span class=\"hljs-type\">String</span>>>,\n) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;Json&#x3C;<span class=\"hljs-type\">Vec</span>&#x3C;NftMetadata>>, StatusCode> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">owner_address</span> = <span class=\"hljs-keyword\">match</span> token_owner {\n        <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-keyword\">ref</span> owner) <span class=\"hljs-keyword\">if</span> owner.<span class=\"hljs-number\">0</span> != <span class=\"hljs-string\">\"0\"</span> => <span class=\"hljs-keyword\">match</span> owner.<span class=\"hljs-number\">0</span>.parse::&#x3C;Address>() {\n            <span class=\"hljs-comment\">// ì†Œìœ ìê°€ \"0\"ì´ ì•„ë‹Œì§€ í™•ì¸</span>\n            <span class=\"hljs-title function_ invoke__\">Ok</span>(addr) => addr,\n            <span class=\"hljs-title function_ invoke__\">Err</span>(_) => <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(StatusCode::BAD_REQUEST),\n        },\n        _ => Address::<span class=\"hljs-title function_ invoke__\">default</span>(), <span class=\"hljs-comment\">// \"0\" ë˜ëŠ” ì—†ìŒì„ ëª¨ë“  í† í°ì„ ë‚˜ì—´í•˜ëŠ” í‘œì‹œë¡œ ì·¨ê¸‰</span>\n    };\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">token_ids</span> =\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-title function_ invoke__\">get_all_owned_tokens</span>(&#x26;web3_client.web3, &#x26;web3_client.contract, owner_address).<span class=\"hljs-keyword\">await</span> {\n            <span class=\"hljs-title function_ invoke__\">Ok</span>(ids) => ids,\n            <span class=\"hljs-title function_ invoke__\">Err</span>(_) => <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(StatusCode::INTERNAL_SERVER_ERROR),\n        };\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">nft_metadata_list</span> = <span class=\"hljs-type\">Vec</span>::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">token_id</span> <span class=\"hljs-keyword\">in</span> token_ids {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-title function_ invoke__\">get_nft_details</span>(&#x26;web3_client.contract, token_id.<span class=\"hljs-title function_ invoke__\">to_string</span>()).<span class=\"hljs-keyword\">await</span> {\n            <span class=\"hljs-title function_ invoke__\">Ok</span>((_, token_name, _onwer, token_uri)) => {\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nft_metadata</span> = NftMetadata {\n                    token_id: token_id.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n                    owner_address: _onwer.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n                    token_name,\n                    token_uri,\n                };\n                nft_metadata_list.<span class=\"hljs-title function_ invoke__\">push</span>(nft_metadata);\n            }\n            <span class=\"hljs-title function_ invoke__\">Err</span>(e) => eprintln!(<span class=\"hljs-string\">\"í† í° {}ì— ëŒ€í•œ ë©”íƒ€ë°ì´í„° ê²€ìƒ‰ ì‹¤íŒ¨: {:?}\"</span>, token_id, e), <span class=\"hljs-comment\">// í•„ìš”ì— ë”°ë¼ ë¡œê·¸ ë˜ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬</span>\n        }\n    }\n\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(<span class=\"hljs-title function_ invoke__\">Json</span>(nft_metadata_list))\n}\n</code></pre>\n<p><strong>list_tokens</strong> ì—”ë“œí¬ì¸íŠ¸ëŠ” íŠ¹ì • ì£¼ì†Œê°€ ì†Œìœ í•œ ëª¨ë“  NFTë¥¼ ë‚˜ì—´í•˜ê±°ë‚˜ íŠ¹ë³„í•œ ë§¤ê°œë³€ìˆ˜ê°€ ì œê³µëœ ê²½ìš° ëª¨ë‘ ë°œí–‰ëœ NFTë¥¼ ë‚˜ì—´í•©ë‹ˆë‹¤. ì´ëŠ” ìŠ¤ë§ˆíŠ¸ ê³„ì•½ìœ¼ë¡œ ì†Œìœ í•œ í† í° IDë¥¼ ì¡°íšŒí•˜ê³  ê°ê°ì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê³¼ì •ì„ í¬í•¨í•©ë‹ˆë‹¤.</p>\n<h2>NFT ìƒì„± ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[utoipa::path(\npost,\n    path = <span class=\"hljs-string\">\"/mint\"</span>,\n    request_body = MintNftRequest,\nresponses(\n    (status = 200, description = <span class=\"hljs-string\">\"NFTê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë¨\"</span>, body = NftMetadata),\n    (status = 400, description = <span class=\"hljs-string\">\"ì˜ëª»ëœ ìš”ì²­\"</span>),\n    (status = 500, description = <span class=\"hljs-string\">\"ë‚´ë¶€ ì„œë²„ ì˜¤ë¥˜\"</span>)\n)\n)]</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">process_mint_nft</span>(\n    <span class=\"hljs-title function_ invoke__\">Extension</span>(web3_client): Extension&#x3C;Arc&#x3C;Web3Client>>,\n    <span class=\"hljs-title function_ invoke__\">Json</span>(payload): Json&#x3C;MintNftRequest>,\n) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;Json&#x3C;NftMetadata>, AppError> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">owner_address</span> = payload\n        .owner_address\n        .parse::&#x3C;Address>()\n        .<span class=\"hljs-title function_ invoke__\">map_err</span>(|_| AppError::<span class=\"hljs-title function_ invoke__\">BadRequest</span>(<span class=\"hljs-string\">\"ìœ íš¨í•˜ì§€ ì•Šì€ ì†Œìœ ì ì£¼ì†Œ\"</span>.<span class=\"hljs-title function_ invoke__\">into</span>()))?;\n\n    <span class=\"hljs-comment\">// í™˜ê²½ ë³€ìˆ˜ì—ì„œ ëª¨ì˜ ê°œì¸ í‚¤ ê°€ì ¸ì˜¤ê¸°</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">mock_private_key</span> = env::<span class=\"hljs-title function_ invoke__\">var</span>(<span class=\"hljs-string\">\"MOCK_PRIVATE_KEY\"</span>).<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"MOCK_PRIVATE_KEYê°€ ì„¤ì •ë˜ì–´ ìˆì–´ì•¼ í•¨\"</span>);\n\n    <span class=\"hljs-comment\">// ì„œëª…ë  ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">data_to_sign</span> = <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{}:{}\"</span>, payload.owner_address, payload.token_name).<span class=\"hljs-title function_ invoke__\">into_bytes</span>();\n\n    <span class=\"hljs-comment\">// ëª¨ì˜ ì„œëª… ìˆ˜í–‰</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">_mock_signature</span> = <span class=\"hljs-title function_ invoke__\">mock_sign_data</span>(&#x26;data_to_sign, &#x26;mock_private_key)?;\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">upload_response</span> = <span class=\"hljs-keyword\">match</span> ipfs::<span class=\"hljs-title function_ invoke__\">file_upload</span>(payload.file_path.<span class=\"hljs-title function_ invoke__\">clone</span>()).<span class=\"hljs-keyword\">await</span> {\n        <span class=\"hljs-title function_ invoke__\">Ok</span>(response) => response,\n        <span class=\"hljs-title function_ invoke__\">Err</span>(_) => <span class=\"hljs-built_in\">unreachable!</span>(), <span class=\"hljs-comment\">// Errì€ Infallibleì´ë¯€ë¡œ ì´ ë¶€ë¶„ì€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ</span>\n    };\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">uploaded_token_uri</span> = upload_response.token_uri.<span class=\"hljs-title function_ invoke__\">clone</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n\n    <span class=\"hljs-comment\">// íŒŒì¼ URLì„ í† í° URIë¡œ ì‚¬ìš©í•˜ì—¬ mint_nft í˜¸ì¶œ</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">token_id</span> = <span class=\"hljs-title function_ invoke__\">mint_nft</span>(\n        &#x26;web3_client.web3,\n        &#x26;web3_client.contract,\n        owner_address,\n        uploaded_token_uri.<span class=\"hljs-title function_ invoke__\">clone</span>(),\n        payload.token_name.<span class=\"hljs-title function_ invoke__\">clone</span>(),\n    )\n    .<span class=\"hljs-keyword\">await</span>\n    .<span class=\"hljs-title function_ invoke__\">map_err</span>(|e| AppError::<span class=\"hljs-title function_ invoke__\">InternalServerError</span>(<span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"NFT ìƒì„± ì‹¤íŒ¨: {}\"</span>, e)))?;\n\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(<span class=\"hljs-title function_ invoke__\">Json</span>(NftMetadata {\n        token_id: token_id.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n        owner_address: payload.owner_address,\n        token_name: payload.token_name,\n        token_uri: uploaded_token_uri.<span class=\"hljs-title function_ invoke__\">clone</span>(),\n    }))\n}\n</code></pre>\n<p>ì´ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ëŠ” ìŠ¤ë§ˆíŠ¸ ê³„ì•½ê³¼ ìƒí˜¸ì‘ìš©í•˜ì—¬ ìƒˆ NFTë¥¼ ìƒì„±í•˜ë©°, ì†Œìœ ì, í† í° URI ë° í† í° ì´ë¦„ì„ ì§€ì •í•©ë‹ˆë‹¤. ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ê±°ë˜ë¥¼ êµ¬ì„±í•˜ê³  ë³´ë‚´ëŠ” ì„¸ë¶€ì‚¬í•­ì„ ìº¡ìŠí™”í•©ë‹ˆë‹¤.</p>\n<h2>ì†Œìœ í•œ í† í° ê²€ìƒ‰ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_all_owned_tokens</span>&#x3C;T: Transport>(\n    _web3: &#x26;Web3&#x3C;T>,\n    contract: &#x26;Contract&#x3C;T>,\n    owner: Address,\n) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">Vec</span>&#x3C;<span class=\"hljs-type\">u64</span>>, <span class=\"hljs-type\">Box</span>&#x3C;<span class=\"hljs-keyword\">dyn</span> Error>> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">options</span> = Options::<span class=\"hljs-title function_ invoke__\">with</span>(|opt| {\n        opt.gas = <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">1_000_000</span>.<span class=\"hljs-title function_ invoke__\">into</span>());\n    });\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">result</span>: <span class=\"hljs-type\">Vec</span>&#x3C;<span class=\"hljs-type\">u64</span>> = contract\n        .<span class=\"hljs-title function_ invoke__\">query</span>(<span class=\"hljs-string\">\"getAllTokensByOwner\"</span>, owner, owner, options, <span class=\"hljs-literal\">None</span>)\n        .<span class=\"hljs-keyword\">await</span>?;\n\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(result)\n}\n</code></pre>\n<p>ì´ í•¨ìˆ˜ëŠ” ì§€ì •ëœ ì£¼ì†Œê°€ ì†Œìœ í•œ í† í° ID ëª©ë¡ì„ ê°€ì ¸ì™€ ì‚¬ìš©ìê°€ ì†Œìœ í•œ NFT ëª©ë¡ì„ ë‚˜ì—´í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì„ ì¿¼ë¦¬í•˜ê³  ì‘ë‹µì„ ì‰½ê²Œ ì†Œë¹„í•  ìˆ˜ ìˆë„ë¡ í¬ë§·í•©ë‹ˆë‹¤.</p>\n<h2>ì„œë²„ ì´ˆê¸°í™” ë° ë¼ìš°íŠ¸ ì •ì˜</h2>\n<h2>ì£¼ì†Œ ì§€ì • ë° ë“¤ì–´ì˜¤ëŠ” ìš”ì²­ ìˆ˜ì‹  ì‹œì‘</h2>\n<p>ë©”ì¸ í•¨ìˆ˜ëŠ” Axum ì„œë²„ë¥¼ ì´ˆê¸°í™”í•˜ë©°, ì •ì˜ëœ ì—”ë“œí¬ì¸íŠ¸ì— ëŒ€í•œ ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  CORSì™€ ê°™ì€ ë¯¸ë“¤ì›¨ì–´ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤. ì„œë²„ë¥¼ ì§€ì •ëœ ì£¼ì†Œì— ë°”ì¸ë”©í•˜ê³  ë“¤ì–´ì˜¤ëŠ” ìš”ì²­ì„ ìˆ˜ì‹ í•˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤.</p>\n<h2>ì •ì  íŒŒì¼ ì œê³µ ì˜¤ë¥˜ ì²˜ë¦¬</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">handle_serve_dir_error</span>(error: io::Error) <span class=\"hljs-punctuation\">-></span> (StatusCode, <span class=\"hljs-type\">String</span>) {\n    (\n        StatusCode::INTERNAL_SERVER_ERROR,\n        <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"ì •ì  íŒŒì¼ ì œê³µì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {}\"</span>, error),\n    )\n}\n</code></pre>\n<p>ì´ ê¸°ëŠ¥ì€ ì •ì  íŒŒì¼ì„ ì œê³µí•˜ëŠ” ì¤‘ì— ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ ëª…í™•íˆ ë³´ê³ í•˜ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ì œê³µí•˜ì—¬ static/swagger-ui ë””ë ‰í† ë¦¬ì—ì„œ íŒŒì¼ì„ ì œê³µí•˜ëŠ” ë™ì•ˆ ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.</p>\n<p>main.rs íŒŒì¼ì˜ ê° ì„¹ì…˜ì€ Rust NFT APIì˜ ì „ì²´ ê¸°ëŠ¥ì— ê¸°ì—¬í•©ë‹ˆë‹¤. ì—”ë“œí¬ì¸íŠ¸ ì •ì˜ ë° ìš”ì²­ ì²˜ë¦¬ë¶€í„° ì´ë”ë¦¬ì›€ ë° IPFSì™€ ìƒí˜¸ ì‘ìš©í•˜ì—¬ NFT ì‘ìš© í”„ë¡œê·¸ë¨ì— ê°•ë ¥í•œ ë°±ì—”ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.</p>\n<p>GitHub ë ˆí¬ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”! ğŸš€</p>\n<p>Rust NFT APIì— ëŒ€í•œ ì´ ê¹Šì€ íƒêµ¬ê°€ ìœ ìµí•˜ê³  í¥ë¯¸ë¡œì› ê¸°ë¥¼ ë°”ëë‹ˆë‹¤. ìš°ë¦¬ ì¼ë°˜ì ì¸ ê¸€ë³´ë‹¤ ì¡°ê¸ˆ ë” ê¸¸ì–´ì§„ ê²ƒ ê°™ì•„ë„ ê°ì‚¬í•©ë‹ˆë‹¤.</p>\n<p>ê·¸ ê²°ê³¼ì— ë§Œì¡±í•˜ì‹œëŠ” ë¶„ë“¤ì´ë‚˜ ì½”ë“œë¥¼ ë” íƒêµ¬í•˜ê³  ì‹¶ì€ ë¶„ë“¤ê»˜ ì¢‹ì€ ì†Œì‹ì´ ìˆì–´ìš”!</p>\n<p>ì „ì²´ ì½”ë“œë² ì´ìŠ¤ ë° í”„ë¡œì íŠ¸ë¥¼ ì„¤ì •í•˜ëŠ” ë‹¨ê³„ë³„ ì§€ì¹¨ì„ ì°¾ì„ ìˆ˜ ìˆëŠ” GitHub ì €ì¥ì†Œë¥¼ ì†Œê°œí•©ë‹ˆë‹¤: <a href=\"https://github.com/luishsr/rust-nft-api\" rel=\"nofollow\" target=\"_blank\">https://github.com/luishsr/rust-nft-api</a>. ì–¸ì œë“ ì§€ ì°¸ì—¬í•´ë³´ì„¸ìš”. ì¦ê±°ìš´ ì½”ë”© ë˜ì„¸ìš”!</p>\n<h1>ğŸš€ Luis Soaresì˜ ë” ë§ì€ ì •ë³´ í™•ì¸í•˜ê¸°</h1>\n<p>ğŸ“š í•™ìŠµ í—ˆë¸Œ: ëŸ¬ìŠ¤íŠ¸, ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ, í´ë¼ìš°ë“œ ì»´í“¨íŒ…, ì‚¬ì´ë²„ ë³´ì•ˆ, ë¸”ë¡ì²´ì¸, ë¦¬ëˆ…ìŠ¤ ë“± ë‹¤ì–‘í•œ ê¸°ìˆ  ë¶„ì•¼ì—ì„œ ì§€ì‹ì„ í™•ì¥í•  ìˆ˜ ìˆëŠ” ê´‘ë²”ìœ„í•œ ìë£Œ ëª¨ìŒìœ¼ë¡œ ì§€ì‹ì„ í–¥ìƒí•´ë³´ì„¸ìš”:</p>\n<ul>\n<li>GitHub Reposì™€ í•¨ê»˜í•œ ì‹¤ì „ íŠœí† ë¦¬ì–¼: ë‹¨ê³„ë³„ íŠœí† ë¦¬ì–¼ë¡œ ë‹¤ì–‘í•œ ê¸°ìˆ ì— ëŒ€í•œ ì‹¤ìš©ì ì¸ ê¸°ìˆ ì„ ìŠµë“í•˜ê³  ì „ìš© GitHub ë¦¬í¬ì§€í† ë¦¬ë¥¼ ì´ìš©í•˜ì„¸ìš”. <a href=\"link\">íŠœí† ë¦¬ì–¼ í™•ì¸í•˜ê¸°</a></li>\n<li>ê¹Šì´ ìˆëŠ” ì•ˆë‚´ì„œ ë° ê¸°ì‚¬: Rust, ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ, í´ë¼ìš°ë“œ ì»´í“¨íŒ… ë“± í•µì‹¬ ê°œë…ì„ ìì„¸í•œ ì•ˆë‚´ì„œì™€ ì‹¤ìš©ì ì¸ ì˜ˆì‹œê°€ ê°€ë“í•œ ê¸°ì‚¬ë¡œ ê¹Šê²Œ ë“¤ì–´ê°€ ë³´ì„¸ìš”. <a href=\"link\">ë” ì½ê¸°</a></li>\n<li>E-Book ì»¬ë ‰ì…˜: \"Mastering Rust Ownership\"ì™€ \"Application Security Guide\"ì™€ ê°™ì€ ì œëª©ì˜ ë¬´ë£Œ E-Book ì‹œë¦¬ì¦ˆë¡œ ì—¬ëŸ¬ ê¸°ìˆ  ë¶„ì•¼ì— ëŒ€í•œ ì´í•´ë¥¼ ë†’ì´ì„¸ìš”. <a href=\"link\">E-Book ë‹¤ìš´ë¡œë“œ</a></li>\n<li>í”„ë¡œì íŠ¸ ì‡¼ì¼€ì´ìŠ¤: API ê²Œì´íŠ¸ì›¨ì´, ë¸”ë¡ì²´ì¸ ë„¤íŠ¸ì›Œí¬, ì‚¬ì´ë²„ ë³´ì•ˆ ë„êµ¬, í´ë¼ìš°ë“œ ì„œë¹„ìŠ¤ ë“± ë‹¤ì–‘í•œ ë„ë©”ì¸ì—ì„œ ì™„ì „íˆ ê¸°ëŠ¥í•˜ëŠ” í”„ë¡œì íŠ¸ë¥¼ ë°œê²¬í•˜ì„¸ìš”. <a href=\"link\">í”„ë¡œì íŠ¸ ë³´ê¸°</a></li>\n<li>LinkedIn ë‰´ìŠ¤ë ˆí„°: LinkedInì—ì„œ êµ¬ë…í•˜ë©´ Rust, ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ë° ì‹ ìƒ ê¸°ìˆ ì— ëŒ€í•œ ì •ê¸° ì—…ë°ì´íŠ¸ì™€ í†µì°°ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. <a href=\"link\">ì—¬ê¸°ì„œ êµ¬ë…í•˜ê¸°</a></li>\n</ul>\n<p>ğŸ”— ë‚˜ì™€ ì†Œí†µí•˜ê¸°:</p>\n<ul>\n<li>Medium: Mediumì—ì„œ ì œê°€ ì“´ ê¸°ì‚¬ë¥¼ ì½ê³  ë„ì›€ì´ ëë‹¤ë©´ clapsë¥¼ ì£¼ì„¸ìš”. ì œê²Œ ê¸€ì“°ê³  Rust ì½˜í…ì¸ ë¥¼ ê³„ì† ê³µìœ í•˜ê²Œ í•˜ëŠ” ì›ë™ë ¥ì´ ë©ë‹ˆë‹¤. <a href=\"link\">Medium íŒ”ë¡œìš°í•˜ê¸°</a></li>\n<li>ê°œì¸ ë¸”ë¡œê·¸: ì œ ê°œì¸ ë¸”ë¡œê·¸ì—ì„œ ë” ë§ì€ Rust ê´€ë ¨ ì½˜í…ì¸ ë¥¼ ì°¾ì•„ë³´ì„¸ìš”. <a href=\"link\">ë¸”ë¡œê·¸ ë°©ë¬¸í•˜ê¸°</a></li>\n<li>LinkedIn: ë” ë§ì€ í†µì°°ì„ ì–»ê¸° ìœ„í•´ ì „ë¬¸ ë„¤íŠ¸ì›Œí¬ì— ì°¸ì—¬í•˜ì„¸ìš”. <a href=\"link\">LinkedInì—ì„œ ì ‘ì†í•˜ê¸°</a></li>\n<li>Twitter: Rust í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ë¹ ë¥¸ ì—…ë°ì´íŠ¸ì™€ ìƒê°ì„ ë³´ë ¤ë©´ Twitterë¡œ íŒ”ë¡œìš°í•˜ì„¸ìš”. <a href=\"link\">Twitter íŒ”ë¡œìš°í•˜ê¸°</a></li>\n</ul>\n<p>ëŒ€í™”í•˜ê³  ì‹¶ìœ¼ì„¸ìš”? ëŒ“ê¸€ì„ ë‚¨ê¸°ê±°ë‚˜ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì£¼ì„¸ìš”!</p>\n<p>ëª¨ë‘ ì¢‹ì€ ì¼ ë˜ê¸¸ ë°”ë¼ë©°,</p>\n<p>Luis Soares<br>\n<a href=\"mailto:luis.soares@linux.com\">luis.soares@linux.com</a></p>\n<p>ì‹œë‹ˆì–´ ì†Œí”„íŠ¸ì›¨ì–´ ì—”ì§€ë‹ˆì–´ | í´ë¼ìš°ë“œ ì—”ì§€ë‹ˆì–´ | SRE | ê¸°ìˆ  ë¦¬ë“œ | Rust | Golang | Java | ML AI ë° í†µê³„ | Web3 &#x26; ë¸”ë¡ì²´ì¸</p>\n</body>\n</html>\n"},"__N_SSG":true}