<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>루스트로 블록체인 구현하기 | blocktong</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://blocktong.github.io///post/2024-05-05-ImplementingaBlockchaininRust" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="루스트로 블록체인 구현하기 | blocktong" data-gatsby-head="true"/><meta property="og:title" content="루스트로 블록체인 구현하기 | blocktong" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://blocktong.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://blocktong.github.io///post/2024-05-05-ImplementingaBlockchaininRust" data-gatsby-head="true"/><meta name="twitter:title" content="루스트로 블록체인 구현하기 | blocktong" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | blocktong" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-05 17:33" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-5b12619e815e966a.js" defer=""></script><script src="/_next/static/z0ZGRQY04MD5cUdT-Nqp1/_buildManifest.js" defer=""></script><script src="/_next/static/z0ZGRQY04MD5cUdT-Nqp1/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Block Tong</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">루스트로 블록체인 구현하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="루스트로 블록체인 구현하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Block Tong</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 5, 2024</span><span class="posts_reading_time__f7YPP">23<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-05-ImplementingaBlockchaininRust&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png" alt="Implementing a Blockchain in Rust"></p>
<p>안녕하세요! 이 기사는 Rust에서 기본적인 블록체인을 구현하는 단계별 방법을 제공합니다. 블록 구조의 초기 설정부터 시작하여 고유 식별자와 암호 해시를 포함하고, 블록 생성, 채굴, 그리고 유효성 검사로 그 기초를 마련합니다. 각 함수의 밑바탕과 그 이유를 설명하여 작업 증명, 논스 계산, 블록체인의 무결성과 연속성을 유지하는 메커니즘에 대한 통찰을 제공합니다.</p>
<p>참고: 이는 학습 목적을 위한 베어본과 기본 블록체인 구현이며 프로덕션 환경에는 사용하지 않는 것이 좋습니다! :)</p>
<p>자, 함께 Rustaceans 여러분, 바로 들어가 봅시다!</p>
<h1>기본 사항</h1>
<p>블록체인의 P2P 네트워크 상호작용 처리에서 핵심 개념과 주요 요소는 다음과 같습니다:</p>
<h2>노드와 피어 찾기</h2>
<ul>
<li>노드 식별: 블록체인 네트워크의 각 노드는 암호화 키 쌍에서 파생된 고유 식별자를 갖습니다.</li>
<li>피어 찾기: 노드는 네트워크를 형성하기 위해 서로를 발견해야 합니다. 미리 정의된 피어(정적 구성), DNS 기반 발견, 또는 로컬 네트워크 발견을 위해 mDNS와 같은 프로토콜을 사용하는 등, 다양한 방법으로 이를 달성할 수 있습니다.</li>
<li>부트스트랩 노드: 새로운 노드는 종종 신뢰할 수 있는 알려진 노드(부트스트랩 노드)에 연결하여 빠르게 네트워크에 통합됩니다.</li>
</ul>
<h2>네트워크 프로토콜</h2>
<ul>
<li>프로토콜 스택: 블록체인 P2P 네트워크는 특정 프로토콜 스택을 사용하여 통신합니다. 주로 사용되는 프로토콜로는 기본 전송을 위한 TCP/IP와 안전한 통신을 위한 암호 프로토콜(예: TLS 또는 Noise)이 있습니다.</li>
<li>메시징 프로토콜: Floodsub이나 Gossipsub과 같은 프로토콜은 메시지 방송 및 네트워크 전파를위해 사용됩니다.</li>
</ul>
<h2>데이터 전파 및 동기화</h2>
<ul>
<li>방송: 노드는 트랜잭션 및 새롭게 채굴된 블록을 네트워크로 방송하여 모든 참가자가 최신 데이터를 수신하도록합니다.</li>
<li>체인 동기화: 노드는 블록체인 복사본을 가장 긴 체인(일반적으로 유효한 것으로 인정됨)에 동기화하여 네트워크의 일관성을 유지합니다.</li>
<li>합의 메커니즘: 합의 알고리즘인 작업 증명(PoW) 또는 지분 증명(PoS) 등이 새로운 블록을 검증하고 추가하기위해 특히 블록체인의 상태에 대한 합의에 사용됩니다.</li>
</ul>
<p>이러한 핵심 개념을 이해했다면, 이제 코드로 넘어가 봅시다!</p>
<h1>cargo.toml — 다음 종속성을 추가하세요</h1>
<pre><code class="hljs language-toml"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">chrono</span> = <span class="hljs-string">"0.4"</span>
<span class="hljs-attr">sha2</span> = <span class="hljs-string">"0.9.8"</span>
<span class="hljs-attr">serde</span> = { version = <span class="hljs-string">"1.0"</span>, features = [<span class="hljs-string">"derive"</span>] }
<span class="hljs-attr">serde_json</span> = <span class="hljs-string">"1.0"</span>
<span class="hljs-attr">libp2p</span> = { version = <span class="hljs-string">"0.40.0"</span>, features = [<span class="hljs-string">"tcp-tokio"</span>, <span class="hljs-string">"mdns"</span>] }
<span class="hljs-attr">tokio</span> = { version = <span class="hljs-string">"1.0"</span>, features = [<span class="hljs-string">"io-util"</span>, <span class="hljs-string">"io-std"</span>, <span class="hljs-string">"macros"</span>, <span class="hljs-string">"rt"</span>, <span class="hljs-string">"rt-multi-thread"</span>, <span class="hljs-string">"sync"</span>, <span class="hljs-string">"time"</span>] }
<span class="hljs-attr">hex</span> = <span class="hljs-string">"0.4"</span>
<span class="hljs-attr">once_cell</span> = <span class="hljs-string">"1.5"</span>
<span class="hljs-attr">log</span> = <span class="hljs-string">"0.4"</span>
<span class="hljs-attr">pretty_env_logger</span> = <span class="hljs-string">"0.4"</span>
</code></pre>
<p>우리는 많은 시간을 잡아먹지 않도록 모든 라이브러리를 자세히 다루지 않겠습니다. 하지만 P2P 구현에 중요한 라이브러리로써 libp2p를 언급해 봅니다.</p>
<p>저는 libp2p에 대해 자세한 기사를 작성했습니다. 여기서 이 풍부한 Rust 크레이트에 익숙해질 수 있습니다.</p>
<h2>blockchain.rs — 이벤트 처리 및 P2P 통신</h2>
<p>우리가 이벤트 처리 및 p2p 방법을 구현할 'blockchain.rs'라는 새 파일을 만들어봅시다.</p>
<h3>기본 설정</h3>
<ul>
<li>KEYS, PEER_ID, CHAIN_TOPIC, BLOCK_TOPIC: 이러한 정적 변수는 신원을 위한 암호화 키, 네트워크 노드를 위한 피어 ID, 그리고 Floodsub 프로토콜을 사용하여 체인 및 블록 관련 메시지를 처리하기 위한 주제를 초기화합니다.</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> super::{App, Block};
<span class="hljs-keyword">use</span> libp2p::{
    floodsub::{Floodsub, FloodsubEvent, Topic},
    identity,
    mdns::{Mdns, MdnsEvent},
    swarm::{NetworkBehaviourEventProcess, Swarm},
    NetworkBehaviour, PeerId,
};
<span class="hljs-keyword">use</span> log::{error, info};
<span class="hljs-keyword">use</span> once_cell::sync::Lazy;
<span class="hljs-keyword">use</span> serde::{Deserialize, Serialize};
<span class="hljs-keyword">use</span> std::collections::HashSet;
<span class="hljs-keyword">use</span> tokio::sync::mpsc;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> KEYS: Lazy&#x3C;identity::Keypair> = Lazy::<span class="hljs-title function_ invoke__">new</span>(identity::Keypair::generate_ed25519);
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> PEER_ID: Lazy&#x3C;PeerId> = Lazy::<span class="hljs-title function_ invoke__">new</span>(|| PeerId::<span class="hljs-title function_ invoke__">from</span>(KEYS.<span class="hljs-title function_ invoke__">public</span>()));
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> CHAIN_TOPIC: Lazy&#x3C;Topic> = Lazy::<span class="hljs-title function_ invoke__">new</span>(|| Topic::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">"chains"</span>));
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> BLOCK_TOPIC: Lazy&#x3C;Topic> = Lazy::<span class="hljs-title function_ invoke__">new</span>(|| Topic::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">"blocks"</span>));
</code></pre>
<h1>이벤트 유형</h1>
<ul>
<li>ChainResponse, LocalChainRequest, EventType: 이러한 데이터 구조는 노드가 보내고 받을 수 있는 이벤트 및 메시지 유형을 정의합니다. ChainResponse 및 LocalChainRequest는 체인 요청에 응답하고 로컬 체인 상태를 요청하는 데 사용됩니다.</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[derive(Debug, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChainResponse</span> {
    <span class="hljs-keyword">pub</span> blocks: <span class="hljs-type">Vec</span>&#x3C;Block>,
    <span class="hljs-keyword">pub</span> receiver: <span class="hljs-type">String</span>,
}

<span class="hljs-meta">#[derive(Debug, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LocalChainRequest</span> {
    <span class="hljs-keyword">pub</span> from_peer_id: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">EventType</span> {
    <span class="hljs-title function_ invoke__">LocalChainResponse</span>(ChainResponse),
    <span class="hljs-title function_ invoke__">Input</span>(<span class="hljs-type">String</span>),
    Init,
}
</code></pre>
<h2>AppBehaviour</h2>
<ul>
<li>NetworkBehaviour Implementation (AppBehaviour): This struct implements the NetworkBehaviour trait, combining different behaviours like Floodsub (for pub/sub messaging) and mDNS (for local network peer discovery). It also holds channels for sending responses and initializing events and an instance of the App struct which contains the blockchain logic.</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[derive(NetworkBehaviour)]</span>
<span class="hljs-meta">#[behaviour(out_event=<span class="hljs-string">"Event"</span>)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppBehaviour</span> {
    <span class="hljs-keyword">pub</span> floodsub: Floodsub,
    <span class="hljs-keyword">pub</span> mdns: Mdns,
    <span class="hljs-meta">#[behaviour(ignore)]</span>
    <span class="hljs-keyword">pub</span> response_sender: mpsc::UnboundedSender&#x3C;ChainResponse>,
    <span class="hljs-meta">#[behaviour(ignore)]</span>
    <span class="hljs-keyword">pub</span> init_sender: mpsc::UnboundedSender&#x3C;<span class="hljs-type">bool</span>>,
    <span class="hljs-meta">#[behaviour(ignore)]</span>
    <span class="hljs-keyword">pub</span> app: App,
}

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Event</span> {
    <span class="hljs-title function_ invoke__">ChainResponse</span>(ChainResponse),
    <span class="hljs-title function_ invoke__">Floodsub</span>(FloodsubEvent),
    <span class="hljs-title function_ invoke__">Mdns</span>(MdnsEvent),
    <span class="hljs-title function_ invoke__">Input</span>(<span class="hljs-type">String</span>),
    Init,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&#x3C;FloodsubEvent> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Event</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(event: FloodsubEvent) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">Floodsub</span>(event)
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&#x3C;MdnsEvent> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Event</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(event: MdnsEvent) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">Mdns</span>(event)
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">AppBehaviour</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(
        app: App,
        response_sender: mpsc::UnboundedSender&#x3C;ChainResponse>,
        init_sender: mpsc::UnboundedSender&#x3C;<span class="hljs-type">bool</span>>,
    ) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">behaviour</span> = <span class="hljs-keyword">Self</span> {
            app,
            floodsub: Floodsub::<span class="hljs-title function_ invoke__">new</span>(*PEER_ID),
            mdns: Mdns::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">Default</span>::<span class="hljs-title function_ invoke__">default</span>())
                .<span class="hljs-keyword">await</span>
                .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can create mdns"</span>),
            response_sender,
            init_sender,
        };

        behaviour.floodsub.<span class="hljs-title function_ invoke__">subscribe</span>(CHAIN_TOPIC.<span class="hljs-title function_ invoke__">clone</span>());
        behaviour.floodsub.<span class="hljs-title function_ invoke__">subscribe</span>(BLOCK_TOPIC.<span class="hljs-title function_ invoke__">clone</span>());

        behaviour
    }
}
</code></pre>
<h1>이벤트 처리</h1>
<ul>
<li>FloodsubEvent 및 MdnsEvent를 위한 NetworkBehaviourEventProcess: 이러한 구현은 응용 프로그램이 다양한 네트워크 이벤트에 반응하는 방식을 정의합니다.</li>
<li>Floodsub 이벤트: 새 블록, 체인 응답 또는 로컬 체인 요청과 같은 블록체인 관련 메시지를 처리합니다. 예를 들어, 새 블록이 수신되면 try_add_block을 통해 블록체인에 추가됩니다.</li>
<li>mDNS 이벤트: 로컬 네트워크에서 새 피어의 발견 또는 기존 피어의 손실을 처리합니다. 이는 Floodsub 프로토콜에서 피어 목록을 업데이트합니다.</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-comment">// 수신 이벤트 핸들러</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">NetworkBehaviourEventProcess</span>&#x3C;FloodsubEvent> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppBehaviour</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">inject_event</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, event: FloodsubEvent) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">FloodsubEvent</span>::<span class="hljs-title function_ invoke__">Message</span>(msg) = event {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(resp) = serde_json::from_slice::&#x3C;ChainResponse>(&#x26;msg.data) {
                <span class="hljs-keyword">if</span> resp.receiver == PEER_ID.<span class="hljs-title function_ invoke__">to_string</span>() {
                    info!(<span class="hljs-string">"{}로부터 응답:"</span>, msg.source);
                    resp.blocks.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">for_each</span>(|r| info!(<span class="hljs-string">"{:?}"</span>, r));

                    <span class="hljs-keyword">self</span>.app.blocks = <span class="hljs-keyword">self</span>.app.<span class="hljs-title function_ invoke__">choose_chain</span>(<span class="hljs-keyword">self</span>.app.blocks.<span class="hljs-title function_ invoke__">clone</span>(), resp.blocks);
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(resp) = serde_json::from_slice::&#x3C;LocalChainRequest>(&#x26;msg.data) {
                info!(<span class="hljs-string">"{}로부터 로컬 체인 전송"</span>, msg.source.<span class="hljs-title function_ invoke__">to_string</span>());
                <span class="hljs-keyword">let</span> <span class="hljs-variable">peer_id</span> = resp.from_peer_id;
                <span class="hljs-keyword">if</span> PEER_ID.<span class="hljs-title function_ invoke__">to_string</span>() == peer_id {
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(e) = <span class="hljs-keyword">self</span>.response_sender.<span class="hljs-title function_ invoke__">send</span>(ChainResponse {
                        blocks: <span class="hljs-keyword">self</span>.app.blocks.<span class="hljs-title function_ invoke__">clone</span>(),
                        receiver: msg.source.<span class="hljs-title function_ invoke__">to_string</span>(),
                    }) {
                        error!(<span class="hljs-string">"채널을 통해 응답 전송 중 오류 발생, {}"</span>, e);
                    }
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(block) = serde_json::from_slice::&#x3C;Block>(&#x26;msg.data) {
                info!(<span class="hljs-string">"{}로부터 새 블록 수신"</span>, msg.source.<span class="hljs-title function_ invoke__">to_string</span>());
                <span class="hljs-keyword">self</span>.app.<span class="hljs-title function_ invoke__">try_add_block</span>(block);
            }
        }
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">NetworkBehaviourEventProcess</span>&#x3C;MdnsEvent> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppBehaviour</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">inject_event</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, event: MdnsEvent) {
        <span class="hljs-keyword">match</span> event {
            MdnsEvent::<span class="hljs-title function_ invoke__">Discovered</span>(discovered_list) => {
                <span class="hljs-title function_ invoke__">for</span> (peer, _addr) <span class="hljs-keyword">in</span> discovered_list {
                    <span class="hljs-keyword">self</span>.floodsub.<span class="hljs-title function_ invoke__">add_node_to_partial_view</span>(peer);
                }
            }
            MdnsEvent::<span class="hljs-title function_ invoke__">Expired</span>(expired_list) => {
                <span class="hljs-title function_ invoke__">for</span> (peer, _addr) <span class="hljs-keyword">in</span> expired_list {
                    <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.mdns.<span class="hljs-title function_ invoke__">has_node</span>(&#x26;peer) {
                        <span class="hljs-keyword">self</span>.floodsub.<span class="hljs-title function_ invoke__">remove_node_from_partial_view</span>(&#x26;peer);
                    }
                }
            }
        }
    }
}
</code></pre>
<h1>유틸리티 함수</h1>
<ul>
<li>get_list_peers: 네트워크에서 발견된 피어 목록을 반환합니다.</li>
<li>handle_print_peers: 콘솔에 피어 목록을 로깅합니다.</li>
<li>handle_print_chain: 로컬 블록체인 상태를 기록하며, 블록체인의 시각적 표현을 제공합니다.</li>
<li>handle_create_block: 사용자 입력을 처리하여 새 블록을 생성합니다. 제공된 데이터로 새 블록을 생성하고, 로컬 블록체인을 업데이트하고, Floodsub을 사용하여 새 블록을 피어에 브로드캐스트합니다.</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_list_peers</span>(swarm: &#x26;Swarm&#x3C;AppBehaviour>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Vec</span>&#x3C;<span class="hljs-type">String</span>> {
    info!(<span class="hljs-string">"발견된 피어:"</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">nodes</span> = swarm.<span class="hljs-title function_ invoke__">behaviour</span>().mdns.<span class="hljs-title function_ invoke__">discovered_nodes</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">unique_peers</span> = HashSet::<span class="hljs-title function_ invoke__">new</span>();
    <span class="hljs-keyword">for</span> <span class="hljs-variable">peer</span> <span class="hljs-keyword">in</span> nodes {
        unique_peers.<span class="hljs-title function_ invoke__">insert</span>(peer);
    }
    unique_peers.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|p| p.<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">collect</span>()
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_print_peers</span>(swarm: &#x26;Swarm&#x3C;AppBehaviour>) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">peers</span> = <span class="hljs-title function_ invoke__">get_list_peers</span>(swarm);
    peers.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">for_each</span>(|p| info!(<span class="hljs-string">"{}"</span>, p));
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_print_chain</span>(swarm: &#x26;Swarm&#x3C;AppBehaviour>) {
    info!(<span class="hljs-string">"로컬 블록체인:"</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">pretty_json</span> =
        serde_json::<span class="hljs-title function_ invoke__">to_string_pretty</span>(&#x26;swarm.<span class="hljs-title function_ invoke__">behaviour</span>().app.blocks).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can jsonify blocks"</span>);
    info!(<span class="hljs-string">"{}"</span>, pretty_json);
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_create_block</span>(cmd: &#x26;<span class="hljs-type">str</span>, swarm: &#x26;<span class="hljs-keyword">mut</span> Swarm&#x3C;AppBehaviour>) {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(data) = cmd.<span class="hljs-title function_ invoke__">strip_prefix</span>(<span class="hljs-string">"create b"</span>) {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">behaviour</span> = swarm.<span class="hljs-title function_ invoke__">behaviour_mut</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">latest_block</span> = behaviour
            .app
            .blocks
            .<span class="hljs-title function_ invoke__">last</span>()
            .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"적어도 하나의 블록이 있어야 함"</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">block</span> = Block::<span class="hljs-title function_ invoke__">new</span>(
            latest_block.id + <span class="hljs-number">1</span>,
            latest_block.hash.<span class="hljs-title function_ invoke__">clone</span>(),
            data.<span class="hljs-title function_ invoke__">to_owned</span>(),
        );
        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = serde_json::<span class="hljs-title function_ invoke__">to_string</span>(&#x26;block).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can jsonify request"</span>);
        behaviour.app.blocks.<span class="hljs-title function_ invoke__">push</span>(block);
        info!(<span class="hljs-string">"새 블록을 브로드캐스팅 중"</span>);
        behaviour
            .floodsub
            .<span class="hljs-title function_ invoke__">publish</span>(BLOCK_TOPIC.<span class="hljs-title function_ invoke__">clone</span>(), json.<span class="hljs-title function_ invoke__">as_bytes</span>());
    }
}
</code></pre>
<h1>main.rs — Main Loop 및 블록 채굴</h1>
<p>이제 'main.rs'라는 새 파일을 생성하여 메인 루프와 블록 채굴을 담당할 것입니다. 코어 로직은 아래와 같습니다:</p>
<h1>블록 구조</h1>
<p>블록 구조체는 블록체인 내의 블록 구조를 정의합니다. 이 구조에는 다음이 포함됩니다:</p>
<ul>
<li>id: 블록의 고유 식별자입니다.</li>
<li>hash: 블록의 해시입니다.</li>
<li>previous_hash: 체인 내 이전 블록의 해시입니다.</li>
<li>timestamp: 블록의 생성 시간입니다.</li>
<li>data: 블록의 데이터 또는 페이로드입니다.</li>
<li>nonce: 채굴 과정 중 사용되는 값입니다.</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::io::{Read, Write};
<span class="hljs-keyword">use</span> chrono::prelude::*;
<span class="hljs-keyword">use</span> libp2p::{
    core::upgrade,
    futures::StreamExt,
    mplex,
    noise::{Keypair, NoiseConfig, X25519Spec},
    swarm::{Swarm, SwarmBuilder},
    tcp::TokioTcpConfig,
    Transport,
};
<span class="hljs-keyword">use</span> log::{error, info, warn};
<span class="hljs-keyword">use</span> serde::{Deserialize, Serialize};
<span class="hljs-keyword">use</span> sha2::{Digest, Sha256};
<span class="hljs-keyword">use</span> std::time::Duration;
<span class="hljs-keyword">use</span> tokio::{
    io::{stdin, AsyncBufReadExt, BufReader},
    select, spawn,
    sync::mpsc,
    time::sleep,
};

<span class="hljs-keyword">const</span> DIFFICULTY_PREFIX: &#x26;<span class="hljs-type">str</span> = <span class="hljs-string">"00"</span>;

<span class="hljs-keyword">mod</span> blockchain;
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">App</span> {
    <span class="hljs-keyword">pub</span> blocks: <span class="hljs-type">Vec</span>&#x3C;Block>,
}

<span class="hljs-meta">#[derive(Serialize, Deserialize, Debug, Clone)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block</span> {
    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u64</span>,
    <span class="hljs-keyword">pub</span> hash: <span class="hljs-type">String</span>,
    <span class="hljs-keyword">pub</span> previous_hash: <span class="hljs-type">String</span>,
    <span class="hljs-keyword">pub</span> timestamp: <span class="hljs-type">i64</span>,
    <span class="hljs-keyword">pub</span> data: <span class="hljs-type">String</span>,
    <span class="hljs-keyword">pub</span> nonce: <span class="hljs-type">u64</span>,
}
</code></pre>
<h1>블록 생성 (새로운 기능)</h1>
<p>블록 구현 블록(DOM)에 있는 새로운 기능은 새 블록을 생성합니다. 이 기능은 mine_block 함수를 호출하여 블록의 해시와 논스를 생성합니다. 다른 속성들은 입력 값과 현재 시간을 기준으로 설정됩니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Block</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(id: <span class="hljs-type">u64</span>, previous_hash: <span class="hljs-type">String</span>, data: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Utc::<span class="hljs-title function_ invoke__">now</span>();
        <span class="hljs-keyword">let</span> (nonce, hash) = <span class="hljs-title function_ invoke__">mine_block</span>(id, now.<span class="hljs-title function_ invoke__">timestamp</span>(), &#x26;previous_hash, &#x26;data);
        <span class="hljs-keyword">Self</span> {
            id,
            hash,
            timestamp: now.<span class="hljs-title function_ invoke__">timestamp</span>(),
            previous_hash,
            data,
            nonce,
        }
    }
}
</code></pre>
<h1>해시 계산 (calculate_hash 함수)</h1>
<p><code>calculate_hash</code> 함수는 블록의 해시를 생성합니다. 이 함수는 블록의 속성을 JSON 객체로 만들고 이 데이터를 해시하기 위해 SHA-256 알고리즘을 사용합니다. 이 함수는 블록체인의 무결성을 보장하는 데 중요합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_hash</span>(id: <span class="hljs-type">u64</span>, timestamp: <span class="hljs-type">i64</span>, previous_hash: &#x26;<span class="hljs-type">str</span>, data: &#x26;<span class="hljs-type">str</span>, nonce: <span class="hljs-type">u64</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Vec</span>&#x3C;<span class="hljs-type">u8</span>> {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = serde_json::json!({
        <span class="hljs-string">"id"</span>: id,
        <span class="hljs-string">"previous_hash"</span>: previous_hash,
        <span class="hljs-string">"data"</span>: data,
        <span class="hljs-string">"timestamp"</span>: timestamp,
        <span class="hljs-string">"nonce"</span>: nonce
    });
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hasher</span> = Sha256::<span class="hljs-title function_ invoke__">new</span>();
    hasher.<span class="hljs-title function_ invoke__">update</span>(data.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">as_bytes</span>());
    hasher.<span class="hljs-title function_ invoke__">finalize</span>().<span class="hljs-title function_ invoke__">as_slice</span>().<span class="hljs-title function_ invoke__">to_owned</span>()
}
</code></pre>
<h2>채굴 (mine_block 함수)</h2>
<p><code>mine_block</code>은 작업 증명 알고리즘이 구현된 곳입니다. 이 함수는 nonce 값을 반복하여 특정 접두사(난이도 접두사로 정의됨)로 시작하는 해시를 찾으려고 시도합니다. 유효한 해시가 발견되면 함수는 nonce와 해당 해시를 반환합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">mine_block</span>(id: <span class="hljs-type">u64</span>, timestamp: <span class="hljs-type">i64</span>, previous_hash: &#x26;<span class="hljs-type">str</span>, data: &#x26;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-></span> (<span class="hljs-type">u64</span>, <span class="hljs-type">String</span>) {
    info!(<span class="hljs-string">"블록 채굴 중..."</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nonce</span> = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">if</span> nonce % <span class="hljs-number">100000</span> == <span class="hljs-number">0</span> {
            info!(<span class="hljs-string">"논스: {}"</span>, nonce);
        }
        <span class="hljs-keyword">let</span> <span class="hljs-variable">hash</span> = <span class="hljs-title function_ invoke__">calculate_hash</span>(id, timestamp, previous_hash, data, nonce);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">binary_hash</span> = <span class="hljs-title function_ invoke__">hash_to_binary_representation</span>(&#x26;hash);
        <span class="hljs-keyword">if</span> binary_hash.<span class="hljs-title function_ invoke__">starts_with</span>(DIFFICULTY_PREFIX) {
            info!(
                <span class="hljs-string">"채굴 성공! 논스: {}, 해시: {}, 이진 해시: {}"</span>,
                nonce,
                hex::<span class="hljs-title function_ invoke__">encode</span>(&#x26;hash),
                binary_hash
            );
            <span class="hljs-title function_ invoke__">return</span> (nonce, hex::<span class="hljs-title function_ invoke__">encode</span>(hash));
        }
        nonce += <span class="hljs-number">1</span>;
    }
}
</code></pre>
<h1>이진 해시 표현 (hash_to_binary_representation 함수)</h1>
<p>해시를 해당 이진 표현으로 변환하는 함수입니다. 이는 채굴 과정에서 해시가 난이도 조건을 충족하는지 확인하는 데 사용됩니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hash_to_binary_representation</span>(hash: &#x26;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-></span> <span class="hljs-type">String</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span>: <span class="hljs-type">String</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">default</span>();
    <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> hash {
        res.<span class="hljs-title function_ invoke__">push_str</span>(&#x26;<span class="hljs-built_in">format!</span>(<span class="hljs-string">"{:b}"</span>, c));
    }
    res
}
</code></pre>
<h1>제네시스 블록 (genesis 함수)</h1>
<p>이 함수는 블록체인에서 첫 번째 블록을 생성하는 함수로, 제네시스 블록이라고 알려져 있습니다. 이 블록은 수동으로 블록체인에 추가됩니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">App</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-></span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> { blocks: <span class="hljs-built_in">vec!</span>[] }
    }

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">genesis</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">genesis_block</span> = Block {
            id: <span class="hljs-number">0</span>,
            timestamp: Utc::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">timestamp</span>(),
            previous_hash: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"genesis"</span>),
            data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"genesis!"</span>),
            nonce: <span class="hljs-number">2836</span>,
            hash: <span class="hljs-string">"0000f816a87f806bb0073dcf026a64fb40c946b5abee2573702828694d5b4c43"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),
        };
        <span class="hljs-keyword">self</span>.blocks.<span class="hljs-title function_ invoke__">push</span>(genesis_block);
    }
</code></pre>
<h1>블록 추가하기 (try_add_block 함수)</h1>
<p><code>try_add_block</code> 함수는 블록체인에 새로운 블록을 추가하려고 시도합니다. 먼저, 새로운 블록을 최신 블록과 검증합니다. 새로운 블록이 유효하면 체인에 추가됩니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_add_block</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, block: Block) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">latest_block</span> = <span class="hljs-keyword">self</span>.blocks.<span class="hljs-title function_ invoke__">last</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"there is at least one block"</span>);
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_block_valid</span>(&#x26;block, latest_block) {
        <span class="hljs-keyword">self</span>.blocks.<span class="hljs-title function_ invoke__">push</span>(block);
    } <span class="hljs-keyword">else</span> {
        error!(<span class="hljs-string">"could not add block - invalid"</span>);
    }
}
</code></pre>
<h2>블록 유효성 검사 (is_block_valid 함수)</h2>
<p>이 함수는 이전 블록에 대해 블록을 유효성 검사합니다. 다음을 확인합니다:</p>
<ul>
<li>이전 해시 필드는 이전 블록의 해시와 일치합니다.</li>
<li>해시 난이도 수준이 올바릅니다.</li>
<li>블록 ID가 이전 블록의 ID를 따릅니다.</li>
<li>블록 해시가 유효합니다.</li>
</ul>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_block_valid</span>(&#x26;<span class="hljs-keyword">self</span>, block: &#x26;Block, previous_block: &#x26;Block) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> {
    <span class="hljs-keyword">if</span> block.previous_hash != previous_block.hash {
        warn!(<span class="hljs-string">"블록 ID가 {}인 블록은 잘못된 이전 해시를 가지고 있습니다."</span>, block.id);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">hash_to_binary_representation</span>(
        &#x26;hex::<span class="hljs-title function_ invoke__">decode</span>(&#x26;block.hash).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"16진수로 디코딩할 수 있어야 합니다."</span>),
    )
        .<span class="hljs-title function_ invoke__">starts_with</span>(DIFFICULTY_PREFIX)
    {
        warn!(<span class="hljs-string">"블록 ID가 {}인 블록은 유효하지 않은 난이도를 가지고 있습니다."</span>, block.id);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> block.id != previous_block.id + <span class="hljs-number">1</span> {
        warn!(
            <span class="hljs-string">"블록 ID가 {}인 블록은 최신 블록 이후의 다음 블록이 아닙니다: {}"</span>,
            block.id, previous_block.id
        );
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> hex::<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-title function_ invoke__">calculate_hash</span>(
        block.id,
        block.timestamp,
        &#x26;block.previous_hash,
        &#x26;block.data,
        block.nonce,
    )) != block.hash
    {
        warn!(<span class="hljs-string">"블록 ID가 {}인 블록은 유효하지 않은 해시를 가지고 있습니다."</span>, block.id);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-literal">true</span>
}
</code></pre>
<h1>체인 유효성 검사 (is_chain_valid 함수)</h1>
<p>is_chain_valid는 전체 블록 체인의 유효성을 검사합니다. 블록체인이 일관적이고 유효한 상태를 유지하는 데 사용됩니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_chain_valid</span>(&#x26;<span class="hljs-keyword">self</span>, chain: &#x26;[Block]) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..chain.<span class="hljs-title function_ invoke__">len</span>() {
        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = chain.<span class="hljs-title function_ invoke__">get</span>(i - <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"has to exist"</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = chain.<span class="hljs-title function_ invoke__">get</span>(i).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"has to exist"</span>);
        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_block_valid</span>(second, first) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-literal">true</span>
}
</code></pre>
<h1>체인 선택 (choose_chain 함수)</h1>
<p>이 함수는 블록체인의 여러 버전이 충돌하는 경우 해결하는 데 사용됩니다. 항상 가장 긴 유효한 체인을 선택합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-comment">// 항상 가장 긴 유효한 체인을 선택합니다</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">choose_chain</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, local: <span class="hljs-type">Vec</span>&#x3C;Block>, remote: <span class="hljs-type">Vec</span>&#x3C;Block>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Vec</span>&#x3C;Block> {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">is_local_valid</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_chain_valid</span>(&#x26;local);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">is_remote_valid</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_chain_valid</span>(&#x26;remote);

    <span class="hljs-keyword">if</span> is_local_valid &#x26;&#x26; is_remote_valid {
        <span class="hljs-keyword">if</span> local.<span class="hljs-title function_ invoke__">len</span>() >= remote.<span class="hljs-title function_ invoke__">len</span>() {
            local
        } <span class="hljs-keyword">else</span> {
            remote
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> is_remote_valid &#x26;&#x26; !is_local_valid {
        remote
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !is_remote_valid &#x26;&#x26; is_local_valid {
        local
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"로컬 및 원격 체인이 모두 유효하지 않습니다"</span>);
    }
}
</code></pre>
<h1>메인 기능 및 블록체인 네트워킹</h1>
<p>주요 기능은 블록체인 애플리케이션의 네트워킹 및 이벤트 처리 부분을 설정합니다. 토키오(tokio)와 립투피(libp2p) 라이브러리를 사용하여 피어 간 상호 작용을 관리하며, 체인 요청 및 사용자 입력 처리와 같은 이벤트에 응답합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[tokio::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    pretty_env_logger::<span class="hljs-title function_ invoke__">init</span>();

    info!(<span class="hljs-string">"Peer Id: {}"</span>, blockchain::PEER_ID.<span class="hljs-title function_ invoke__">clone</span>());
    <span class="hljs-keyword">let</span> (response_sender, <span class="hljs-keyword">mut</span> response_rcv) = mpsc::<span class="hljs-title function_ invoke__">unbounded_channel</span>();
    <span class="hljs-keyword">let</span> (init_sender, <span class="hljs-keyword">mut</span> init_rcv) = mpsc::<span class="hljs-title function_ invoke__">unbounded_channel</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">auth_keys</span> = Keypair::&#x3C;X25519Spec>::<span class="hljs-title function_ invoke__">new</span>()
        .<span class="hljs-title function_ invoke__">into_authentic</span>(&#x26;blockchain::KEYS)
        .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can create auth keys"</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-variable">transp</span> = TokioTcpConfig::<span class="hljs-title function_ invoke__">new</span>()
        .<span class="hljs-title function_ invoke__">upgrade</span>(upgrade::Version::V1)
        .<span class="hljs-title function_ invoke__">authenticate</span>(NoiseConfig::<span class="hljs-title function_ invoke__">xx</span>(auth_keys).<span class="hljs-title function_ invoke__">into_authenticated</span>())
        .<span class="hljs-title function_ invoke__">multiplex</span>(mplex::MplexConfig::<span class="hljs-title function_ invoke__">new</span>())
        .<span class="hljs-title function_ invoke__">boxed</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">behaviour</span> = blockchain::AppBehaviour::<span class="hljs-title function_ invoke__">new</span>(App::<span class="hljs-title function_ invoke__">new</span>(), response_sender, init_sender.<span class="hljs-title function_ invoke__">clone</span>()).<span class="hljs-keyword">await</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">swarm</span> = SwarmBuilder::<span class="hljs-title function_ invoke__">new</span>(transp, behaviour, *blockchain::PEER_ID)
        .<span class="hljs-title function_ invoke__">executor</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|fut| {
            <span class="hljs-title function_ invoke__">spawn</span>(fut);
        }))
        .<span class="hljs-title function_ invoke__">build</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stdin</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">stdin</span>()).<span class="hljs-title function_ invoke__">lines</span>();

    Swarm::<span class="hljs-title function_ invoke__">listen_on</span>(
        &#x26;<span class="hljs-keyword">mut</span> swarm,
        <span class="hljs-string">"/ip4/0.0.0.0/tcp/0"</span>
            .<span class="hljs-title function_ invoke__">parse</span>()
            .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can get a local socket"</span>),
    )
        .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"swarm can be started"</span>);

    <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
        <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>)).<span class="hljs-keyword">await</span>;
        info!(<span class="hljs-string">"sending init event"</span>);
        init_sender.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can send init event"</span>);
    });

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">evt</span> = {
            <span class="hljs-built_in">select!</span> {
                line = stdin.<span class="hljs-title function_ invoke__">next_line</span>() => <span class="hljs-title function_ invoke__">Some</span>(blockchain::EventType::<span class="hljs-title function_ invoke__">Input</span>(line.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can get line"</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can read line from stdin"</span>))),
                response = response_rcv.<span class="hljs-title function_ invoke__">recv</span>() => {
                    <span class="hljs-title function_ invoke__">Some</span>(blockchain::EventType::<span class="hljs-title function_ invoke__">LocalChainResponse</span>(response.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"response exists"</span>)))
                },
                _init = init_rcv.<span class="hljs-title function_ invoke__">recv</span>() => {
                    <span class="hljs-title function_ invoke__">Some</span>(blockchain::EventType::Init)
                }
                event = swarm.<span class="hljs-title function_ invoke__">select_next_some</span>() => {
                    info!(<span class="hljs-string">"Unhandled Swarm Event: {:?}"</span>, event);
                    <span class="hljs-literal">None</span>
                },
            }
        };

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(event) = evt {
            <span class="hljs-keyword">match</span> event {
                blockchain::EventType::Init => {
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">peers</span> = blockchain::<span class="hljs-title function_ invoke__">get_list_peers</span>(&#x26;swarm);
                    swarm.<span class="hljs-title function_ invoke__">behaviour_mut</span>().app.<span class="hljs-title function_ invoke__">genesis</span>();

                    info!(<span class="hljs-string">"connected nodes: {}"</span>, peers.<span class="hljs-title function_ invoke__">len</span>());
                    <span class="hljs-keyword">if</span> !peers.<span class="hljs-title function_ invoke__">is_empty</span>() {
                        <span class="hljs-keyword">let</span> <span class="hljs-variable">req</span> = blockchain::LocalChainRequest {
                            from_peer_id: peers
                                .<span class="hljs-title function_ invoke__">iter</span>()
                                .<span class="hljs-title function_ invoke__">last</span>()
                                .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"at least one peer"</span>)
                                .<span class="hljs-title function_ invoke__">to_string</span>(),
                        };

                        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = serde_json::<span class="hljs-title function_ invoke__">to_string</span>(&#x26;req).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can jsonify request"</span>);
                        swarm
                            .<span class="hljs-title function_ invoke__">behaviour_mut</span>()
                            .floodsub
                            .<span class="hljs-title function_ invoke__">publish</span>(blockchain::CHAIN_TOPIC.<span class="hljs-title function_ invoke__">clone</span>(), json.<span class="hljs-title function_ invoke__">as_bytes</span>());
                    }
                }
                blockchain::EventType::<span class="hljs-title function_ invoke__">LocalChainResponse</span>(resp) => {
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = serde_json::<span class="hljs-title function_ invoke__">to_string</span>(&#x26;resp).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"can jsonify response"</span>);
                    swarm
                        .<span class="hljs-title function_ invoke__">behaviour_mut</span>()
                        .floodsub
                        .<span class="hljs-title function_ invoke__">publish</span>(blockchain::CHAIN_TOPIC.<span class="hljs-title function_ invoke__">clone</span>(), json.<span class="hljs-title function_ invoke__">as_bytes</span>());
                }
                blockchain::EventType::<span class="hljs-title function_ invoke__">Input</span>(line) => <span class="hljs-keyword">match</span> line.<span class="hljs-title function_ invoke__">as_str</span>() {
                    <span class="hljs-string">"ls p"</span> => blockchain::<span class="hljs-title function_ invoke__">handle_print_peers</span>(&#x26;swarm),
                    cmd <span class="hljs-keyword">if</span> cmd.<span class="hljs-title function_ invoke__">starts_with</span>(<span class="hljs-string">"ls c"</span>) => blockchain::<span class="hljs-title function_ invoke__">handle_print_chain</span>(&#x26;swarm),
                    cmd <span class="hljs-keyword">if</span> cmd.<span class="hljs-title function_ invoke__">starts_with</span>(<span class="hljs-string">"create b"</span>) => blockchain::<span class="hljs-title function_ invoke__">handle_create_block</span>(cmd, &#x26;<span class="hljs-keyword">mut</span> swarm),
                    _ => error!(<span class="hljs-string">"unknown command"</span>),
                },
            }
        }
    }
}
</code></pre>
<p>와우, 이것 참 많이네요!</p>
<p>내 GitHub 저장소에서 완전한 구현을 찾을 수 있어요: <a href="https://github.com/luishsr/rustychain" rel="nofollow" target="_blank">루스티체인</a>.</p>
<h2>블록체인 테스트</h2>
<p>Rust로 제공된 블록체인 구현을 사용하고 테스트하려면 환경 설정, 노드 시작 및 상호 작용하는 일련의 단계를 따라야 해요. 시작하는 데 도움이 되는 빠른 가이드를 제공할게요:</p>
<h2>단일 노드 실행</h2>
<ul>
<li><strong>컴파일 및 실행</strong>: Rust 블록체인 코드가 있는 디렉토리로 이동한 후 cargo build를 사용하여 프로젝트를 컴파일합니다. 성공적인 컴파일이 완료되면 cargo run을 사용하여 노드를 실행합니다.</li>
<li><strong>초기 테스트</strong>: 처음에는 제네시스 블록이 올바르게 생성되고 노드가 제대로 시작되는지 확인하기 위해 단일 노드로 테스트합니다. 만약 구현되어 있다면 현재 체인이나 노드 상태를 표시하는 명령을 사용할 수 있습니다.</li>
</ul>
<h1>여러 노드 실행하기</h1>
<p>실제 블록체인 네트워크를 시뮬레이션하려면 여러 노드를 동시에 실행해야 합니다.</p>
<ul>
<li><strong>여러 터미널 열기</strong>: 여러 터미널 창 또는 탭을열어주세요. 각각은 네트워크에서 별개의 노드를 나타냅니다.</li>
<li><strong>독립적으로 노드 실행</strong>: 각 터미널에서 프로젝트 디렉토리로 이동하고 cargo run을 실행합니다. 각 인스턴스는 블록체인 네트워크의 별개 노드로 동작하게 됩니다.</li>
</ul>
<h1>노드와 상호작용하기</h1>
<p>블록체인의 기능을 테스트하려면 노드와 상호작용해야 합니다.</p>
<ul>
<li>새 블록 생성: 구현된 명령어(예: <code>data</code>를 이용한 <code>create b</code>)를 사용하여 새 블록을 생성하세요. 이는 블록체인에 거래나 데이터 추가를 시뮬레이션할 것입니다.</li>
<li>블록 전파: 한 노드에서 새 블록이 생성되면 이 블록을 다른 노드에 전파해야 합니다. 다른 노드가 이 새 블록을 수신하고 유효성을 검사하여 자신의 블록체인 버전에 추가하는지 확인하세요.</li>
<li>블록체인 상태 보기: 정기적으로 각 노드의 블록체인 현재 상태를 출력하는 명령어를 사용하세요. 노드 간에 일관성이 있어야하며 최신 유효 블록을 반영해야 합니다.</li>
<li>체인 충돌 테스트: 서로 다른 노드에서 동시에 다른 블록을 생성하여 체인 충돌을 시뮬레이트하세요. 구현이 이러한 충돌을 해결하는 방식(일반적으로 가장 긴 유효 체인을 선택함)을 관찰하세요.</li>
</ul>
<h1>🚀 루이스 소아레스에 의한 소프트웨어 개발 및 기타 다양한 리소스 탐색하기</h1>
<p>📚 학습 플랫폼: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅, 사이버 보안, 블록체인, 리눅스 등 다양한 기술 분야에서 지식을 넓히세요. 저의 포괄적인 자료 모음을 통해:</p>
<ul>
<li>GitHub 리포지토리와 함께 하는 실습 튜토리얼: 전용 GitHub 리포지토리를 통해 단계별 실습을 통해 다양한 기술을 실용적으로 익힐 수 있습니다. <a href="%EB%A7%81%ED%81%AC">튜토리얼 접근하기</a></li>
<li>심층 안내서 및 기사: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅 등의 핵심 개념을 자세히 다룬 안내서와 실제 예제가 풍부한 기사로 깊게 파보세요. <a href="%EB%A7%81%ED%81%AC">더 읽기</a></li>
<li>전자책 모음집: "러스트 소유권 마스터하기" 및 "애플리케이션 보안 안내서"와 같은 제목을 포함한 무료 전자책 시리즈로 다양한 기술 분야의 이해를 향상시키세요. <a href="%EB%A7%81%ED%81%AC">전자책 다운로드</a></li>
<li>프로젝트 쇼케이스: API 게이트웨이, 블록체인 네트워크, 사이버 보안 도구, 클라우드 서비스 등과 같이 다양한 분야의 완전 기능 프로젝트를 발견하세요. <a href="%EB%A7%81%ED%81%AC">프로젝트 보기</a></li>
<li>LinkedIn 뉴스레터: LinkedIn에서 제 뉴스레터를 구독하여 러스트, 소프트웨어 개발 및 신흥 기술에 관한 규칙적인 업데이트와 통찰력을 유지하세요. <a href="%EB%A7%81%ED%81%AC">여기서 구독하기</a></li>
</ul>
<p>🔗 저와 연결해보세요:</p>
<ul>
<li>Medium: 미디엄에서 제 글을 읽고 유용하다고 생각하면 박수를 보내주세요. 이는 저에게 글쓰기와 러스트 콘텐츠 공유를 계속 이끌어주는 원동력이 됩니다. <a href="%EB%A7%81%ED%81%AC">Medium 팔로우하기</a></li>
<li>개인 블로그: 제 개인 블로그에서 더 많은 러스트 관련 콘텐츠를 확인하세요. <a href="%EB%A7%81%ED%81%AC">블로그 방문하기</a></li>
<li>LinkedIn: 더 많은 통찰력 있는 토론과 업데이트를 위해 제 전문 네트워크에 참여하세요. <a href="%EB%A7%81%ED%81%AC">LinkedIn 연결하기</a></li>
<li>트위터: 빠른 업데이트와 러스트 프로그래밍에 대한 생각을 보려면 트위터에서 저를 팔로우하세요. <a href="%EB%A7%81%ED%81%AC">트위터에서 팔로우하기</a></li>
</ul>
<p>Wassup, folks? Feel free to leave a comment or shoot me a message!</p>
<p>Cheers,</p>
<p>Luis Soares
<a href="mailto:luis.soares@linux.com">luis.soares@linux.com</a></p>
<p>Senior Software Engineer | Cloud Engineer | SRE | Tech Lead | Rust | Golang | Java | ML AI &#x26; Statistics | Web3 &#x26; Blockchain</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"루스트로 블록체인 구현하기","description":"","date":"2024-05-05 17:33","slug":"2024-05-05-ImplementingaBlockchaininRust","content":"\n\n![Implementing a Blockchain in Rust](/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png)\n\n안녕하세요! 이 기사는 Rust에서 기본적인 블록체인을 구현하는 단계별 방법을 제공합니다. 블록 구조의 초기 설정부터 시작하여 고유 식별자와 암호 해시를 포함하고, 블록 생성, 채굴, 그리고 유효성 검사로 그 기초를 마련합니다. 각 함수의 밑바탕과 그 이유를 설명하여 작업 증명, 논스 계산, 블록체인의 무결성과 연속성을 유지하는 메커니즘에 대한 통찰을 제공합니다.\n\n참고: 이는 학습 목적을 위한 베어본과 기본 블록체인 구현이며 프로덕션 환경에는 사용하지 않는 것이 좋습니다! :)\n\n자, 함께 Rustaceans 여러분, 바로 들어가 봅시다!\n\n\n\n# 기본 사항\n\n블록체인의 P2P 네트워크 상호작용 처리에서 핵심 개념과 주요 요소는 다음과 같습니다:\n\n## 노드와 피어 찾기\n\n- 노드 식별: 블록체인 네트워크의 각 노드는 암호화 키 쌍에서 파생된 고유 식별자를 갖습니다.\n- 피어 찾기: 노드는 네트워크를 형성하기 위해 서로를 발견해야 합니다. 미리 정의된 피어(정적 구성), DNS 기반 발견, 또는 로컬 네트워크 발견을 위해 mDNS와 같은 프로토콜을 사용하는 등, 다양한 방법으로 이를 달성할 수 있습니다.\n- 부트스트랩 노드: 새로운 노드는 종종 신뢰할 수 있는 알려진 노드(부트스트랩 노드)에 연결하여 빠르게 네트워크에 통합됩니다.\n\n\n\n## 네트워크 프로토콜\n\n- 프로토콜 스택: 블록체인 P2P 네트워크는 특정 프로토콜 스택을 사용하여 통신합니다. 주로 사용되는 프로토콜로는 기본 전송을 위한 TCP/IP와 안전한 통신을 위한 암호 프로토콜(예: TLS 또는 Noise)이 있습니다.\n- 메시징 프로토콜: Floodsub이나 Gossipsub과 같은 프로토콜은 메시지 방송 및 네트워크 전파를위해 사용됩니다.\n\n## 데이터 전파 및 동기화\n\n- 방송: 노드는 트랜잭션 및 새롭게 채굴된 블록을 네트워크로 방송하여 모든 참가자가 최신 데이터를 수신하도록합니다.\n- 체인 동기화: 노드는 블록체인 복사본을 가장 긴 체인(일반적으로 유효한 것으로 인정됨)에 동기화하여 네트워크의 일관성을 유지합니다.\n- 합의 메커니즘: 합의 알고리즘인 작업 증명(PoW) 또는 지분 증명(PoS) 등이 새로운 블록을 검증하고 추가하기위해 특히 블록체인의 상태에 대한 합의에 사용됩니다.\n\n\n\n이러한 핵심 개념을 이해했다면, 이제 코드로 넘어가 봅시다!\n\n# cargo.toml — 다음 종속성을 추가하세요\n\n```toml\n[dependencies]\nchrono = \"0.4\"\nsha2 = \"0.9.8\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nlibp2p = { version = \"0.40.0\", features = [\"tcp-tokio\", \"mdns\"] }\ntokio = { version = \"1.0\", features = [\"io-util\", \"io-std\", \"macros\", \"rt\", \"rt-multi-thread\", \"sync\", \"time\"] }\nhex = \"0.4\"\nonce_cell = \"1.5\"\nlog = \"0.4\"\npretty_env_logger = \"0.4\"\n```\n\n우리는 많은 시간을 잡아먹지 않도록 모든 라이브러리를 자세히 다루지 않겠습니다. 하지만 P2P 구현에 중요한 라이브러리로써 libp2p를 언급해 봅니다.\n\n\n\n저는 libp2p에 대해 자세한 기사를 작성했습니다. 여기서 이 풍부한 Rust 크레이트에 익숙해질 수 있습니다.\n\n## blockchain.rs — 이벤트 처리 및 P2P 통신\n\n우리가 이벤트 처리 및 p2p 방법을 구현할 'blockchain.rs'라는 새 파일을 만들어봅시다.\n\n### 기본 설정\n\n\n\n- KEYS, PEER_ID, CHAIN_TOPIC, BLOCK_TOPIC: 이러한 정적 변수는 신원을 위한 암호화 키, 네트워크 노드를 위한 피어 ID, 그리고 Floodsub 프로토콜을 사용하여 체인 및 블록 관련 메시지를 처리하기 위한 주제를 초기화합니다.\n\n```rust\nuse super::{App, Block};\nuse libp2p::{\n    floodsub::{Floodsub, FloodsubEvent, Topic},\n    identity,\n    mdns::{Mdns, MdnsEvent},\n    swarm::{NetworkBehaviourEventProcess, Swarm},\n    NetworkBehaviour, PeerId,\n};\nuse log::{error, info};\nuse once_cell::sync::Lazy;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse tokio::sync::mpsc;\n\npub static KEYS: Lazy\u003cidentity::Keypair\u003e = Lazy::new(identity::Keypair::generate_ed25519);\npub static PEER_ID: Lazy\u003cPeerId\u003e = Lazy::new(|| PeerId::from(KEYS.public()));\npub static CHAIN_TOPIC: Lazy\u003cTopic\u003e = Lazy::new(|| Topic::new(\"chains\"));\npub static BLOCK_TOPIC: Lazy\u003cTopic\u003e = Lazy::new(|| Topic::new(\"blocks\"));\n```\n\n# 이벤트 유형\n\n- ChainResponse, LocalChainRequest, EventType: 이러한 데이터 구조는 노드가 보내고 받을 수 있는 이벤트 및 메시지 유형을 정의합니다. ChainResponse 및 LocalChainRequest는 체인 요청에 응답하고 로컬 체인 상태를 요청하는 데 사용됩니다.\n\n\n\n```rust\n#[derive(Debug, Serialize, Deserialize)]\npub struct ChainResponse {\n    pub blocks: Vec\u003cBlock\u003e,\n    pub receiver: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LocalChainRequest {\n    pub from_peer_id: String,\n}\n\npub enum EventType {\n    LocalChainResponse(ChainResponse),\n    Input(String),\n    Init,\n}\n```\n\n## AppBehaviour\n\n- NetworkBehaviour Implementation (AppBehaviour): This struct implements the NetworkBehaviour trait, combining different behaviours like Floodsub (for pub/sub messaging) and mDNS (for local network peer discovery). It also holds channels for sending responses and initializing events and an instance of the App struct which contains the blockchain logic.\n\n```rust\n#[derive(NetworkBehaviour)]\n#[behaviour(out_event=\"Event\")]\npub struct AppBehaviour {\n    pub floodsub: Floodsub,\n    pub mdns: Mdns,\n    #[behaviour(ignore)]\n    pub response_sender: mpsc::UnboundedSender\u003cChainResponse\u003e,\n    #[behaviour(ignore)]\n    pub init_sender: mpsc::UnboundedSender\u003cbool\u003e,\n    #[behaviour(ignore)]\n    pub app: App,\n}\n\n#[derive(Debug)]\npub enum Event {\n    ChainResponse(ChainResponse),\n    Floodsub(FloodsubEvent),\n    Mdns(MdnsEvent),\n    Input(String),\n    Init,\n}\n\nimpl From\u003cFloodsubEvent\u003e for Event {\n    fn from(event: FloodsubEvent) -\u003e Self {\n        Self::Floodsub(event)\n    }\n}\n\nimpl From\u003cMdnsEvent\u003e for Event {\n    fn from(event: MdnsEvent) -\u003e Self {\n        Self::Mdns(event)\n    }\n}\n\nimpl AppBehaviour {\n    pub async fn new(\n        app: App,\n        response_sender: mpsc::UnboundedSender\u003cChainResponse\u003e,\n        init_sender: mpsc::UnboundedSender\u003cbool\u003e,\n    ) -\u003e Self {\n        let mut behaviour = Self {\n            app,\n            floodsub: Floodsub::new(*PEER_ID),\n            mdns: Mdns::new(Default::default())\n                .await\n                .expect(\"can create mdns\"),\n            response_sender,\n            init_sender,\n        };\n\n        behaviour.floodsub.subscribe(CHAIN_TOPIC.clone());\n        behaviour.floodsub.subscribe(BLOCK_TOPIC.clone());\n\n        behaviour\n    }\n}\n```\n\n\n\n# 이벤트 처리\n\n- FloodsubEvent 및 MdnsEvent를 위한 NetworkBehaviourEventProcess: 이러한 구현은 응용 프로그램이 다양한 네트워크 이벤트에 반응하는 방식을 정의합니다.\n- Floodsub 이벤트: 새 블록, 체인 응답 또는 로컬 체인 요청과 같은 블록체인 관련 메시지를 처리합니다. 예를 들어, 새 블록이 수신되면 try_add_block을 통해 블록체인에 추가됩니다.\n- mDNS 이벤트: 로컬 네트워크에서 새 피어의 발견 또는 기존 피어의 손실을 처리합니다. 이는 Floodsub 프로토콜에서 피어 목록을 업데이트합니다.\n\n```rust\n// 수신 이벤트 핸들러\nimpl NetworkBehaviourEventProcess\u003cFloodsubEvent\u003e for AppBehaviour {\n    fn inject_event(\u0026mut self, event: FloodsubEvent) {\n        if let FloodsubEvent::Message(msg) = event {\n            if let Ok(resp) = serde_json::from_slice::\u003cChainResponse\u003e(\u0026msg.data) {\n                if resp.receiver == PEER_ID.to_string() {\n                    info!(\"{}로부터 응답:\", msg.source);\n                    resp.blocks.iter().for_each(|r| info!(\"{:?}\", r));\n\n                    self.app.blocks = self.app.choose_chain(self.app.blocks.clone(), resp.blocks);\n                }\n            } else if let Ok(resp) = serde_json::from_slice::\u003cLocalChainRequest\u003e(\u0026msg.data) {\n                info!(\"{}로부터 로컬 체인 전송\", msg.source.to_string());\n                let peer_id = resp.from_peer_id;\n                if PEER_ID.to_string() == peer_id {\n                    if let Err(e) = self.response_sender.send(ChainResponse {\n                        blocks: self.app.blocks.clone(),\n                        receiver: msg.source.to_string(),\n                    }) {\n                        error!(\"채널을 통해 응답 전송 중 오류 발생, {}\", e);\n                    }\n                }\n            } else if let Ok(block) = serde_json::from_slice::\u003cBlock\u003e(\u0026msg.data) {\n                info!(\"{}로부터 새 블록 수신\", msg.source.to_string());\n                self.app.try_add_block(block);\n            }\n        }\n    }\n}\n\nimpl NetworkBehaviourEventProcess\u003cMdnsEvent\u003e for AppBehaviour {\n    fn inject_event(\u0026mut self, event: MdnsEvent) {\n        match event {\n            MdnsEvent::Discovered(discovered_list) =\u003e {\n                for (peer, _addr) in discovered_list {\n                    self.floodsub.add_node_to_partial_view(peer);\n                }\n            }\n            MdnsEvent::Expired(expired_list) =\u003e {\n                for (peer, _addr) in expired_list {\n                    if !self.mdns.has_node(\u0026peer) {\n                        self.floodsub.remove_node_from_partial_view(\u0026peer);\n                    }\n                }\n            }\n        }\n    }\n}\r\n```\n\n# 유틸리티 함수\n\n\n\n- get_list_peers: 네트워크에서 발견된 피어 목록을 반환합니다.\n- handle_print_peers: 콘솔에 피어 목록을 로깅합니다.\n- handle_print_chain: 로컬 블록체인 상태를 기록하며, 블록체인의 시각적 표현을 제공합니다.\n- handle_create_block: 사용자 입력을 처리하여 새 블록을 생성합니다. 제공된 데이터로 새 블록을 생성하고, 로컬 블록체인을 업데이트하고, Floodsub을 사용하여 새 블록을 피어에 브로드캐스트합니다.\n\n```rust\npub fn get_list_peers(swarm: \u0026Swarm\u003cAppBehaviour\u003e) -\u003e Vec\u003cString\u003e {\n    info!(\"발견된 피어:\");\n    let nodes = swarm.behaviour().mdns.discovered_nodes();\n    let mut unique_peers = HashSet::new();\n    for peer in nodes {\n        unique_peers.insert(peer);\n    }\n    unique_peers.iter().map(|p| p.to_string()).collect()\n}\n\npub fn handle_print_peers(swarm: \u0026Swarm\u003cAppBehaviour\u003e) {\n    let peers = get_list_peers(swarm);\n    peers.iter().for_each(|p| info!(\"{}\", p));\n}\n\npub fn handle_print_chain(swarm: \u0026Swarm\u003cAppBehaviour\u003e) {\n    info!(\"로컬 블록체인:\");\n    let pretty_json =\n        serde_json::to_string_pretty(\u0026swarm.behaviour().app.blocks).expect(\"can jsonify blocks\");\n    info!(\"{}\", pretty_json);\n}\n\npub fn handle_create_block(cmd: \u0026str, swarm: \u0026mut Swarm\u003cAppBehaviour\u003e) {\n    if let Some(data) = cmd.strip_prefix(\"create b\") {\n        let behaviour = swarm.behaviour_mut();\n        let latest_block = behaviour\n            .app\n            .blocks\n            .last()\n            .expect(\"적어도 하나의 블록이 있어야 함\");\n        let block = Block::new(\n            latest_block.id + 1,\n            latest_block.hash.clone(),\n            data.to_owned(),\n        );\n        let json = serde_json::to_string(\u0026block).expect(\"can jsonify request\");\n        behaviour.app.blocks.push(block);\n        info!(\"새 블록을 브로드캐스팅 중\");\n        behaviour\n            .floodsub\n            .publish(BLOCK_TOPIC.clone(), json.as_bytes());\n    }\n}\n```\n\n# main.rs — Main Loop 및 블록 채굴\n\n이제 'main.rs'라는 새 파일을 생성하여 메인 루프와 블록 채굴을 담당할 것입니다. 코어 로직은 아래와 같습니다:\n\n\n\n# 블록 구조\n\n블록 구조체는 블록체인 내의 블록 구조를 정의합니다. 이 구조에는 다음이 포함됩니다:\n\n- id: 블록의 고유 식별자입니다.\n- hash: 블록의 해시입니다.\n- previous_hash: 체인 내 이전 블록의 해시입니다.\n- timestamp: 블록의 생성 시간입니다.\n- data: 블록의 데이터 또는 페이로드입니다.\n- nonce: 채굴 과정 중 사용되는 값입니다.\n\n```rust\nuse std::io::{Read, Write};\nuse chrono::prelude::*;\nuse libp2p::{\n    core::upgrade,\n    futures::StreamExt,\n    mplex,\n    noise::{Keypair, NoiseConfig, X25519Spec},\n    swarm::{Swarm, SwarmBuilder},\n    tcp::TokioTcpConfig,\n    Transport,\n};\nuse log::{error, info, warn};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse std::time::Duration;\nuse tokio::{\n    io::{stdin, AsyncBufReadExt, BufReader},\n    select, spawn,\n    sync::mpsc,\n    time::sleep,\n};\n\nconst DIFFICULTY_PREFIX: \u0026str = \"00\";\n\nmod blockchain;\npub struct App {\n    pub blocks: Vec\u003cBlock\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Block {\n    pub id: u64,\n    pub hash: String,\n    pub previous_hash: String,\n    pub timestamp: i64,\n    pub data: String,\n    pub nonce: u64,\n}\n```\n\n\n\n# 블록 생성 (새로운 기능)\n\n블록 구현 블록(DOM)에 있는 새로운 기능은 새 블록을 생성합니다. 이 기능은 mine_block 함수를 호출하여 블록의 해시와 논스를 생성합니다. 다른 속성들은 입력 값과 현재 시간을 기준으로 설정됩니다.\n\n```rust\nimpl Block {\n    pub fn new(id: u64, previous_hash: String, data: String) -\u003e Self {\n        let now = Utc::now();\n        let (nonce, hash) = mine_block(id, now.timestamp(), \u0026previous_hash, \u0026data);\n        Self {\n            id,\n            hash,\n            timestamp: now.timestamp(),\n            previous_hash,\n            data,\n            nonce,\n        }\n    }\n}\n```\n\n# 해시 계산 (calculate_hash 함수)\n\n\n\n`calculate_hash` 함수는 블록의 해시를 생성합니다. 이 함수는 블록의 속성을 JSON 객체로 만들고 이 데이터를 해시하기 위해 SHA-256 알고리즘을 사용합니다. 이 함수는 블록체인의 무결성을 보장하는 데 중요합니다.\n\n```rust\nfn calculate_hash(id: u64, timestamp: i64, previous_hash: \u0026str, data: \u0026str, nonce: u64) -\u003e Vec\u003cu8\u003e {\n    let data = serde_json::json!({\n        \"id\": id,\n        \"previous_hash\": previous_hash,\n        \"data\": data,\n        \"timestamp\": timestamp,\n        \"nonce\": nonce\n    });\n    let mut hasher = Sha256::new();\n    hasher.update(data.to_string().as_bytes());\n    hasher.finalize().as_slice().to_owned()\n}\n```\n\n## 채굴 (mine_block 함수)\n\n`mine_block`은 작업 증명 알고리즘이 구현된 곳입니다. 이 함수는 nonce 값을 반복하여 특정 접두사(난이도 접두사로 정의됨)로 시작하는 해시를 찾으려고 시도합니다. 유효한 해시가 발견되면 함수는 nonce와 해당 해시를 반환합니다.\n\n\n\n```rust\nfn mine_block(id: u64, timestamp: i64, previous_hash: \u0026str, data: \u0026str) -\u003e (u64, String) {\n    info!(\"블록 채굴 중...\");\n    let mut nonce = 0;\n\n    loop {\n        if nonce % 100000 == 0 {\n            info!(\"논스: {}\", nonce);\n        }\n        let hash = calculate_hash(id, timestamp, previous_hash, data, nonce);\n        let binary_hash = hash_to_binary_representation(\u0026hash);\n        if binary_hash.starts_with(DIFFICULTY_PREFIX) {\n            info!(\n                \"채굴 성공! 논스: {}, 해시: {}, 이진 해시: {}\",\n                nonce,\n                hex::encode(\u0026hash),\n                binary_hash\n            );\n            return (nonce, hex::encode(hash));\n        }\n        nonce += 1;\n    }\n}\n```\n\n# 이진 해시 표현 (hash_to_binary_representation 함수)\n\n해시를 해당 이진 표현으로 변환하는 함수입니다. 이는 채굴 과정에서 해시가 난이도 조건을 충족하는지 확인하는 데 사용됩니다.\n\n```rust\nfn hash_to_binary_representation(hash: \u0026[u8]) -\u003e String {\n    let mut res: String = String::default();\n    for c in hash {\n        res.push_str(\u0026format!(\"{:b}\", c));\n    }\n    res\n}\n```\n\n\n\n# 제네시스 블록 (genesis 함수)\n\n이 함수는 블록체인에서 첫 번째 블록을 생성하는 함수로, 제네시스 블록이라고 알려져 있습니다. 이 블록은 수동으로 블록체인에 추가됩니다.\n\n```rust\nimpl App {\n    fn new() -\u003e Self {\n        Self { blocks: vec![] }\n    }\n\n    fn genesis(\u0026mut self) {\n        let genesis_block = Block {\n            id: 0,\n            timestamp: Utc::now().timestamp(),\n            previous_hash: String::from(\"genesis\"),\n            data: String::from(\"genesis!\"),\n            nonce: 2836,\n            hash: \"0000f816a87f806bb0073dcf026a64fb40c946b5abee2573702828694d5b4c43\".to_string(),\n        };\n        self.blocks.push(genesis_block);\n    }\n```\n\n# 블록 추가하기 (try_add_block 함수)\n\n\n\n`try_add_block` 함수는 블록체인에 새로운 블록을 추가하려고 시도합니다. 먼저, 새로운 블록을 최신 블록과 검증합니다. 새로운 블록이 유효하면 체인에 추가됩니다.\n\n```rust\nfn try_add_block(\u0026mut self, block: Block) {\n    let latest_block = self.blocks.last().expect(\"there is at least one block\");\n    if self.is_block_valid(\u0026block, latest_block) {\n        self.blocks.push(block);\n    } else {\n        error!(\"could not add block - invalid\");\n    }\n}\n```\n\n## 블록 유효성 검사 (is_block_valid 함수)\n\n이 함수는 이전 블록에 대해 블록을 유효성 검사합니다. 다음을 확인합니다:\n\n\n\n- 이전 해시 필드는 이전 블록의 해시와 일치합니다.\n- 해시 난이도 수준이 올바릅니다.\n- 블록 ID가 이전 블록의 ID를 따릅니다.\n- 블록 해시가 유효합니다.\n\n```rust\nfn is_block_valid(\u0026self, block: \u0026Block, previous_block: \u0026Block) -\u003e bool {\n    if block.previous_hash != previous_block.hash {\n        warn!(\"블록 ID가 {}인 블록은 잘못된 이전 해시를 가지고 있습니다.\", block.id);\n        return false;\n    } else if !hash_to_binary_representation(\n        \u0026hex::decode(\u0026block.hash).expect(\"16진수로 디코딩할 수 있어야 합니다.\"),\n    )\n        .starts_with(DIFFICULTY_PREFIX)\n    {\n        warn!(\"블록 ID가 {}인 블록은 유효하지 않은 난이도를 가지고 있습니다.\", block.id);\n        return false;\n    } else if block.id != previous_block.id + 1 {\n        warn!(\n            \"블록 ID가 {}인 블록은 최신 블록 이후의 다음 블록이 아닙니다: {}\",\n            block.id, previous_block.id\n        );\n        return false;\n    } else if hex::encode(calculate_hash(\n        block.id,\n        block.timestamp,\n        \u0026block.previous_hash,\n        \u0026block.data,\n        block.nonce,\n    )) != block.hash\n    {\n        warn!(\"블록 ID가 {}인 블록은 유효하지 않은 해시를 가지고 있습니다.\", block.id);\n        return false;\n    }\n    true\n}\n```\n\n# 체인 유효성 검사 (is_chain_valid 함수)\n\nis_chain_valid는 전체 블록 체인의 유효성을 검사합니다. 블록체인이 일관적이고 유효한 상태를 유지하는 데 사용됩니다.\n\n\n\n```rust\nfn is_chain_valid(\u0026self, chain: \u0026[Block]) -\u003e bool {\n    for i in 0..chain.len() {\n        if i == 0 {\n            continue;\n        }\n        let first = chain.get(i - 1).expect(\"has to exist\");\n        let second = chain.get(i).expect(\"has to exist\");\n        if !self.is_block_valid(second, first) {\n            return false;\n        }\n    }\n    true\n}\n```\n\n# 체인 선택 (choose_chain 함수)\n\n이 함수는 블록체인의 여러 버전이 충돌하는 경우 해결하는 데 사용됩니다. 항상 가장 긴 유효한 체인을 선택합니다.\n\n```rust\n// 항상 가장 긴 유효한 체인을 선택합니다\nfn choose_chain(\u0026mut self, local: Vec\u003cBlock\u003e, remote: Vec\u003cBlock\u003e) -\u003e Vec\u003cBlock\u003e {\n    let is_local_valid = self.is_chain_valid(\u0026local);\n    let is_remote_valid = self.is_chain_valid(\u0026remote);\n\n    if is_local_valid \u0026\u0026 is_remote_valid {\n        if local.len() \u003e= remote.len() {\n            local\n        } else {\n            remote\n        }\n    } else if is_remote_valid \u0026\u0026 !is_local_valid {\n        remote\n    } else if !is_remote_valid \u0026\u0026 is_local_valid {\n        local\n    } else {\n        panic!(\"로컬 및 원격 체인이 모두 유효하지 않습니다\");\n    }\n}\n```\n\n\n\n# 메인 기능 및 블록체인 네트워킹\n\n주요 기능은 블록체인 애플리케이션의 네트워킹 및 이벤트 처리 부분을 설정합니다. 토키오(tokio)와 립투피(libp2p) 라이브러리를 사용하여 피어 간 상호 작용을 관리하며, 체인 요청 및 사용자 입력 처리와 같은 이벤트에 응답합니다.\n\n```rust\n#[tokio::main]\nasync fn main() {\n    pretty_env_logger::init();\n\n    info!(\"Peer Id: {}\", blockchain::PEER_ID.clone());\n    let (response_sender, mut response_rcv) = mpsc::unbounded_channel();\n    let (init_sender, mut init_rcv) = mpsc::unbounded_channel();\n\n    let auth_keys = Keypair::\u003cX25519Spec\u003e::new()\n        .into_authentic(\u0026blockchain::KEYS)\n        .expect(\"can create auth keys\");\n\n    let transp = TokioTcpConfig::new()\n        .upgrade(upgrade::Version::V1)\n        .authenticate(NoiseConfig::xx(auth_keys).into_authenticated())\n        .multiplex(mplex::MplexConfig::new())\n        .boxed();\n\n    let behaviour = blockchain::AppBehaviour::new(App::new(), response_sender, init_sender.clone()).await;\n\n    let mut swarm = SwarmBuilder::new(transp, behaviour, *blockchain::PEER_ID)\n        .executor(Box::new(|fut| {\n            spawn(fut);\n        }))\n        .build();\n\n    let mut stdin = BufReader::new(stdin()).lines();\n\n    Swarm::listen_on(\n        \u0026mut swarm,\n        \"/ip4/0.0.0.0/tcp/0\"\n            .parse()\n            .expect(\"can get a local socket\"),\n    )\n        .expect(\"swarm can be started\");\n\n    spawn(async move {\n        sleep(Duration::from_secs(1)).await;\n        info!(\"sending init event\");\n        init_sender.send(true).expect(\"can send init event\");\n    });\n\n    loop {\n        let evt = {\n            select! {\n                line = stdin.next_line() =\u003e Some(blockchain::EventType::Input(line.expect(\"can get line\").expect(\"can read line from stdin\"))),\n                response = response_rcv.recv() =\u003e {\n                    Some(blockchain::EventType::LocalChainResponse(response.expect(\"response exists\")))\n                },\n                _init = init_rcv.recv() =\u003e {\n                    Some(blockchain::EventType::Init)\n                }\n                event = swarm.select_next_some() =\u003e {\n                    info!(\"Unhandled Swarm Event: {:?}\", event);\n                    None\n                },\n            }\n        };\n\n        if let Some(event) = evt {\n            match event {\n                blockchain::EventType::Init =\u003e {\n                    let peers = blockchain::get_list_peers(\u0026swarm);\n                    swarm.behaviour_mut().app.genesis();\n\n                    info!(\"connected nodes: {}\", peers.len());\n                    if !peers.is_empty() {\n                        let req = blockchain::LocalChainRequest {\n                            from_peer_id: peers\n                                .iter()\n                                .last()\n                                .expect(\"at least one peer\")\n                                .to_string(),\n                        };\n\n                        let json = serde_json::to_string(\u0026req).expect(\"can jsonify request\");\n                        swarm\n                            .behaviour_mut()\n                            .floodsub\n                            .publish(blockchain::CHAIN_TOPIC.clone(), json.as_bytes());\n                    }\n                }\n                blockchain::EventType::LocalChainResponse(resp) =\u003e {\n                    let json = serde_json::to_string(\u0026resp).expect(\"can jsonify response\");\n                    swarm\n                        .behaviour_mut()\n                        .floodsub\n                        .publish(blockchain::CHAIN_TOPIC.clone(), json.as_bytes());\n                }\n                blockchain::EventType::Input(line) =\u003e match line.as_str() {\n                    \"ls p\" =\u003e blockchain::handle_print_peers(\u0026swarm),\n                    cmd if cmd.starts_with(\"ls c\") =\u003e blockchain::handle_print_chain(\u0026swarm),\n                    cmd if cmd.starts_with(\"create b\") =\u003e blockchain::handle_create_block(cmd, \u0026mut swarm),\n                    _ =\u003e error!(\"unknown command\"),\n                },\n            }\n        }\n    }\n}\n```\n\n와우, 이것 참 많이네요!\n\n\n\n내 GitHub 저장소에서 완전한 구현을 찾을 수 있어요: [루스티체인](https://github.com/luishsr/rustychain).\n\n## 블록체인 테스트\n\nRust로 제공된 블록체인 구현을 사용하고 테스트하려면 환경 설정, 노드 시작 및 상호 작용하는 일련의 단계를 따라야 해요. 시작하는 데 도움이 되는 빠른 가이드를 제공할게요:\n\n## 단일 노드 실행\n\n\n\n- **컴파일 및 실행**: Rust 블록체인 코드가 있는 디렉토리로 이동한 후 cargo build를 사용하여 프로젝트를 컴파일합니다. 성공적인 컴파일이 완료되면 cargo run을 사용하여 노드를 실행합니다.\n- **초기 테스트**: 처음에는 제네시스 블록이 올바르게 생성되고 노드가 제대로 시작되는지 확인하기 위해 단일 노드로 테스트합니다. 만약 구현되어 있다면 현재 체인이나 노드 상태를 표시하는 명령을 사용할 수 있습니다.\n\n# 여러 노드 실행하기\n\n실제 블록체인 네트워크를 시뮬레이션하려면 여러 노드를 동시에 실행해야 합니다.\n\n- **여러 터미널 열기**: 여러 터미널 창 또는 탭을열어주세요. 각각은 네트워크에서 별개의 노드를 나타냅니다.\n- **독립적으로 노드 실행**: 각 터미널에서 프로젝트 디렉토리로 이동하고 cargo run을 실행합니다. 각 인스턴스는 블록체인 네트워크의 별개 노드로 동작하게 됩니다.\n\n\n\n# 노드와 상호작용하기\n\n블록체인의 기능을 테스트하려면 노드와 상호작용해야 합니다.\n\n- 새 블록 생성: 구현된 명령어(예: `data`를 이용한 `create b`)를 사용하여 새 블록을 생성하세요. 이는 블록체인에 거래나 데이터 추가를 시뮬레이션할 것입니다.\n- 블록 전파: 한 노드에서 새 블록이 생성되면 이 블록을 다른 노드에 전파해야 합니다. 다른 노드가 이 새 블록을 수신하고 유효성을 검사하여 자신의 블록체인 버전에 추가하는지 확인하세요.\n- 블록체인 상태 보기: 정기적으로 각 노드의 블록체인 현재 상태를 출력하는 명령어를 사용하세요. 노드 간에 일관성이 있어야하며 최신 유효 블록을 반영해야 합니다.\n- 체인 충돌 테스트: 서로 다른 노드에서 동시에 다른 블록을 생성하여 체인 충돌을 시뮬레이트하세요. 구현이 이러한 충돌을 해결하는 방식(일반적으로 가장 긴 유효 체인을 선택함)을 관찰하세요.\n\n# 🚀 루이스 소아레스에 의한 소프트웨어 개발 및 기타 다양한 리소스 탐색하기\n\n\n\n📚 학습 플랫폼: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅, 사이버 보안, 블록체인, 리눅스 등 다양한 기술 분야에서 지식을 넓히세요. 저의 포괄적인 자료 모음을 통해:\n\n- GitHub 리포지토리와 함께 하는 실습 튜토리얼: 전용 GitHub 리포지토리를 통해 단계별 실습을 통해 다양한 기술을 실용적으로 익힐 수 있습니다. [튜토리얼 접근하기](링크)\n- 심층 안내서 및 기사: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅 등의 핵심 개념을 자세히 다룬 안내서와 실제 예제가 풍부한 기사로 깊게 파보세요. [더 읽기](링크)\n- 전자책 모음집: \"러스트 소유권 마스터하기\" 및 \"애플리케이션 보안 안내서\"와 같은 제목을 포함한 무료 전자책 시리즈로 다양한 기술 분야의 이해를 향상시키세요. [전자책 다운로드](링크)\n- 프로젝트 쇼케이스: API 게이트웨이, 블록체인 네트워크, 사이버 보안 도구, 클라우드 서비스 등과 같이 다양한 분야의 완전 기능 프로젝트를 발견하세요. [프로젝트 보기](링크)\n- LinkedIn 뉴스레터: LinkedIn에서 제 뉴스레터를 구독하여 러스트, 소프트웨어 개발 및 신흥 기술에 관한 규칙적인 업데이트와 통찰력을 유지하세요. [여기서 구독하기](링크)\n\n🔗 저와 연결해보세요:\n\n- Medium: 미디엄에서 제 글을 읽고 유용하다고 생각하면 박수를 보내주세요. 이는 저에게 글쓰기와 러스트 콘텐츠 공유를 계속 이끌어주는 원동력이 됩니다. [Medium 팔로우하기](링크)\n- 개인 블로그: 제 개인 블로그에서 더 많은 러스트 관련 콘텐츠를 확인하세요. [블로그 방문하기](링크)\n- LinkedIn: 더 많은 통찰력 있는 토론과 업데이트를 위해 제 전문 네트워크에 참여하세요. [LinkedIn 연결하기](링크)\n- 트위터: 빠른 업데이트와 러스트 프로그래밍에 대한 생각을 보려면 트위터에서 저를 팔로우하세요. [트위터에서 팔로우하기](링크)\n\n\n\nWassup, folks? Feel free to leave a comment or shoot me a message!\n\nCheers,\n\nLuis Soares\n[luis.soares@linux.com](mailto:luis.soares@linux.com)\n\nSenior Software Engineer | Cloud Engineer | SRE | Tech Lead | Rust | Golang | Java | ML AI \u0026 Statistics | Web3 \u0026 Blockchain","ogImage":{"url":"/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png"},"coverImage":"/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png","tag":["Tech"],"readingTime":23},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png\" alt=\"Implementing a Blockchain in Rust\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요! 이 기사는 Rust에서 기본적인 블록체인을 구현하는 단계별 방법을 제공합니다. 블록 구조의 초기 설정부터 시작하여 고유 식별자와 암호 해시를 포함하고, 블록 생성, 채굴, 그리고 유효성 검사로 그 기초를 마련합니다. 각 함수의 밑바탕과 그 이유를 설명하여 작업 증명, 논스 계산, 블록체인의 무결성과 연속성을 유지하는 메커니즘에 대한 통찰을 제공합니다.\u003c/p\u003e\n\u003cp\u003e참고: 이는 학습 목적을 위한 베어본과 기본 블록체인 구현이며 프로덕션 환경에는 사용하지 않는 것이 좋습니다! :)\u003c/p\u003e\n\u003cp\u003e자, 함께 Rustaceans 여러분, 바로 들어가 봅시다!\u003c/p\u003e\n\u003ch1\u003e기본 사항\u003c/h1\u003e\n\u003cp\u003e블록체인의 P2P 네트워크 상호작용 처리에서 핵심 개념과 주요 요소는 다음과 같습니다:\u003c/p\u003e\n\u003ch2\u003e노드와 피어 찾기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e노드 식별: 블록체인 네트워크의 각 노드는 암호화 키 쌍에서 파생된 고유 식별자를 갖습니다.\u003c/li\u003e\n\u003cli\u003e피어 찾기: 노드는 네트워크를 형성하기 위해 서로를 발견해야 합니다. 미리 정의된 피어(정적 구성), DNS 기반 발견, 또는 로컬 네트워크 발견을 위해 mDNS와 같은 프로토콜을 사용하는 등, 다양한 방법으로 이를 달성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e부트스트랩 노드: 새로운 노드는 종종 신뢰할 수 있는 알려진 노드(부트스트랩 노드)에 연결하여 빠르게 네트워크에 통합됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e네트워크 프로토콜\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e프로토콜 스택: 블록체인 P2P 네트워크는 특정 프로토콜 스택을 사용하여 통신합니다. 주로 사용되는 프로토콜로는 기본 전송을 위한 TCP/IP와 안전한 통신을 위한 암호 프로토콜(예: TLS 또는 Noise)이 있습니다.\u003c/li\u003e\n\u003cli\u003e메시징 프로토콜: Floodsub이나 Gossipsub과 같은 프로토콜은 메시지 방송 및 네트워크 전파를위해 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e데이터 전파 및 동기화\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e방송: 노드는 트랜잭션 및 새롭게 채굴된 블록을 네트워크로 방송하여 모든 참가자가 최신 데이터를 수신하도록합니다.\u003c/li\u003e\n\u003cli\u003e체인 동기화: 노드는 블록체인 복사본을 가장 긴 체인(일반적으로 유효한 것으로 인정됨)에 동기화하여 네트워크의 일관성을 유지합니다.\u003c/li\u003e\n\u003cli\u003e합의 메커니즘: 합의 알고리즘인 작업 증명(PoW) 또는 지분 증명(PoS) 등이 새로운 블록을 검증하고 추가하기위해 특히 블록체인의 상태에 대한 합의에 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 핵심 개념을 이해했다면, 이제 코드로 넘어가 봅시다!\u003c/p\u003e\n\u003ch1\u003ecargo.toml — 다음 종속성을 추가하세요\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-toml\"\u003e\u003cspan class=\"hljs-section\"\u003e[dependencies]\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003echrono\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.4\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003esha2\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.9.8\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eserde\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"1.0\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"derive\"\u003c/span\u003e] }\n\u003cspan class=\"hljs-attr\"\u003eserde_json\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"1.0\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003elibp2p\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"0.40.0\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"tcp-tokio\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"mdns\"\u003c/span\u003e] }\n\u003cspan class=\"hljs-attr\"\u003etokio\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"1.0\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"io-util\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"io-std\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"macros\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"rt\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"rt-multi-thread\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"sync\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"time\"\u003c/span\u003e] }\n\u003cspan class=\"hljs-attr\"\u003ehex\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.4\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eonce_cell\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"1.5\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003elog\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.4\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003epretty_env_logger\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.4\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 많은 시간을 잡아먹지 않도록 모든 라이브러리를 자세히 다루지 않겠습니다. 하지만 P2P 구현에 중요한 라이브러리로써 libp2p를 언급해 봅니다.\u003c/p\u003e\n\u003cp\u003e저는 libp2p에 대해 자세한 기사를 작성했습니다. 여기서 이 풍부한 Rust 크레이트에 익숙해질 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eblockchain.rs — 이벤트 처리 및 P2P 통신\u003c/h2\u003e\n\u003cp\u003e우리가 이벤트 처리 및 p2p 방법을 구현할 'blockchain.rs'라는 새 파일을 만들어봅시다.\u003c/p\u003e\n\u003ch3\u003e기본 설정\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKEYS, PEER_ID, CHAIN_TOPIC, BLOCK_TOPIC: 이러한 정적 변수는 신원을 위한 암호화 키, 네트워크 노드를 위한 피어 ID, 그리고 Floodsub 프로토콜을 사용하여 체인 및 블록 관련 메시지를 처리하기 위한 주제를 초기화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e super::{App, Block};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e libp2p::{\n    floodsub::{Floodsub, FloodsubEvent, Topic},\n    identity,\n    mdns::{Mdns, MdnsEvent},\n    swarm::{NetworkBehaviourEventProcess, Swarm},\n    NetworkBehaviour, PeerId,\n};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e log::{error, info};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e once_cell::sync::Lazy;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e serde::{Deserialize, Serialize};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::collections::HashSet;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e tokio::sync::mpsc;\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e KEYS: Lazy\u0026#x3C;identity::Keypair\u003e = Lazy::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(identity::Keypair::generate_ed25519);\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e PEER_ID: Lazy\u0026#x3C;PeerId\u003e = Lazy::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(|| PeerId::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(KEYS.\u003cspan class=\"hljs-title function_ invoke__\"\u003epublic\u003c/span\u003e()));\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e CHAIN_TOPIC: Lazy\u0026#x3C;Topic\u003e = Lazy::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(|| Topic::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"chains\"\u003c/span\u003e));\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e BLOCK_TOPIC: Lazy\u0026#x3C;Topic\u003e = Lazy::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(|| Topic::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"blocks\"\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e이벤트 유형\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eChainResponse, LocalChainRequest, EventType: 이러한 데이터 구조는 노드가 보내고 받을 수 있는 이벤트 및 메시지 유형을 정의합니다. ChainResponse 및 LocalChainRequest는 체인 요청에 응답하고 로컬 체인 상태를 요청하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[derive(Debug, Serialize, Deserialize)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChainResponse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e blocks: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Block\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e receiver: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(Debug, Serialize, Deserialize)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLocalChainRequest\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e from_peer_id: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventType\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eLocalChainResponse\u003c/span\u003e(ChainResponse),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eInput\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e),\n    Init,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAppBehaviour\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eNetworkBehaviour Implementation (AppBehaviour): This struct implements the NetworkBehaviour trait, combining different behaviours like Floodsub (for pub/sub messaging) and mDNS (for local network peer discovery). It also holds channels for sending responses and initializing events and an instance of the App struct which contains the blockchain logic.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[derive(NetworkBehaviour)]\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#[behaviour(out_event=\u003cspan class=\"hljs-string\"\u003e\"Event\"\u003c/span\u003e)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppBehaviour\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e floodsub: Floodsub,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e mdns: Mdns,\n    \u003cspan class=\"hljs-meta\"\u003e#[behaviour(ignore)]\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e response_sender: mpsc::UnboundedSender\u0026#x3C;ChainResponse\u003e,\n    \u003cspan class=\"hljs-meta\"\u003e#[behaviour(ignore)]\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e init_sender: mpsc::UnboundedSender\u0026#x3C;\u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e\u003e,\n    \u003cspan class=\"hljs-meta\"\u003e#[behaviour(ignore)]\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e app: App,\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(Debug)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEvent\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eChainResponse\u003c/span\u003e(ChainResponse),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eFloodsub\u003c/span\u003e(FloodsubEvent),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eMdns\u003c/span\u003e(MdnsEvent),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eInput\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e),\n    Init,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFrom\u003c/span\u003e\u0026#x3C;FloodsubEvent\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEvent\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(event: FloodsubEvent) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003eFloodsub\u003c/span\u003e(event)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFrom\u003c/span\u003e\u0026#x3C;MdnsEvent\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEvent\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(event: MdnsEvent) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003eMdns\u003c/span\u003e(event)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppBehaviour\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\n        app: App,\n        response_sender: mpsc::UnboundedSender\u0026#x3C;ChainResponse\u003e,\n        init_sender: mpsc::UnboundedSender\u0026#x3C;\u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e\u003e,\n    ) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ebehaviour\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e {\n            app,\n            floodsub: Floodsub::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(*PEER_ID),\n            mdns: Mdns::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eDefault\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003edefault\u003c/span\u003e())\n                .\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e\n                .\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can create mdns\"\u003c/span\u003e),\n            response_sender,\n            init_sender,\n        };\n\n        behaviour.floodsub.\u003cspan class=\"hljs-title function_ invoke__\"\u003esubscribe\u003c/span\u003e(CHAIN_TOPIC.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e());\n        behaviour.floodsub.\u003cspan class=\"hljs-title function_ invoke__\"\u003esubscribe\u003c/span\u003e(BLOCK_TOPIC.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e());\n\n        behaviour\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e이벤트 처리\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eFloodsubEvent 및 MdnsEvent를 위한 NetworkBehaviourEventProcess: 이러한 구현은 응용 프로그램이 다양한 네트워크 이벤트에 반응하는 방식을 정의합니다.\u003c/li\u003e\n\u003cli\u003eFloodsub 이벤트: 새 블록, 체인 응답 또는 로컬 체인 요청과 같은 블록체인 관련 메시지를 처리합니다. 예를 들어, 새 블록이 수신되면 try_add_block을 통해 블록체인에 추가됩니다.\u003c/li\u003e\n\u003cli\u003emDNS 이벤트: 로컬 네트워크에서 새 피어의 발견 또는 기존 피어의 손실을 처리합니다. 이는 Floodsub 프로토콜에서 피어 목록을 업데이트합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 수신 이벤트 핸들러\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkBehaviourEventProcess\u003c/span\u003e\u0026#x3C;FloodsubEvent\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppBehaviour\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einject_event\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, event: FloodsubEvent) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eFloodsubEvent\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003eMessage\u003c/span\u003e(msg) = event {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eOk\u003c/span\u003e(resp) = serde_json::from_slice::\u0026#x3C;ChainResponse\u003e(\u0026#x26;msg.data) {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e resp.receiver == PEER_ID.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e() {\n                    info!(\u003cspan class=\"hljs-string\"\u003e\"{}로부터 응답:\"\u003c/span\u003e, msg.source);\n                    resp.blocks.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003efor_each\u003c/span\u003e(|r| info!(\u003cspan class=\"hljs-string\"\u003e\"{:?}\"\u003c/span\u003e, r));\n\n                    \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.app.blocks = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.app.\u003cspan class=\"hljs-title function_ invoke__\"\u003echoose_chain\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.app.blocks.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(), resp.blocks);\n                }\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eOk\u003c/span\u003e(resp) = serde_json::from_slice::\u0026#x3C;LocalChainRequest\u003e(\u0026#x26;msg.data) {\n                info!(\u003cspan class=\"hljs-string\"\u003e\"{}로부터 로컬 체인 전송\"\u003c/span\u003e, msg.source.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e());\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epeer_id\u003c/span\u003e = resp.from_peer_id;\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e PEER_ID.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e() == peer_id {\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eErr\u003c/span\u003e(e) = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.response_sender.\u003cspan class=\"hljs-title function_ invoke__\"\u003esend\u003c/span\u003e(ChainResponse {\n                        blocks: \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.app.blocks.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(),\n                        receiver: msg.source.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(),\n                    }) {\n                        error!(\u003cspan class=\"hljs-string\"\u003e\"채널을 통해 응답 전송 중 오류 발생, {}\"\u003c/span\u003e, e);\n                    }\n                }\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eOk\u003c/span\u003e(block) = serde_json::from_slice::\u0026#x3C;Block\u003e(\u0026#x26;msg.data) {\n                info!(\u003cspan class=\"hljs-string\"\u003e\"{}로부터 새 블록 수신\"\u003c/span\u003e, msg.source.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e());\n                \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.app.\u003cspan class=\"hljs-title function_ invoke__\"\u003etry_add_block\u003c/span\u003e(block);\n            }\n        }\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkBehaviourEventProcess\u003c/span\u003e\u0026#x3C;MdnsEvent\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppBehaviour\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einject_event\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, event: MdnsEvent) {\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e event {\n            MdnsEvent::\u003cspan class=\"hljs-title function_ invoke__\"\u003eDiscovered\u003c/span\u003e(discovered_list) =\u003e {\n                \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (peer, _addr) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e discovered_list {\n                    \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.floodsub.\u003cspan class=\"hljs-title function_ invoke__\"\u003eadd_node_to_partial_view\u003c/span\u003e(peer);\n                }\n            }\n            MdnsEvent::\u003cspan class=\"hljs-title function_ invoke__\"\u003eExpired\u003c/span\u003e(expired_list) =\u003e {\n                \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (peer, _addr) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e expired_list {\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.mdns.\u003cspan class=\"hljs-title function_ invoke__\"\u003ehas_node\u003c/span\u003e(\u0026#x26;peer) {\n                        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.floodsub.\u003cspan class=\"hljs-title function_ invoke__\"\u003eremove_node_from_partial_view\u003c/span\u003e(\u0026#x26;peer);\n                    }\n                }\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e유틸리티 함수\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eget_list_peers: 네트워크에서 발견된 피어 목록을 반환합니다.\u003c/li\u003e\n\u003cli\u003ehandle_print_peers: 콘솔에 피어 목록을 로깅합니다.\u003c/li\u003e\n\u003cli\u003ehandle_print_chain: 로컬 블록체인 상태를 기록하며, 블록체인의 시각적 표현을 제공합니다.\u003c/li\u003e\n\u003cli\u003ehandle_create_block: 사용자 입력을 처리하여 새 블록을 생성합니다. 제공된 데이터로 새 블록을 생성하고, 로컬 블록체인을 업데이트하고, Floodsub을 사용하여 새 블록을 피어에 브로드캐스트합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_list_peers\u003c/span\u003e(swarm: \u0026#x26;Swarm\u0026#x3C;AppBehaviour\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e\u003e {\n    info!(\u003cspan class=\"hljs-string\"\u003e\"발견된 피어:\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003enodes\u003c/span\u003e = swarm.\u003cspan class=\"hljs-title function_ invoke__\"\u003ebehaviour\u003c/span\u003e().mdns.\u003cspan class=\"hljs-title function_ invoke__\"\u003ediscovered_nodes\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eunique_peers\u003c/span\u003e = HashSet::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epeer\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e nodes {\n        unique_peers.\u003cspan class=\"hljs-title function_ invoke__\"\u003einsert\u003c/span\u003e(peer);\n    }\n    unique_peers.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003emap\u003c/span\u003e(|p| p.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e()).\u003cspan class=\"hljs-title function_ invoke__\"\u003ecollect\u003c/span\u003e()\n}\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandle_print_peers\u003c/span\u003e(swarm: \u0026#x26;Swarm\u0026#x3C;AppBehaviour\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epeers\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eget_list_peers\u003c/span\u003e(swarm);\n    peers.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003efor_each\u003c/span\u003e(|p| info!(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, p));\n}\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandle_print_chain\u003c/span\u003e(swarm: \u0026#x26;Swarm\u0026#x3C;AppBehaviour\u003e) {\n    info!(\u003cspan class=\"hljs-string\"\u003e\"로컬 블록체인:\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epretty_json\u003c/span\u003e =\n        serde_json::\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string_pretty\u003c/span\u003e(\u0026#x26;swarm.\u003cspan class=\"hljs-title function_ invoke__\"\u003ebehaviour\u003c/span\u003e().app.blocks).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can jsonify blocks\"\u003c/span\u003e);\n    info!(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, pretty_json);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandle_create_block\u003c/span\u003e(cmd: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e, swarm: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e Swarm\u0026#x3C;AppBehaviour\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(data) = cmd.\u003cspan class=\"hljs-title function_ invoke__\"\u003estrip_prefix\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"create b\"\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebehaviour\u003c/span\u003e = swarm.\u003cspan class=\"hljs-title function_ invoke__\"\u003ebehaviour_mut\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003elatest_block\u003c/span\u003e = behaviour\n            .app\n            .blocks\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003elast\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"적어도 하나의 블록이 있어야 함\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eblock\u003c/span\u003e = Block::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\n            latest_block.id + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n            latest_block.hash.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(),\n            data.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_owned\u003c/span\u003e(),\n        );\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ejson\u003c/span\u003e = serde_json::\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(\u0026#x26;block).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can jsonify request\"\u003c/span\u003e);\n        behaviour.app.blocks.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush\u003c/span\u003e(block);\n        info!(\u003cspan class=\"hljs-string\"\u003e\"새 블록을 브로드캐스팅 중\"\u003c/span\u003e);\n        behaviour\n            .floodsub\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003epublish\u003c/span\u003e(BLOCK_TOPIC.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(), json.\u003cspan class=\"hljs-title function_ invoke__\"\u003eas_bytes\u003c/span\u003e());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003emain.rs — Main Loop 및 블록 채굴\u003c/h1\u003e\n\u003cp\u003e이제 'main.rs'라는 새 파일을 생성하여 메인 루프와 블록 채굴을 담당할 것입니다. 코어 로직은 아래와 같습니다:\u003c/p\u003e\n\u003ch1\u003e블록 구조\u003c/h1\u003e\n\u003cp\u003e블록 구조체는 블록체인 내의 블록 구조를 정의합니다. 이 구조에는 다음이 포함됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eid: 블록의 고유 식별자입니다.\u003c/li\u003e\n\u003cli\u003ehash: 블록의 해시입니다.\u003c/li\u003e\n\u003cli\u003eprevious_hash: 체인 내 이전 블록의 해시입니다.\u003c/li\u003e\n\u003cli\u003etimestamp: 블록의 생성 시간입니다.\u003c/li\u003e\n\u003cli\u003edata: 블록의 데이터 또는 페이로드입니다.\u003c/li\u003e\n\u003cli\u003enonce: 채굴 과정 중 사용되는 값입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::io::{Read, Write};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e chrono::prelude::*;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e libp2p::{\n    core::upgrade,\n    futures::StreamExt,\n    mplex,\n    noise::{Keypair, NoiseConfig, X25519Spec},\n    swarm::{Swarm, SwarmBuilder},\n    tcp::TokioTcpConfig,\n    Transport,\n};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e log::{error, info, warn};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e serde::{Deserialize, Serialize};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e sha2::{Digest, Sha256};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::time::Duration;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e tokio::{\n    io::{stdin, AsyncBufReadExt, BufReader},\n    select, spawn,\n    sync::mpsc,\n    time::sleep,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e DIFFICULTY_PREFIX: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"00\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e blockchain;\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e blocks: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Block\u003e,\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(Serialize, Deserialize, Debug, Clone)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlock\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e id: \u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e hash: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e previous_hash: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e timestamp: \u003cspan class=\"hljs-type\"\u003ei64\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e data: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e nonce: \u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e블록 생성 (새로운 기능)\u003c/h1\u003e\n\u003cp\u003e블록 구현 블록(DOM)에 있는 새로운 기능은 새 블록을 생성합니다. 이 기능은 mine_block 함수를 호출하여 블록의 해시와 논스를 생성합니다. 다른 속성들은 입력 값과 현재 시간을 기준으로 설정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlock\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(id: \u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e, previous_hash: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e, data: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003enow\u003c/span\u003e = Utc::\u003cspan class=\"hljs-title function_ invoke__\"\u003enow\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (nonce, hash) = \u003cspan class=\"hljs-title function_ invoke__\"\u003emine_block\u003c/span\u003e(id, now.\u003cspan class=\"hljs-title function_ invoke__\"\u003etimestamp\u003c/span\u003e(), \u0026#x26;previous_hash, \u0026#x26;data);\n        \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e {\n            id,\n            hash,\n            timestamp: now.\u003cspan class=\"hljs-title function_ invoke__\"\u003etimestamp\u003c/span\u003e(),\n            previous_hash,\n            data,\n            nonce,\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e해시 계산 (calculate_hash 함수)\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003ecalculate_hash\u003c/code\u003e 함수는 블록의 해시를 생성합니다. 이 함수는 블록의 속성을 JSON 객체로 만들고 이 데이터를 해시하기 위해 SHA-256 알고리즘을 사용합니다. 이 함수는 블록체인의 무결성을 보장하는 데 중요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_hash\u003c/span\u003e(id: \u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e, timestamp: \u003cspan class=\"hljs-type\"\u003ei64\u003c/span\u003e, previous_hash: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e, data: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e, nonce: \u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003edata\u003c/span\u003e = serde_json::json!({\n        \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: id,\n        \u003cspan class=\"hljs-string\"\u003e\"previous_hash\"\u003c/span\u003e: previous_hash,\n        \u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e: data,\n        \u003cspan class=\"hljs-string\"\u003e\"timestamp\"\u003c/span\u003e: timestamp,\n        \u003cspan class=\"hljs-string\"\u003e\"nonce\"\u003c/span\u003e: nonce\n    });\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ehasher\u003c/span\u003e = Sha256::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e();\n    hasher.\u003cspan class=\"hljs-title function_ invoke__\"\u003eupdate\u003c/span\u003e(data.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eas_bytes\u003c/span\u003e());\n    hasher.\u003cspan class=\"hljs-title function_ invoke__\"\u003efinalize\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eas_slice\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_owned\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e채굴 (mine_block 함수)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003emine_block\u003c/code\u003e은 작업 증명 알고리즘이 구현된 곳입니다. 이 함수는 nonce 값을 반복하여 특정 접두사(난이도 접두사로 정의됨)로 시작하는 해시를 찾으려고 시도합니다. 유효한 해시가 발견되면 함수는 nonce와 해당 해시를 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emine_block\u003c/span\u003e(id: \u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e, timestamp: \u003cspan class=\"hljs-type\"\u003ei64\u003c/span\u003e, previous_hash: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e, data: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) {\n    info!(\u003cspan class=\"hljs-string\"\u003e\"블록 채굴 중...\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003enonce\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e nonce % \u003cspan class=\"hljs-number\"\u003e100000\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"논스: {}\"\u003c/span\u003e, nonce);\n        }\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehash\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003ecalculate_hash\u003c/span\u003e(id, timestamp, previous_hash, data, nonce);\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebinary_hash\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003ehash_to_binary_representation\u003c/span\u003e(\u0026#x26;hash);\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e binary_hash.\u003cspan class=\"hljs-title function_ invoke__\"\u003estarts_with\u003c/span\u003e(DIFFICULTY_PREFIX) {\n            info!(\n                \u003cspan class=\"hljs-string\"\u003e\"채굴 성공! 논스: {}, 해시: {}, 이진 해시: {}\"\u003c/span\u003e,\n                nonce,\n                hex::\u003cspan class=\"hljs-title function_ invoke__\"\u003eencode\u003c/span\u003e(\u0026#x26;hash),\n                binary_hash\n            );\n            \u003cspan class=\"hljs-title function_ invoke__\"\u003ereturn\u003c/span\u003e (nonce, hex::\u003cspan class=\"hljs-title function_ invoke__\"\u003eencode\u003c/span\u003e(hash));\n        }\n        nonce += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e이진 해시 표현 (hash_to_binary_representation 함수)\u003c/h1\u003e\n\u003cp\u003e해시를 해당 이진 표현으로 변환하는 함수입니다. 이는 채굴 과정에서 해시가 난이도 조건을 충족하는지 확인하는 데 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehash_to_binary_representation\u003c/span\u003e(hash: \u0026#x26;[\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e]) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eres\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003edefault\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ec\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e hash {\n        res.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush_str\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-built_in\"\u003eformat!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{:b}\"\u003c/span\u003e, c));\n    }\n    res\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e제네시스 블록 (genesis 함수)\u003c/h1\u003e\n\u003cp\u003e이 함수는 블록체인에서 첫 번째 블록을 생성하는 함수로, 제네시스 블록이라고 알려져 있습니다. 이 블록은 수동으로 블록체인에 추가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e { blocks: \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[] }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egenesis\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003egenesis_block\u003c/span\u003e = Block {\n            id: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n            timestamp: Utc::\u003cspan class=\"hljs-title function_ invoke__\"\u003enow\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003etimestamp\u003c/span\u003e(),\n            previous_hash: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"genesis\"\u003c/span\u003e),\n            data: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"genesis!\"\u003c/span\u003e),\n            nonce: \u003cspan class=\"hljs-number\"\u003e2836\u003c/span\u003e,\n            hash: \u003cspan class=\"hljs-string\"\u003e\"0000f816a87f806bb0073dcf026a64fb40c946b5abee2573702828694d5b4c43\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(),\n        };\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.blocks.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush\u003c/span\u003e(genesis_block);\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e블록 추가하기 (try_add_block 함수)\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003etry_add_block\u003c/code\u003e 함수는 블록체인에 새로운 블록을 추가하려고 시도합니다. 먼저, 새로운 블록을 최신 블록과 검증합니다. 새로운 블록이 유효하면 체인에 추가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etry_add_block\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, block: Block) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003elatest_block\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.blocks.\u003cspan class=\"hljs-title function_ invoke__\"\u003elast\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"there is at least one block\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eis_block_valid\u003c/span\u003e(\u0026#x26;block, latest_block) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.blocks.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush\u003c/span\u003e(block);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        error!(\u003cspan class=\"hljs-string\"\u003e\"could not add block - invalid\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e블록 유효성 검사 (is_block_valid 함수)\u003c/h2\u003e\n\u003cp\u003e이 함수는 이전 블록에 대해 블록을 유효성 검사합니다. 다음을 확인합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이전 해시 필드는 이전 블록의 해시와 일치합니다.\u003c/li\u003e\n\u003cli\u003e해시 난이도 수준이 올바릅니다.\u003c/li\u003e\n\u003cli\u003e블록 ID가 이전 블록의 ID를 따릅니다.\u003c/li\u003e\n\u003cli\u003e블록 해시가 유효합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eis_block_valid\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, block: \u0026#x26;Block, previous_block: \u0026#x26;Block) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e block.previous_hash != previous_block.hash {\n        warn!(\u003cspan class=\"hljs-string\"\u003e\"블록 ID가 {}인 블록은 잘못된 이전 해시를 가지고 있습니다.\"\u003c/span\u003e, block.id);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !\u003cspan class=\"hljs-title function_ invoke__\"\u003ehash_to_binary_representation\u003c/span\u003e(\n        \u0026#x26;hex::\u003cspan class=\"hljs-title function_ invoke__\"\u003edecode\u003c/span\u003e(\u0026#x26;block.hash).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"16진수로 디코딩할 수 있어야 합니다.\"\u003c/span\u003e),\n    )\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003estarts_with\u003c/span\u003e(DIFFICULTY_PREFIX)\n    {\n        warn!(\u003cspan class=\"hljs-string\"\u003e\"블록 ID가 {}인 블록은 유효하지 않은 난이도를 가지고 있습니다.\"\u003c/span\u003e, block.id);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e block.id != previous_block.id + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e {\n        warn!(\n            \u003cspan class=\"hljs-string\"\u003e\"블록 ID가 {}인 블록은 최신 블록 이후의 다음 블록이 아닙니다: {}\"\u003c/span\u003e,\n            block.id, previous_block.id\n        );\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e hex::\u003cspan class=\"hljs-title function_ invoke__\"\u003eencode\u003c/span\u003e(\u003cspan class=\"hljs-title function_ invoke__\"\u003ecalculate_hash\u003c/span\u003e(\n        block.id,\n        block.timestamp,\n        \u0026#x26;block.previous_hash,\n        \u0026#x26;block.data,\n        block.nonce,\n    )) != block.hash\n    {\n        warn!(\u003cspan class=\"hljs-string\"\u003e\"블록 ID가 {}인 블록은 유효하지 않은 해시를 가지고 있습니다.\"\u003c/span\u003e, block.id);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e체인 유효성 검사 (is_chain_valid 함수)\u003c/h1\u003e\n\u003cp\u003eis_chain_valid는 전체 블록 체인의 유효성을 검사합니다. 블록체인이 일관적이고 유효한 상태를 유지하는 데 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eis_chain_valid\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, chain: \u0026#x26;[Block]) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ei\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..chain.\u003cspan class=\"hljs-title function_ invoke__\"\u003elen\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efirst\u003c/span\u003e = chain.\u003cspan class=\"hljs-title function_ invoke__\"\u003eget\u003c/span\u003e(i - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"has to exist\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003esecond\u003c/span\u003e = chain.\u003cspan class=\"hljs-title function_ invoke__\"\u003eget\u003c/span\u003e(i).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"has to exist\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eis_block_valid\u003c/span\u003e(second, first) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n        }\n    }\n    \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e체인 선택 (choose_chain 함수)\u003c/h1\u003e\n\u003cp\u003e이 함수는 블록체인의 여러 버전이 충돌하는 경우 해결하는 데 사용됩니다. 항상 가장 긴 유효한 체인을 선택합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 항상 가장 긴 유효한 체인을 선택합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echoose_chain\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, local: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Block\u003e, remote: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Block\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Block\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eis_local_valid\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eis_chain_valid\u003c/span\u003e(\u0026#x26;local);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eis_remote_valid\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eis_chain_valid\u003c/span\u003e(\u0026#x26;remote);\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e is_local_valid \u0026#x26;\u0026#x26; is_remote_valid {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e local.\u003cspan class=\"hljs-title function_ invoke__\"\u003elen\u003c/span\u003e() \u003e= remote.\u003cspan class=\"hljs-title function_ invoke__\"\u003elen\u003c/span\u003e() {\n            local\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            remote\n        }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e is_remote_valid \u0026#x26;\u0026#x26; !is_local_valid {\n        remote\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !is_remote_valid \u0026#x26;\u0026#x26; is_local_valid {\n        local\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003epanic!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"로컬 및 원격 체인이 모두 유효하지 않습니다\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e메인 기능 및 블록체인 네트워킹\u003c/h1\u003e\n\u003cp\u003e주요 기능은 블록체인 애플리케이션의 네트워킹 및 이벤트 처리 부분을 설정합니다. 토키오(tokio)와 립투피(libp2p) 라이브러리를 사용하여 피어 간 상호 작용을 관리하며, 체인 요청 및 사용자 입력 처리와 같은 이벤트에 응답합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[tokio::main]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    pretty_env_logger::\u003cspan class=\"hljs-title function_ invoke__\"\u003einit\u003c/span\u003e();\n\n    info!(\u003cspan class=\"hljs-string\"\u003e\"Peer Id: {}\"\u003c/span\u003e, blockchain::PEER_ID.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e());\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (response_sender, \u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e response_rcv) = mpsc::\u003cspan class=\"hljs-title function_ invoke__\"\u003eunbounded_channel\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (init_sender, \u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e init_rcv) = mpsc::\u003cspan class=\"hljs-title function_ invoke__\"\u003eunbounded_channel\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eauth_keys\u003c/span\u003e = Keypair::\u0026#x3C;X25519Spec\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_authentic\u003c/span\u003e(\u0026#x26;blockchain::KEYS)\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can create auth keys\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etransp\u003c/span\u003e = TokioTcpConfig::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003eupgrade\u003c/span\u003e(upgrade::Version::V1)\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003eauthenticate\u003c/span\u003e(NoiseConfig::\u003cspan class=\"hljs-title function_ invoke__\"\u003exx\u003c/span\u003e(auth_keys).\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_authenticated\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003emultiplex\u003c/span\u003e(mplex::MplexConfig::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003eboxed\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebehaviour\u003c/span\u003e = blockchain::AppBehaviour::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(App::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(), response_sender, init_sender.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eswarm\u003c/span\u003e = SwarmBuilder::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(transp, behaviour, *blockchain::PEER_ID)\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003eexecutor\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(|fut| {\n            \u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(fut);\n        }))\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003ebuild\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003estdin\u003c/span\u003e = BufReader::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-title function_ invoke__\"\u003estdin\u003c/span\u003e()).\u003cspan class=\"hljs-title function_ invoke__\"\u003elines\u003c/span\u003e();\n\n    Swarm::\u003cspan class=\"hljs-title function_ invoke__\"\u003elisten_on\u003c/span\u003e(\n        \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e swarm,\n        \u003cspan class=\"hljs-string\"\u003e\"/ip4/0.0.0.0/tcp/0\"\u003c/span\u003e\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003eparse\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can get a local socket\"\u003c/span\u003e),\n    )\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"swarm can be started\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003esleep\u003c/span\u003e(Duration::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom_secs\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e;\n        info!(\u003cspan class=\"hljs-string\"\u003e\"sending init event\"\u003c/span\u003e);\n        init_sender.\u003cspan class=\"hljs-title function_ invoke__\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can send init event\"\u003c/span\u003e);\n    });\n\n    \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eevt\u003c/span\u003e = {\n            \u003cspan class=\"hljs-built_in\"\u003eselect!\u003c/span\u003e {\n                line = stdin.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext_line\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(blockchain::EventType::\u003cspan class=\"hljs-title function_ invoke__\"\u003eInput\u003c/span\u003e(line.\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can get line\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can read line from stdin\"\u003c/span\u003e))),\n                response = response_rcv.\u003cspan class=\"hljs-title function_ invoke__\"\u003erecv\u003c/span\u003e() =\u003e {\n                    \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(blockchain::EventType::\u003cspan class=\"hljs-title function_ invoke__\"\u003eLocalChainResponse\u003c/span\u003e(response.\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"response exists\"\u003c/span\u003e)))\n                },\n                _init = init_rcv.\u003cspan class=\"hljs-title function_ invoke__\"\u003erecv\u003c/span\u003e() =\u003e {\n                    \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(blockchain::EventType::Init)\n                }\n                event = swarm.\u003cspan class=\"hljs-title function_ invoke__\"\u003eselect_next_some\u003c/span\u003e() =\u003e {\n                    info!(\u003cspan class=\"hljs-string\"\u003e\"Unhandled Swarm Event: {:?}\"\u003c/span\u003e, event);\n                    \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n                },\n            }\n        };\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(event) = evt {\n            \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e event {\n                blockchain::EventType::Init =\u003e {\n                    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epeers\u003c/span\u003e = blockchain::\u003cspan class=\"hljs-title function_ invoke__\"\u003eget_list_peers\u003c/span\u003e(\u0026#x26;swarm);\n                    swarm.\u003cspan class=\"hljs-title function_ invoke__\"\u003ebehaviour_mut\u003c/span\u003e().app.\u003cspan class=\"hljs-title function_ invoke__\"\u003egenesis\u003c/span\u003e();\n\n                    info!(\u003cspan class=\"hljs-string\"\u003e\"connected nodes: {}\"\u003c/span\u003e, peers.\u003cspan class=\"hljs-title function_ invoke__\"\u003elen\u003c/span\u003e());\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !peers.\u003cspan class=\"hljs-title function_ invoke__\"\u003eis_empty\u003c/span\u003e() {\n                        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ereq\u003c/span\u003e = blockchain::LocalChainRequest {\n                            from_peer_id: peers\n                                .\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e()\n                                .\u003cspan class=\"hljs-title function_ invoke__\"\u003elast\u003c/span\u003e()\n                                .\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"at least one peer\"\u003c/span\u003e)\n                                .\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(),\n                        };\n\n                        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ejson\u003c/span\u003e = serde_json::\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(\u0026#x26;req).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can jsonify request\"\u003c/span\u003e);\n                        swarm\n                            .\u003cspan class=\"hljs-title function_ invoke__\"\u003ebehaviour_mut\u003c/span\u003e()\n                            .floodsub\n                            .\u003cspan class=\"hljs-title function_ invoke__\"\u003epublish\u003c/span\u003e(blockchain::CHAIN_TOPIC.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(), json.\u003cspan class=\"hljs-title function_ invoke__\"\u003eas_bytes\u003c/span\u003e());\n                    }\n                }\n                blockchain::EventType::\u003cspan class=\"hljs-title function_ invoke__\"\u003eLocalChainResponse\u003c/span\u003e(resp) =\u003e {\n                    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ejson\u003c/span\u003e = serde_json::\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(\u0026#x26;resp).\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"can jsonify response\"\u003c/span\u003e);\n                    swarm\n                        .\u003cspan class=\"hljs-title function_ invoke__\"\u003ebehaviour_mut\u003c/span\u003e()\n                        .floodsub\n                        .\u003cspan class=\"hljs-title function_ invoke__\"\u003epublish\u003c/span\u003e(blockchain::CHAIN_TOPIC.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(), json.\u003cspan class=\"hljs-title function_ invoke__\"\u003eas_bytes\u003c/span\u003e());\n                }\n                blockchain::EventType::\u003cspan class=\"hljs-title function_ invoke__\"\u003eInput\u003c/span\u003e(line) =\u003e \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e line.\u003cspan class=\"hljs-title function_ invoke__\"\u003eas_str\u003c/span\u003e() {\n                    \u003cspan class=\"hljs-string\"\u003e\"ls p\"\u003c/span\u003e =\u003e blockchain::\u003cspan class=\"hljs-title function_ invoke__\"\u003ehandle_print_peers\u003c/span\u003e(\u0026#x26;swarm),\n                    cmd \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cmd.\u003cspan class=\"hljs-title function_ invoke__\"\u003estarts_with\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ls c\"\u003c/span\u003e) =\u003e blockchain::\u003cspan class=\"hljs-title function_ invoke__\"\u003ehandle_print_chain\u003c/span\u003e(\u0026#x26;swarm),\n                    cmd \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cmd.\u003cspan class=\"hljs-title function_ invoke__\"\u003estarts_with\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"create b\"\u003c/span\u003e) =\u003e blockchain::\u003cspan class=\"hljs-title function_ invoke__\"\u003ehandle_create_block\u003c/span\u003e(cmd, \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e swarm),\n                    _ =\u003e error!(\u003cspan class=\"hljs-string\"\u003e\"unknown command\"\u003c/span\u003e),\n                },\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e와우, 이것 참 많이네요!\u003c/p\u003e\n\u003cp\u003e내 GitHub 저장소에서 완전한 구현을 찾을 수 있어요: \u003ca href=\"https://github.com/luishsr/rustychain\" rel=\"nofollow\" target=\"_blank\"\u003e루스티체인\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003e블록체인 테스트\u003c/h2\u003e\n\u003cp\u003eRust로 제공된 블록체인 구현을 사용하고 테스트하려면 환경 설정, 노드 시작 및 상호 작용하는 일련의 단계를 따라야 해요. 시작하는 데 도움이 되는 빠른 가이드를 제공할게요:\u003c/p\u003e\n\u003ch2\u003e단일 노드 실행\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e컴파일 및 실행\u003c/strong\u003e: Rust 블록체인 코드가 있는 디렉토리로 이동한 후 cargo build를 사용하여 프로젝트를 컴파일합니다. 성공적인 컴파일이 완료되면 cargo run을 사용하여 노드를 실행합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e초기 테스트\u003c/strong\u003e: 처음에는 제네시스 블록이 올바르게 생성되고 노드가 제대로 시작되는지 확인하기 위해 단일 노드로 테스트합니다. 만약 구현되어 있다면 현재 체인이나 노드 상태를 표시하는 명령을 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e여러 노드 실행하기\u003c/h1\u003e\n\u003cp\u003e실제 블록체인 네트워크를 시뮬레이션하려면 여러 노드를 동시에 실행해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e여러 터미널 열기\u003c/strong\u003e: 여러 터미널 창 또는 탭을열어주세요. 각각은 네트워크에서 별개의 노드를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e독립적으로 노드 실행\u003c/strong\u003e: 각 터미널에서 프로젝트 디렉토리로 이동하고 cargo run을 실행합니다. 각 인스턴스는 블록체인 네트워크의 별개 노드로 동작하게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e노드와 상호작용하기\u003c/h1\u003e\n\u003cp\u003e블록체인의 기능을 테스트하려면 노드와 상호작용해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e새 블록 생성: 구현된 명령어(예: \u003ccode\u003edata\u003c/code\u003e를 이용한 \u003ccode\u003ecreate b\u003c/code\u003e)를 사용하여 새 블록을 생성하세요. 이는 블록체인에 거래나 데이터 추가를 시뮬레이션할 것입니다.\u003c/li\u003e\n\u003cli\u003e블록 전파: 한 노드에서 새 블록이 생성되면 이 블록을 다른 노드에 전파해야 합니다. 다른 노드가 이 새 블록을 수신하고 유효성을 검사하여 자신의 블록체인 버전에 추가하는지 확인하세요.\u003c/li\u003e\n\u003cli\u003e블록체인 상태 보기: 정기적으로 각 노드의 블록체인 현재 상태를 출력하는 명령어를 사용하세요. 노드 간에 일관성이 있어야하며 최신 유효 블록을 반영해야 합니다.\u003c/li\u003e\n\u003cli\u003e체인 충돌 테스트: 서로 다른 노드에서 동시에 다른 블록을 생성하여 체인 충돌을 시뮬레이트하세요. 구현이 이러한 충돌을 해결하는 방식(일반적으로 가장 긴 유효 체인을 선택함)을 관찰하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e🚀 루이스 소아레스에 의한 소프트웨어 개발 및 기타 다양한 리소스 탐색하기\u003c/h1\u003e\n\u003cp\u003e📚 학습 플랫폼: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅, 사이버 보안, 블록체인, 리눅스 등 다양한 기술 분야에서 지식을 넓히세요. 저의 포괄적인 자료 모음을 통해:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub 리포지토리와 함께 하는 실습 튜토리얼: 전용 GitHub 리포지토리를 통해 단계별 실습을 통해 다양한 기술을 실용적으로 익힐 수 있습니다. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e튜토리얼 접근하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e심층 안내서 및 기사: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅 등의 핵심 개념을 자세히 다룬 안내서와 실제 예제가 풍부한 기사로 깊게 파보세요. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e더 읽기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e전자책 모음집: \"러스트 소유권 마스터하기\" 및 \"애플리케이션 보안 안내서\"와 같은 제목을 포함한 무료 전자책 시리즈로 다양한 기술 분야의 이해를 향상시키세요. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e전자책 다운로드\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e프로젝트 쇼케이스: API 게이트웨이, 블록체인 네트워크, 사이버 보안 도구, 클라우드 서비스 등과 같이 다양한 분야의 완전 기능 프로젝트를 발견하세요. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e프로젝트 보기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLinkedIn 뉴스레터: LinkedIn에서 제 뉴스레터를 구독하여 러스트, 소프트웨어 개발 및 신흥 기술에 관한 규칙적인 업데이트와 통찰력을 유지하세요. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e여기서 구독하기\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e🔗 저와 연결해보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMedium: 미디엄에서 제 글을 읽고 유용하다고 생각하면 박수를 보내주세요. 이는 저에게 글쓰기와 러스트 콘텐츠 공유를 계속 이끌어주는 원동력이 됩니다. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003eMedium 팔로우하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e개인 블로그: 제 개인 블로그에서 더 많은 러스트 관련 콘텐츠를 확인하세요. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e블로그 방문하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLinkedIn: 더 많은 통찰력 있는 토론과 업데이트를 위해 제 전문 네트워크에 참여하세요. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003eLinkedIn 연결하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e트위터: 빠른 업데이트와 러스트 프로그래밍에 대한 생각을 보려면 트위터에서 저를 팔로우하세요. \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e트위터에서 팔로우하기\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWassup, folks? Feel free to leave a comment or shoot me a message!\u003c/p\u003e\n\u003cp\u003eCheers,\u003c/p\u003e\n\u003cp\u003eLuis Soares\n\u003ca href=\"mailto:luis.soares@linux.com\"\u003eluis.soares@linux.com\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSenior Software Engineer | Cloud Engineer | SRE | Tech Lead | Rust | Golang | Java | ML AI \u0026#x26; Statistics | Web3 \u0026#x26; Blockchain\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-05-ImplementingaBlockchaininRust"},"buildId":"z0ZGRQY04MD5cUdT-Nqp1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>