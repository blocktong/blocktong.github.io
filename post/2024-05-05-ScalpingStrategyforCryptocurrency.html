<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>암호화폐의 스캘핑 전략 | blocktong</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://blocktong.github.io///post/2024-05-05-ScalpingStrategyforCryptocurrency" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="암호화폐의 스캘핑 전략 | blocktong" data-gatsby-head="true"/><meta property="og:title" content="암호화폐의 스캘핑 전략 | blocktong" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://blocktong.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://blocktong.github.io///post/2024-05-05-ScalpingStrategyforCryptocurrency" data-gatsby-head="true"/><meta name="twitter:title" content="암호화폐의 스캘핑 전략 | blocktong" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | blocktong" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-05 15:06" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-5b12619e815e966a.js" defer=""></script><script src="/_next/static/z0ZGRQY04MD5cUdT-Nqp1/_buildManifest.js" defer=""></script><script src="/_next/static/z0ZGRQY04MD5cUdT-Nqp1/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Block Tong</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">암호화폐의 스캘핑 전략</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="암호화폐의 스캘핑 전략" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Block Tong</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 5, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-05-ScalpingStrategyforCryptocurrency&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>EODHD API를 사용하여 Bitcoin 데이터에 스캘핑 전략 적용하기</h2>
<p><img src="/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_0.png" alt="Scalping Bitcoin"></p>
<h2>스캘핑 전략이란?</h2>
<p>이 개념은 듣기만큼 복잡하지 않습니다. 시장에 있다고 상상해보세요. 한 가격에 물건을 사고 빨리 약간 높은 가격에 다른 사람에게 판매할 기회를 발견합니다. 그것이 바로 거래에서의 스캘핑이 하는 일입니다. 시장의 작은 가격 움직임을 이용해 빠르고 소규모 수익을 창출하는 것입니다.</p>
<p>이제 암호화폐 거래에 적용하는 것을 생각해보겠습니다. 특히 비트코인의 경우, 초고속 디지털 시장에서 이를 진행한다고 상상해보세요. 비트코인과 같은 암호화폐는 가격이 매우 빠르게 변동할 수 있으며 짧은 시간 내에도 꽤 크게 변할 수 있습니다. 이는 스캘핑에 적합합니다. 적은 양의 비트코인을 구매한 다음, 가격이 약간 상승하자마자 소량 이익을 내고 팔아야 합니다. 그리고 다시 그렇게 반복하며 하루에 여러 번 거래를 합니다.</p>
<p>이를 제대로 수행하려면 짧은 간격으로 거래해야 합니다. 전형적인 스캘핑 접근 방식의 경우, 트레이더들은 주로 1분, 5분 또는 15분과 같은 짧은 시간프레임을 사용하는데, 이는 스캘핑이 매우 짧은 시간 내에 시장 움직임에서 이익을 얻으려는 것이므로입니다. 1분 시간프레임은 하루 거래 전체를 통해 다양한 소규모 가격 움직임을 포착할 수 있는 잠재력으로 매우 인기가 있습니다. 그러나 시간프레임의 선택은 트레이더의 특정 전략, 리스크 허용능력 및 거래되는 시장에 따라 다양할 수 있습니다. 이번 시연에서는 EODHD APIs에서 제공하는 1분 데이터를 사용하겠습니다.</p>
<h2>비트코인 스캘핑의 장점</h2>
<ul>
<li>빠른 수익: 빠르고 민첩하다면 하루 내내 소규모 이익을 상당히 쌓을 수 있습니다. 개발한 암호화폐 거래 봇 PyCryptoBot은 이를 자동화하는 데 완벽합니다. 웹소켓을 사용할 수도 있습니다.</li>
<li>즐거움: 꽤 즐겁습니다! 언제나 기회를 찾아 신속하게 결정을 내려야 합니다.</li>
<li>레버리지 사용: 일부 트레이더들은 레버리지를 사용하여 거래력을 증폭시키고 소규모 가격 변동으로부터 이익을 증가시킬 수 있지만, 이는 일반적으로 암호화폐 거래소에는 적용되지 않습니다. 하지만 IG와 같은 플랫폼에서는 가능하지만 전문 계정이 필요하며 상당한 리스크가 있으므로 주의해야 합니다.</li>
</ul>
<h2>비트코인 스캘핑의 단점</h2>
<ul>
<li>고위험: 보상 가능성이 높을수록, 특히 레버리지를 사용하는 경우 손실도 증폭될 수 있습니다.</li>
<li>수수료 부담: 매번 거래를 할 때마다 수수료가 발생합니다. 부주의하면 수익을 갉아먹거나 이긴 전략조차 패배로 변할 수 있습니다. 수수료는 전략 논리에 반영되어야 합니다.</li>
<li>스트레스와 시간 소모: 여유롭지 않습니다. 항상 준비돼 있어야 하며, 상당히 집중력을 필요로 하는 거래 방식입니다.</li>
</ul>
<p>수수료에 대해 얘기해보죠. 이것은 계산에 꼭 고려해야 할 중요한 부분입니다. 거래를 할 때마다 거래소가 약간의 수수료를 차감합니다. 스캘핑이라면 자주 거래를 하기 때문에 작은 수수료가 많이 발생합니다. 주의를 기울이지 않으면 수익을 올리기 위해 움직여야 할 가격이 충분하지 않을 수도 있습니다. 이러면 움직이지 않고 제자리에 서 있기 위해 열심히 움직이고 있는 느낌이 들 수도 있습니다. 혹은 더 나빠진 경우, 돈을 잃을 수도 있습니다. 네, 수수료에 대해 자주 언급하지만 중요성을 강조하기에 그만이 없습니다.</p>
<p>요약하자면, 비트코인 스캘핑은 심리적으로 힘든 것으로 여겨집니다. 변동성이 높아 흥미로울 뿐만 아니라 이윤을 얻을 수 있지만, 손실의 영향, 특히 거래 전략에 미치는 수수료의 영향을 잘 파악해야 합니다. 실제 돈이 걸린 아주 빠른 속도의 비디오 게임을 하는 것과 비슷합니다. 잘 짜여진 전략이 필요하며, 뚜렷한 통제력이 필요하며, 냉정함을 유지해야 합니다.</p>
<h2>전략 개요</h2>
<ul>
<li>시간 단위: 1분 데이터.</li>
<li>매수 신호: 빠른 SMA(5기간)가 느린 SMA(12기간)를 상향 돌파하면 상승 모멘텀이 나타납니다. 우리는 신호 캔들의 종가에 매수합니다.</li>
<li>매도 신호: 빠른 SMA(5기간)가 느린 SMA(12기간)를 하향 돌파하면 하락 모멘텀이 나타납니다. 우리는 신호 캔들의 종가에 매도합니다.</li>
<li>거래 수수료: 각 거래에서 차감되는 왕복(매수 및 매도) 거래 수수료를 가정합니다. Coinbase Advanced Trade의 0.6% 테이커 수수료를 가정합니다.</li>
<li>재투자: 수수료를 고려한 이익을 모두 재투자합니다.</li>
<li>실행: 전략은 신호에 이어 종가에서 실행됩니다.</li>
<li>초기 투자: 백테스트는 정의된 초기 투자 금액으로 시작됩니다.</li>
</ul>
<h2>데이터 검색 중...</h2>
<p>EODHD APIs에서 1분 단위 BTC-USD 데이터를 검색하겠습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> eodhd <span class="hljs-keyword">import</span> APIClient
<span class="hljs-keyword">import</span> config <span class="hljs-keyword">as</span> cfg

api = APIClient(cfg.API_KEY)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ohlc_data</span>():
    df = api.get_historical_data(<span class="hljs-string">"BTC-USD.CC"</span>, <span class="hljs-string">"1m"</span>, results=<span class="hljs-number">120</span>)
    <span class="hljs-keyword">return</span> df

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    df = get_ohlc_data()

    df[<span class="hljs-string">"close"</span>] = pd.to_numeric(df[<span class="hljs-string">"close"</span>], errors=<span class="hljs-string">"coerce"</span>)
    df.dropna(subset=[<span class="hljs-string">"close"</span>], inplace=<span class="hljs-literal">True</span>)
    df[<span class="hljs-string">"close"</span>].fillna(value=df[<span class="hljs-string">"close"</span>].mean(), inplace=<span class="hljs-literal">True</span>)

    <span class="hljs-built_in">print</span>(df)
</code></pre>
<p><img src="/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_1.png" alt="Chart"></p>
<h2>기본 전략 적용</h2>
<p>이것은 기본적인 스캘핑 전략의 예입니다. 세부 조정을 권장드리며, 이후에 이를 백테스트하는 방법을 보여드릴 예정이니 결과에 미치는 개선 사항을 평가할 수 있을 것입니다.</p>
<pre><code class="hljs language-js">fast_sma_period = <span class="hljs-number">5</span>
slow_sma_period = <span class="hljs-number">12</span>
df[<span class="hljs-string">"fast_sma"</span>] = df[<span class="hljs-string">"close"</span>].<span class="hljs-title function_">rolling</span>(<span class="hljs-variable language_">window</span>=fast_sma_period).<span class="hljs-title function_">mean</span>()
df[<span class="hljs-string">"slow_sma"</span>] = df[<span class="hljs-string">"close"</span>].<span class="hljs-title function_">rolling</span>(<span class="hljs-variable language_">window</span>=slow_sma_period).<span class="hljs-title function_">mean</span>()

df[<span class="hljs-string">"signal"</span>] = <span class="hljs-number">0</span>  # <span class="hljs-keyword">default</span>
df.<span class="hljs-property">loc</span>[df[<span class="hljs-string">"fast_sma"</span>] > df[<span class="hljs-string">"slow_sma"</span>], <span class="hljs-string">"signal"</span>] = <span class="hljs-number">1</span>  # buy signal
df.<span class="hljs-property">loc</span>[df[<span class="hljs-string">"fast_sma"</span>] &#x3C; df[<span class="hljs-string">"slow_sma"</span>], <span class="hljs-string">"signal"</span>] = -<span class="hljs-number">1</span>  # sell signal

<span class="hljs-title function_">print</span>(df)
</code></pre>
<p><img src="/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_2.png" alt="Image for Strategy"></p>
<h2>전략 백테스팅</h2>
<pre><code class="hljs language-js">fee_percent = <span class="hljs-number">0.006</span>  # <span class="hljs-number">0.6</span>%

initial_investment = <span class="hljs-number">1000.0</span>
cash = initial_investment
position = <span class="hljs-number">0</span>  # bitcoin balance

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-title function_">len</span>(df)):
    <span class="hljs-keyword">if</span> df.<span class="hljs-property">iloc</span>[i][<span class="hljs-string">"signal"</span>] == <span class="hljs-number">1</span> and df.<span class="hljs-property">iloc</span>[i - <span class="hljs-number">1</span>][<span class="hljs-string">"signal"</span>] == -<span class="hljs-number">1</span>:
        # buy, assuming all cash is used
        buy_amount = cash * (<span class="hljs-number">1</span> - fee_percent)  # deduct fee
        position = buy_amount / df.<span class="hljs-property">iloc</span>[i][<span class="hljs-string">"close"</span>]
        cash = <span class="hljs-number">0</span>

    elif df.<span class="hljs-property">iloc</span>[i][<span class="hljs-string">"signal"</span>] == -<span class="hljs-number">1</span> and df.<span class="hljs-property">iloc</span>[i - <span class="hljs-number">1</span>][<span class="hljs-string">"signal"</span>] == <span class="hljs-number">1</span>:
        # sell, converting position to cash
        cash = position * df.<span class="hljs-property">iloc</span>[i][<span class="hljs-string">"close"</span>] * (<span class="hljs-number">1</span> - fee_percent)  # deduct fee
        position = <span class="hljs-number">0</span>

final_value = cash <span class="hljs-keyword">if</span> position == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> position * df.<span class="hljs-property">iloc</span>[-<span class="hljs-number">1</span>][<span class="hljs-string">"close"</span>]
net_result = final_value - initial_investment

<span class="hljs-title function_">print</span>(f<span class="hljs-string">"최종 가치: {final_value:.2f}"</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"순수익: {net_result:.2f} ({net_result / initial_investment * 100:.2f}%)"</span>)
</code></pre>
<p><img src="/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_3.png" alt="Scalping Strategy for Cryptocurrency"></p>
<p>요 정보는 120분 동안 데이터를 사용할 때 전략이 손해를 낼 것을 보여줍니다. 시작 투자금인 £1000은 120분 후에 £914.38로 감소할 것입니다. 순 결과로는 -£85.62 (-8.56%)가 됩니다. 이것은 크게 놀랍지 않습니다. Coinbase의 수수료가 매우 높기 때문에 전략에 수수료가 포함되어 있습니다.</p>
<p>수수료를 제외하면 긍정적인 결과가 나옵니다.</p>
<pre><code class="hljs language-js"># fee_percent = <span class="hljs-number">0.006</span>  # <span class="hljs-number">0.6</span>%
fee_percent = <span class="hljs-number">0.0</span>  # <span class="hljs-number">0.0</span>%
</code></pre>
<p><img src="/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_4.png" alt="Scalping Strategy for Cryptocurrency"></p>
<p>0.08% in 2 hours.</p>
<h2>Trailing Stop Loss and Take-Profit</h2>
<p>A potential way to improve on this while maintaining the inclusion of fees is to implement a trailing stop loss and/or a take-profit mechanism. The take-profit is often 3x the stop loss.</p>
<p>저는 이것을 실험해 보았고 긍정적인 결과를 얻었지만 수수료를 0.6%에서 0.1%로 낮춰야 했습니다. 비트코인과 같이 변동성이 큰 자산에서 이보다 높은 수수료로는 1분 간격으로는 일관성이 없어 보입니다.</p>
<p>또한 암호화폐와 함께 작업할 때 더 반응성이 좋은 EMA(Exponential Moving Average)로 SMA(Simple Moving Average) 교차선을 교체했습니다.</p>
<p>내 코드는 이렇게 생겼어요:</p>
<pre><code class="hljs language-js">fast_ma_period = <span class="hljs-number">12</span>
slow_ma_period = <span class="hljs-number">26</span>
# df[<span class="hljs-string">"fast_ma"</span>] = df[<span class="hljs-string">"close"</span>].<span class="hljs-title function_">rolling</span>(<span class="hljs-variable language_">window</span>=fast_ma_period).<span class="hljs-title function_">mean</span>()
# df[<span class="hljs-string">"slow_ma"</span>] = df[<span class="hljs-string">"close"</span>].<span class="hljs-title function_">rolling</span>(<span class="hljs-variable language_">window</span>=slow_ma_period).<span class="hljs-title function_">mean</span>()
df[<span class="hljs-string">"fast_ma"</span>] = df[<span class="hljs-string">"close"</span>].<span class="hljs-title function_">ewm</span>(span=fast_ma_period, adjust=<span class="hljs-title class_">False</span>).<span class="hljs-title function_">mean</span>()
df[<span class="hljs-string">"slow_ma"</span>] = df[<span class="hljs-string">"close"</span>].<span class="hljs-title function_">ewm</span>(span=slow_ma_period, adjust=<span class="hljs-title class_">False</span>).<span class="hljs-title function_">mean</span>()

df[<span class="hljs-string">"signal"</span>] = <span class="hljs-number">0</span>  # 기본값 설정
df.<span class="hljs-property">loc</span>[df[<span class="hljs-string">"fast_ma"</span>] > df[<span class="hljs-string">"slow_ma"</span>], <span class="hljs-string">"signal"</span>] = <span class="hljs-number">1</span>  # 매수 신호
df.<span class="hljs-property">loc</span>[df[<span class="hljs-string">"fast_ma"</span>] &#x3C; df[<span class="hljs-string">"slow_ma"</span>], <span class="hljs-string">"signal"</span>] = -<span class="hljs-number">1</span>  # 매도 신호

fee_percent = <span class="hljs-number">0.001</span>  # <span class="hljs-number">0.1</span>%

initial_investment = <span class="hljs-number">1000.0</span>
cash = initial_investment
position = <span class="hljs-number">0</span>
high_since_buy = <span class="hljs-number">0</span>
buy_price = <span class="hljs-number">0</span>

trailing_stop_loss = <span class="hljs-number">0.002</span>  # 예: <span class="hljs-number">0.002</span> × <span class="hljs-number">100</span> = <span class="hljs-number">0.2</span>%
take_profit = trailing_stop_loss * <span class="hljs-number">3</span>  # <span class="hljs-number">3</span>배 트레일링 스탑 손실
stop_loss = <span class="hljs-number">0.02</span>  # 예: <span class="hljs-number">0.02</span> × <span class="hljs-number">100</span> = <span class="hljs-number">2</span>%

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-title function_">len</span>(df)):
    current_price = df.<span class="hljs-property">iloc</span>[i][<span class="hljs-string">"close"</span>]
    <span class="hljs-keyword">if</span> position > <span class="hljs-number">0</span>:
        high_since_buy = <span class="hljs-title function_">max</span>(high_since_buy, current_price)
        <span class="hljs-keyword">if</span> current_price &#x3C;= high_since_buy * (<span class="hljs-number">1</span> - trailing_stop_loss):
            cash = position * current_price * (<span class="hljs-number">1</span> - fee_percent)
            position = <span class="hljs-number">0</span>
            high_since_buy = <span class="hljs-number">0</span>
            <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_price}에서 트레일링 스탑 손실 활성화, 현금 {cash}으로 변경"</span>)
        elif current_price >= buy_price * (<span class="hljs-number">1</span> + take_profit):
            cash = position * current_price * (<span class="hljs-number">1</span> - fee_percent)
            position = <span class="hljs-number">0</span>
            high_since_buy = <span class="hljs-number">0</span>
            <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_price}에서 이익 실현, 현금 {cash}으로 변경"</span>)
        elif current_price &#x3C;= buy_price * (<span class="hljs-number">1</span> - stop_loss):
            cash = position * current_price * (<span class="hljs-number">1</span> - fee_percent)
            position = <span class="hljs-number">0</span>
            high_since_buy = <span class="hljs-number">0</span>
            <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_price}에서 손절, 현금 {cash}으로 변경"</span>)

    <span class="hljs-keyword">if</span> df.<span class="hljs-property">iloc</span>[i][<span class="hljs-string">"signal"</span>] == <span class="hljs-number">1</span> and df.<span class="hljs-property">iloc</span>[i - <span class="hljs-number">1</span>][<span class="hljs-string">"signal"</span>] != <span class="hljs-number">1</span>:
        <span class="hljs-keyword">if</span> cash > <span class="hljs-number">0</span>:
            buy_amount = cash * (<span class="hljs-number">1</span> - fee_percent)
            position = buy_amount / current_price
            cash = <span class="hljs-number">0</span>
            high_since_buy = current_price
            buy_price = current_price
            <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_price}에 매수, 포지션 {position}으로 변경"</span>)
    elif df.<span class="hljs-property">iloc</span>[i][<span class="hljs-string">"signal"</span>] == -<span class="hljs-number">1</span> and df.<span class="hljs-property">iloc</span>[i - <span class="hljs-number">1</span>][<span class="hljs-string">"signal"</span>] != -<span class="hljs-number">1</span>:
        <span class="hljs-keyword">if</span> position > <span class="hljs-number">0</span>:
            cash = position * current_price * (<span class="hljs-number">1</span> - fee_percent)
            position = <span class="hljs-number">0</span>
            high_since_buy = <span class="hljs-number">0</span>
            <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_price}에 매도, 현금 {cash}으로 변경"</span>)

final_value = cash <span class="hljs-keyword">if</span> position == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> position * df.<span class="hljs-property">iloc</span>[-<span class="hljs-number">1</span>][<span class="hljs-string">"close"</span>]
net_result = final_value - initial_investment

<span class="hljs-title function_">print</span>(f<span class="hljs-string">"최종 가치: {final_value:.2f}"</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"순 결과: {net_result:.2f} ({net_result / initial_investment * 100:.2f}%)"</span>)
</code></pre>
<p>이 결과가 나왔어요...</p>
<pre><code class="hljs language-js"><span class="hljs-number">64034.67</span>에 매수, 현재 포지션은 <span class="hljs-number">0.015600923687121368</span>
<span class="hljs-number">63988.53</span>에 매도, 현재 현금은 <span class="hljs-number">997.2818932076951</span>
<span class="hljs-number">64011.68</span>에 매수, 현재 포지션은 <span class="hljs-number">0.015564106602333939</span>
<span class="hljs-number">64431.99</span>에서 익절, 현재 현금은 <span class="hljs-number">1001.8235345995538</span>
<span class="hljs-number">64399.0</span>에 매수, 현재 포지션은 <span class="hljs-number">0.015540951118261995</span>
<span class="hljs-number">64606.62</span>에서 트레일링 스탑 로스, 현재 현금은 <span class="hljs-number">1003.0442750127916</span>
최종 가치: <span class="hljs-number">1003.04</span>
순 결과: <span class="hljs-number">3.04</span> (<span class="hljs-number">0.30</span>%)
</code></pre>
<h2>자동화: 봇 또는 웹소켓</h2>
<p>이상적으로 효과적으로 사용하려면 이 작업을 자동화하는 것이 좋습니다. 짧은 시간 내에 많은 분석과 업데이트를 다뤄야 하기 때문에 수동으로는 실수할 가능성이 매우 높습니다.</p>
<p>웹소켓을 통해 이 작업을 수행하는 방법을 알아보았어요. EODHD API는 암호화폐 웹소켓 API를 제공하며, 여기에서 해당 문서를 찾을 수 있어요.</p>
<p>시작할 수 있는 몇 가지 코드를 제공해보려고 해요…</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> websocket
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> signal
<span class="hljs-keyword">import</span> config <span class="hljs-keyword">as</span> cfg

data = {}
last_printed_minute = <span class="hljs-title class_">None</span>

def <span class="hljs-title function_">on_message</span>(ws, message):
    <span class="hljs-variable language_">global</span> last_printed_minute
    message_json = json.<span class="hljs-title function_">loads</span>(message)

    <span class="hljs-keyword">if</span> <span class="hljs-string">"t"</span> <span class="hljs-keyword">in</span> <span class="hljs-attr">message_json</span>:
        date_time = datetime.<span class="hljs-property">datetime</span>.<span class="hljs-title function_">utcfromtimestamp</span>(message_json[<span class="hljs-string">"t"</span>] / <span class="hljs-number">1000.0</span>)
        floored_datetime = date_time.<span class="hljs-title function_">replace</span>(second=<span class="hljs-number">0</span>, microsecond=<span class="hljs-number">0</span>)
        iso_format = floored_datetime.<span class="hljs-title function_">isoformat</span>()

        <span class="hljs-keyword">if</span> iso_format not <span class="hljs-keyword">in</span> <span class="hljs-attr">data</span>:
            data[iso_format] = {<span class="hljs-string">"sum"</span>: <span class="hljs-title function_">float</span>(message_json[<span class="hljs-string">"p"</span>]), <span class="hljs-string">"count"</span>: <span class="hljs-number">1</span>}
        <span class="hljs-attr">else</span>:
            data[iso_format][<span class="hljs-string">"sum"</span>] += <span class="hljs-title function_">float</span>(message_json[<span class="hljs-string">"p"</span>])
            data[iso_format][<span class="hljs-string">"count"</span>] += <span class="hljs-number">1</span>

        <span class="hljs-keyword">if</span> last_printed_minute != <span class="hljs-attr">iso_format</span>:
            <span class="hljs-keyword">if</span> last_printed_minute is not <span class="hljs-title class_">None</span>:
                avg_price = (
                    data[last_printed_minute][<span class="hljs-string">"sum"</span>]
                    / data[last_printed_minute][<span class="hljs-string">"count"</span>]
                )
                <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{last_printed_minute}: Average price: {avg_price}"</span>)
            last_printed_minute = iso_format

def <span class="hljs-title function_">on_error</span>(ws, error):
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"Error: "</span> + <span class="hljs-title function_">str</span>(error))

def <span class="hljs-title function_">on_close</span>(ws, close_status_code, close_msg):
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"WebSocket closed"</span>)

def <span class="hljs-title function_">on_open</span>(ws):
    def <span class="hljs-title function_">run</span>(*args):
        payload = {
            <span class="hljs-string">"action"</span>: <span class="hljs-string">"subscribe"</span>,
            <span class="hljs-string">"symbols"</span>: <span class="hljs-string">"BTC-USD"</span>,
        }
        ws.<span class="hljs-title function_">send</span>(json.<span class="hljs-title function_">dumps</span>(payload))

        # keep alive
        <span class="hljs-keyword">while</span> <span class="hljs-title class_">True</span>:
            time.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">50</span>)
            ws.<span class="hljs-title function_">send</span>(json.<span class="hljs-title function_">dumps</span>({<span class="hljs-string">"action"</span>: <span class="hljs-string">"keep_alive"</span>}))

    thread = threading.<span class="hljs-title class_">Thread</span>(target=run)
    thread.<span class="hljs-title function_">start</span>()

def <span class="hljs-title function_">on_signal</span>(signal, frame):
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"Signal received, closing WebSocket..."</span>)
    ws.<span class="hljs-title function_">close</span>()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    websocket.<span class="hljs-title function_">enableTrace</span>(<span class="hljs-title class_">False</span>)
    ws = websocket.<span class="hljs-title class_">WebSocketApp</span>(
        f<span class="hljs-string">"wss://ws.eodhistoricaldata.com/ws/crypto?api_token={cfg.API_KEY}"</span>,
        on_open=on_open,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
    )

    signal.<span class="hljs-title function_">signal</span>(signal.<span class="hljs-property">SIGINT</span>, on_signal)  # handle <span class="hljs-title class_">Ctrl</span>-C
    signal.<span class="hljs-title function_">signal</span>(signal.<span class="hljs-property">SIGTERM</span>, on_signal)  # handle kill commands

    ws.<span class="hljs-title function_">run_forever</span>()
</code></pre>
<p>이 코드는 웹소켓에 연결하고 BTC-USD 메시지를 구독할 거에요. 그런 다음 한 분 내 모든 데이터를 집계하고 해당 분의 평균 가격을 계산하며, ISO 형식의 분 타임스탬프에 연결할 거에요. 웹소켓 오픈을 유지하는 케이프 앨리브도 있으며, 스크립트가 종료되면 웹소켓을 정상적으로 중지할 거에요.</p>
<p>다음과 같이 출력이 나타납니다…</p>
<pre><code class="hljs language-js"><span class="hljs-number">2024</span>-<span class="hljs-number">04</span>-14<span class="hljs-attr">T20</span>:<span class="hljs-number">26</span>:<span class="hljs-number">00</span>: 평균 가격: <span class="hljs-number">64106.09294307696</span>
<span class="hljs-number">2024</span>-<span class="hljs-number">04</span>-14<span class="hljs-attr">T20</span>:<span class="hljs-number">27</span>:<span class="hljs-number">00</span>: 평균 가격: <span class="hljs-number">64108.821365536765</span>
<span class="hljs-number">2024</span>-<span class="hljs-number">04</span>-14<span class="hljs-attr">T20</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span>: 평균 가격: <span class="hljs-number">64137.0758961011</span>
<span class="hljs-number">2024</span>-<span class="hljs-number">04</span>-14<span class="hljs-attr">T20</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00</span>: 평균 가격: <span class="hljs-number">64134.83291021914</span>
<span class="hljs-number">2024</span>-<span class="hljs-number">04</span>-14<span class="hljs-attr">T20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span>: 평균 가격: <span class="hljs-number">64162.79143044936</span>
<span class="hljs-number">2024</span>-<span class="hljs-number">04</span>-14<span class="hljs-attr">T20</span>:<span class="hljs-number">31</span>:<span class="hljs-number">00</span>: 평균 가격: <span class="hljs-number">64212.15334335508</span>
</code></pre>
<p>제 스캘핑 코드에서는 EMA12 및 EMA26을 사용했습니다. 이는 EMA26을 계산하기 위해 웹소켓을 26분간 실행해야 하며, 이것이 매수/매도 신호를 계산하는 데 필요합니다.</p>
<p>여기서부터는 동일한 과정입니다. 웹소켓이 다음 분을 반환할 때마다 이동 평균을 다시 계산하고 결과에 대해 어떻게 처리할지 결정하면 됩니다.</p>
<h2>결론</h2>
<p>스캘핑 전략은 잠재력이 있습니다. 반드시 봇이나 웹소켓으로 프로세스를 자동화해야 합니다. 이 작업을 수동으로 하면 머리가 순식간에 회색이 될 것입니다. 또한 매우 낮은 수수료를 제공하거나 다른 요금 구조를 가진 거래소를 찾아야 합니다. Binance는 이 측면에서 꽤 좋은데, 그들의 수수료가 훨씬 낮습니다.</p>
<p>이 기사가 흥미로웠고 유용했기를 바랍니다. 계속해서 최신 정보를 받아보고 싶다면, 저를 팔로우하고 이메일 알림에 가입해주시기 바랍니다.</p>
<ul>
<li>
<p>Michael Whittle</p>
</li>
<li>
<p>만약 이 글이 마음에 드셨다면, 제 Medium 페이지를 팔로우해주세요.</p>
</li>
<li>
<p>더 많은 흥미로운 기사를 보고 싶다면, 제 출판물을 팔로우해주세요.</p>
</li>
<li>
<p>협업에 관심이 있으시다면, LinkedIn에서 연결해보세요.</p>
</li>
<li>
<p>제 글을 비롯한 Medium 작가들을 지원하고 싶다면, 여기에서 가입해주세요.</p>
</li>
<li>
<p>이 글에 박수를 보내주세요 :) ← 감사합니다!</p>
</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"암호화폐의 스캘핑 전략","description":"","date":"2024-05-05 15:06","slug":"2024-05-05-ScalpingStrategyforCryptocurrency","content":"\n\n## EODHD API를 사용하여 Bitcoin 데이터에 스캘핑 전략 적용하기\n\n![Scalping Bitcoin](/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_0.png)\n\n## 스캘핑 전략이란?\n\n이 개념은 듣기만큼 복잡하지 않습니다. 시장에 있다고 상상해보세요. 한 가격에 물건을 사고 빨리 약간 높은 가격에 다른 사람에게 판매할 기회를 발견합니다. 그것이 바로 거래에서의 스캘핑이 하는 일입니다. 시장의 작은 가격 움직임을 이용해 빠르고 소규모 수익을 창출하는 것입니다.\n\n\n\n이제 암호화폐 거래에 적용하는 것을 생각해보겠습니다. 특히 비트코인의 경우, 초고속 디지털 시장에서 이를 진행한다고 상상해보세요. 비트코인과 같은 암호화폐는 가격이 매우 빠르게 변동할 수 있으며 짧은 시간 내에도 꽤 크게 변할 수 있습니다. 이는 스캘핑에 적합합니다. 적은 양의 비트코인을 구매한 다음, 가격이 약간 상승하자마자 소량 이익을 내고 팔아야 합니다. 그리고 다시 그렇게 반복하며 하루에 여러 번 거래를 합니다.\n\n이를 제대로 수행하려면 짧은 간격으로 거래해야 합니다. 전형적인 스캘핑 접근 방식의 경우, 트레이더들은 주로 1분, 5분 또는 15분과 같은 짧은 시간프레임을 사용하는데, 이는 스캘핑이 매우 짧은 시간 내에 시장 움직임에서 이익을 얻으려는 것이므로입니다. 1분 시간프레임은 하루 거래 전체를 통해 다양한 소규모 가격 움직임을 포착할 수 있는 잠재력으로 매우 인기가 있습니다. 그러나 시간프레임의 선택은 트레이더의 특정 전략, 리스크 허용능력 및 거래되는 시장에 따라 다양할 수 있습니다. 이번 시연에서는 EODHD APIs에서 제공하는 1분 데이터를 사용하겠습니다.\n\n## 비트코인 스캘핑의 장점\n\n- 빠른 수익: 빠르고 민첩하다면 하루 내내 소규모 이익을 상당히 쌓을 수 있습니다. 개발한 암호화폐 거래 봇 PyCryptoBot은 이를 자동화하는 데 완벽합니다. 웹소켓을 사용할 수도 있습니다.\n- 즐거움: 꽤 즐겁습니다! 언제나 기회를 찾아 신속하게 결정을 내려야 합니다.\n- 레버리지 사용: 일부 트레이더들은 레버리지를 사용하여 거래력을 증폭시키고 소규모 가격 변동으로부터 이익을 증가시킬 수 있지만, 이는 일반적으로 암호화폐 거래소에는 적용되지 않습니다. 하지만 IG와 같은 플랫폼에서는 가능하지만 전문 계정이 필요하며 상당한 리스크가 있으므로 주의해야 합니다.\n\n\n\n## 비트코인 스캘핑의 단점\n\n- 고위험: 보상 가능성이 높을수록, 특히 레버리지를 사용하는 경우 손실도 증폭될 수 있습니다.\n- 수수료 부담: 매번 거래를 할 때마다 수수료가 발생합니다. 부주의하면 수익을 갉아먹거나 이긴 전략조차 패배로 변할 수 있습니다. 수수료는 전략 논리에 반영되어야 합니다.\n- 스트레스와 시간 소모: 여유롭지 않습니다. 항상 준비돼 있어야 하며, 상당히 집중력을 필요로 하는 거래 방식입니다.\n\n수수료에 대해 얘기해보죠. 이것은 계산에 꼭 고려해야 할 중요한 부분입니다. 거래를 할 때마다 거래소가 약간의 수수료를 차감합니다. 스캘핑이라면 자주 거래를 하기 때문에 작은 수수료가 많이 발생합니다. 주의를 기울이지 않으면 수익을 올리기 위해 움직여야 할 가격이 충분하지 않을 수도 있습니다. 이러면 움직이지 않고 제자리에 서 있기 위해 열심히 움직이고 있는 느낌이 들 수도 있습니다. 혹은 더 나빠진 경우, 돈을 잃을 수도 있습니다. 네, 수수료에 대해 자주 언급하지만 중요성을 강조하기에 그만이 없습니다.\n\n요약하자면, 비트코인 스캘핑은 심리적으로 힘든 것으로 여겨집니다. 변동성이 높아 흥미로울 뿐만 아니라 이윤을 얻을 수 있지만, 손실의 영향, 특히 거래 전략에 미치는 수수료의 영향을 잘 파악해야 합니다. 실제 돈이 걸린 아주 빠른 속도의 비디오 게임을 하는 것과 비슷합니다. 잘 짜여진 전략이 필요하며, 뚜렷한 통제력이 필요하며, 냉정함을 유지해야 합니다.\n\n\n\n## 전략 개요\n\n- 시간 단위: 1분 데이터.\n- 매수 신호: 빠른 SMA(5기간)가 느린 SMA(12기간)를 상향 돌파하면 상승 모멘텀이 나타납니다. 우리는 신호 캔들의 종가에 매수합니다.\n- 매도 신호: 빠른 SMA(5기간)가 느린 SMA(12기간)를 하향 돌파하면 하락 모멘텀이 나타납니다. 우리는 신호 캔들의 종가에 매도합니다.\n- 거래 수수료: 각 거래에서 차감되는 왕복(매수 및 매도) 거래 수수료를 가정합니다. Coinbase Advanced Trade의 0.6% 테이커 수수료를 가정합니다.\n- 재투자: 수수료를 고려한 이익을 모두 재투자합니다.\n- 실행: 전략은 신호에 이어 종가에서 실행됩니다.\n- 초기 투자: 백테스트는 정의된 초기 투자 금액으로 시작됩니다.\n\n## 데이터 검색 중...\n\nEODHD APIs에서 1분 단위 BTC-USD 데이터를 검색하겠습니다.\n\n\n\n```python\nimport pandas as pd\nfrom eodhd import APIClient\nimport config as cfg\n\napi = APIClient(cfg.API_KEY)\n\ndef get_ohlc_data():\n    df = api.get_historical_data(\"BTC-USD.CC\", \"1m\", results=120)\n    return df\n\nif __name__ == \"__main__\":\n    df = get_ohlc_data()\n\n    df[\"close\"] = pd.to_numeric(df[\"close\"], errors=\"coerce\")\n    df.dropna(subset=[\"close\"], inplace=True)\n    df[\"close\"].fillna(value=df[\"close\"].mean(), inplace=True)\n\n    print(df)\n```\n\n![Chart](/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_1.png)\n\n## 기본 전략 적용\n\n이것은 기본적인 스캘핑 전략의 예입니다. 세부 조정을 권장드리며, 이후에 이를 백테스트하는 방법을 보여드릴 예정이니 결과에 미치는 개선 사항을 평가할 수 있을 것입니다.\n  \n\n\n\n```js\nfast_sma_period = 5\nslow_sma_period = 12\ndf[\"fast_sma\"] = df[\"close\"].rolling(window=fast_sma_period).mean()\ndf[\"slow_sma\"] = df[\"close\"].rolling(window=slow_sma_period).mean()\n\ndf[\"signal\"] = 0  # default\ndf.loc[df[\"fast_sma\"] \u003e df[\"slow_sma\"], \"signal\"] = 1  # buy signal\ndf.loc[df[\"fast_sma\"] \u003c df[\"slow_sma\"], \"signal\"] = -1  # sell signal\n\nprint(df)\n```\n\n![Image for Strategy](/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_2.png)\n\n## 전략 백테스팅\n\n```js\nfee_percent = 0.006  # 0.6%\n\ninitial_investment = 1000.0\ncash = initial_investment\nposition = 0  # bitcoin balance\n\nfor i in range(1, len(df)):\n    if df.iloc[i][\"signal\"] == 1 and df.iloc[i - 1][\"signal\"] == -1:\n        # buy, assuming all cash is used\n        buy_amount = cash * (1 - fee_percent)  # deduct fee\n        position = buy_amount / df.iloc[i][\"close\"]\n        cash = 0\n\n    elif df.iloc[i][\"signal\"] == -1 and df.iloc[i - 1][\"signal\"] == 1:\n        # sell, converting position to cash\n        cash = position * df.iloc[i][\"close\"] * (1 - fee_percent)  # deduct fee\n        position = 0\n\nfinal_value = cash if position == 0 else position * df.iloc[-1][\"close\"]\nnet_result = final_value - initial_investment\n\nprint(f\"최종 가치: {final_value:.2f}\")\nprint(f\"순수익: {net_result:.2f} ({net_result / initial_investment * 100:.2f}%)\")\n```\n\n\n\n![Scalping Strategy for Cryptocurrency](/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_3.png)\n\n요 정보는 120분 동안 데이터를 사용할 때 전략이 손해를 낼 것을 보여줍니다. 시작 투자금인 £1000은 120분 후에 £914.38로 감소할 것입니다. 순 결과로는 -£85.62 (-8.56%)가 됩니다. 이것은 크게 놀랍지 않습니다. Coinbase의 수수료가 매우 높기 때문에 전략에 수수료가 포함되어 있습니다.\n\n수수료를 제외하면 긍정적인 결과가 나옵니다.\n\n```js\n# fee_percent = 0.006  # 0.6%\nfee_percent = 0.0  # 0.0%\n```\n\n\n\n![Scalping Strategy for Cryptocurrency](/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_4.png)\n\n0.08% in 2 hours.\n\n## Trailing Stop Loss and Take-Profit\n\nA potential way to improve on this while maintaining the inclusion of fees is to implement a trailing stop loss and/or a take-profit mechanism. The take-profit is often 3x the stop loss.\n\n\n\n저는 이것을 실험해 보았고 긍정적인 결과를 얻었지만 수수료를 0.6%에서 0.1%로 낮춰야 했습니다. 비트코인과 같이 변동성이 큰 자산에서 이보다 높은 수수료로는 1분 간격으로는 일관성이 없어 보입니다.\n\n또한 암호화폐와 함께 작업할 때 더 반응성이 좋은 EMA(Exponential Moving Average)로 SMA(Simple Moving Average) 교차선을 교체했습니다.\n\n내 코드는 이렇게 생겼어요:\n\n```js\nfast_ma_period = 12\nslow_ma_period = 26\n# df[\"fast_ma\"] = df[\"close\"].rolling(window=fast_ma_period).mean()\n# df[\"slow_ma\"] = df[\"close\"].rolling(window=slow_ma_period).mean()\ndf[\"fast_ma\"] = df[\"close\"].ewm(span=fast_ma_period, adjust=False).mean()\ndf[\"slow_ma\"] = df[\"close\"].ewm(span=slow_ma_period, adjust=False).mean()\n\ndf[\"signal\"] = 0  # 기본값 설정\ndf.loc[df[\"fast_ma\"] \u003e df[\"slow_ma\"], \"signal\"] = 1  # 매수 신호\ndf.loc[df[\"fast_ma\"] \u003c df[\"slow_ma\"], \"signal\"] = -1  # 매도 신호\n\nfee_percent = 0.001  # 0.1%\n\ninitial_investment = 1000.0\ncash = initial_investment\nposition = 0\nhigh_since_buy = 0\nbuy_price = 0\n\ntrailing_stop_loss = 0.002  # 예: 0.002 × 100 = 0.2%\ntake_profit = trailing_stop_loss * 3  # 3배 트레일링 스탑 손실\nstop_loss = 0.02  # 예: 0.02 × 100 = 2%\n\nfor i in range(1, len(df)):\n    current_price = df.iloc[i][\"close\"]\n    if position \u003e 0:\n        high_since_buy = max(high_since_buy, current_price)\n        if current_price \u003c= high_since_buy * (1 - trailing_stop_loss):\n            cash = position * current_price * (1 - fee_percent)\n            position = 0\n            high_since_buy = 0\n            print(f\"{current_price}에서 트레일링 스탑 손실 활성화, 현금 {cash}으로 변경\")\n        elif current_price \u003e= buy_price * (1 + take_profit):\n            cash = position * current_price * (1 - fee_percent)\n            position = 0\n            high_since_buy = 0\n            print(f\"{current_price}에서 이익 실현, 현금 {cash}으로 변경\")\n        elif current_price \u003c= buy_price * (1 - stop_loss):\n            cash = position * current_price * (1 - fee_percent)\n            position = 0\n            high_since_buy = 0\n            print(f\"{current_price}에서 손절, 현금 {cash}으로 변경\")\n\n    if df.iloc[i][\"signal\"] == 1 and df.iloc[i - 1][\"signal\"] != 1:\n        if cash \u003e 0:\n            buy_amount = cash * (1 - fee_percent)\n            position = buy_amount / current_price\n            cash = 0\n            high_since_buy = current_price\n            buy_price = current_price\n            print(f\"{current_price}에 매수, 포지션 {position}으로 변경\")\n    elif df.iloc[i][\"signal\"] == -1 and df.iloc[i - 1][\"signal\"] != -1:\n        if position \u003e 0:\n            cash = position * current_price * (1 - fee_percent)\n            position = 0\n            high_since_buy = 0\n            print(f\"{current_price}에 매도, 현금 {cash}으로 변경\")\n\nfinal_value = cash if position == 0 else position * df.iloc[-1][\"close\"]\nnet_result = final_value - initial_investment\n\nprint(f\"최종 가치: {final_value:.2f}\")\nprint(f\"순 결과: {net_result:.2f} ({net_result / initial_investment * 100:.2f}%)\")\n```\n\n\n\n이 결과가 나왔어요...\n\n```js\n64034.67에 매수, 현재 포지션은 0.015600923687121368\n63988.53에 매도, 현재 현금은 997.2818932076951\n64011.68에 매수, 현재 포지션은 0.015564106602333939\n64431.99에서 익절, 현재 현금은 1001.8235345995538\n64399.0에 매수, 현재 포지션은 0.015540951118261995\n64606.62에서 트레일링 스탑 로스, 현재 현금은 1003.0442750127916\n최종 가치: 1003.04\n순 결과: 3.04 (0.30%)\n```\n\n## 자동화: 봇 또는 웹소켓\n\n이상적으로 효과적으로 사용하려면 이 작업을 자동화하는 것이 좋습니다. 짧은 시간 내에 많은 분석과 업데이트를 다뤄야 하기 때문에 수동으로는 실수할 가능성이 매우 높습니다.\n\n\n\n웹소켓을 통해 이 작업을 수행하는 방법을 알아보았어요. EODHD API는 암호화폐 웹소켓 API를 제공하며, 여기에서 해당 문서를 찾을 수 있어요.\n\n시작할 수 있는 몇 가지 코드를 제공해보려고 해요…\n\n```javascript\nimport datetime\nimport websocket\nimport json\nimport time\nimport threading\nimport signal\nimport config as cfg\n\ndata = {}\nlast_printed_minute = None\n\ndef on_message(ws, message):\n    global last_printed_minute\n    message_json = json.loads(message)\n\n    if \"t\" in message_json:\n        date_time = datetime.datetime.utcfromtimestamp(message_json[\"t\"] / 1000.0)\n        floored_datetime = date_time.replace(second=0, microsecond=0)\n        iso_format = floored_datetime.isoformat()\n\n        if iso_format not in data:\n            data[iso_format] = {\"sum\": float(message_json[\"p\"]), \"count\": 1}\n        else:\n            data[iso_format][\"sum\"] += float(message_json[\"p\"])\n            data[iso_format][\"count\"] += 1\n\n        if last_printed_minute != iso_format:\n            if last_printed_minute is not None:\n                avg_price = (\n                    data[last_printed_minute][\"sum\"]\n                    / data[last_printed_minute][\"count\"]\n                )\n                print(f\"{last_printed_minute}: Average price: {avg_price}\")\n            last_printed_minute = iso_format\n\ndef on_error(ws, error):\n    print(\"Error: \" + str(error))\n\ndef on_close(ws, close_status_code, close_msg):\n    print(\"WebSocket closed\")\n\ndef on_open(ws):\n    def run(*args):\n        payload = {\n            \"action\": \"subscribe\",\n            \"symbols\": \"BTC-USD\",\n        }\n        ws.send(json.dumps(payload))\n\n        # keep alive\n        while True:\n            time.sleep(50)\n            ws.send(json.dumps({\"action\": \"keep_alive\"}))\n\n    thread = threading.Thread(target=run)\n    thread.start()\n\ndef on_signal(signal, frame):\n    print(\"Signal received, closing WebSocket...\")\n    ws.close()\n\nif __name__ == \"__main__\":\n    websocket.enableTrace(False)\n    ws = websocket.WebSocketApp(\n        f\"wss://ws.eodhistoricaldata.com/ws/crypto?api_token={cfg.API_KEY}\",\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n    )\n\n    signal.signal(signal.SIGINT, on_signal)  # handle Ctrl-C\n    signal.signal(signal.SIGTERM, on_signal)  # handle kill commands\n\n    ws.run_forever()\n```\n\n이 코드는 웹소켓에 연결하고 BTC-USD 메시지를 구독할 거에요. 그런 다음 한 분 내 모든 데이터를 집계하고 해당 분의 평균 가격을 계산하며, ISO 형식의 분 타임스탬프에 연결할 거에요. 웹소켓 오픈을 유지하는 케이프 앨리브도 있으며, 스크립트가 종료되면 웹소켓을 정상적으로 중지할 거에요.\n\n\n\n다음과 같이 출력이 나타납니다…\n\n```js\n2024-04-14T20:26:00: 평균 가격: 64106.09294307696\n2024-04-14T20:27:00: 평균 가격: 64108.821365536765\n2024-04-14T20:28:00: 평균 가격: 64137.0758961011\n2024-04-14T20:29:00: 평균 가격: 64134.83291021914\n2024-04-14T20:30:00: 평균 가격: 64162.79143044936\n2024-04-14T20:31:00: 평균 가격: 64212.15334335508\n```\n\n제 스캘핑 코드에서는 EMA12 및 EMA26을 사용했습니다. 이는 EMA26을 계산하기 위해 웹소켓을 26분간 실행해야 하며, 이것이 매수/매도 신호를 계산하는 데 필요합니다.\n\n여기서부터는 동일한 과정입니다. 웹소켓이 다음 분을 반환할 때마다 이동 평균을 다시 계산하고 결과에 대해 어떻게 처리할지 결정하면 됩니다.\n\n\n\n\n## 결론\n\n스캘핑 전략은 잠재력이 있습니다. 반드시 봇이나 웹소켓으로 프로세스를 자동화해야 합니다. 이 작업을 수동으로 하면 머리가 순식간에 회색이 될 것입니다. 또한 매우 낮은 수수료를 제공하거나 다른 요금 구조를 가진 거래소를 찾아야 합니다. Binance는 이 측면에서 꽤 좋은데, 그들의 수수료가 훨씬 낮습니다.\n\n이 기사가 흥미로웠고 유용했기를 바랍니다. 계속해서 최신 정보를 받아보고 싶다면, 저를 팔로우하고 이메일 알림에 가입해주시기 바랍니다.\n\n- Michael Whittle\n\n\n\n- 만약 이 글이 마음에 드셨다면, 제 Medium 페이지를 팔로우해주세요.\n- 더 많은 흥미로운 기사를 보고 싶다면, 제 출판물을 팔로우해주세요.\n- 협업에 관심이 있으시다면, LinkedIn에서 연결해보세요.\n- 제 글을 비롯한 Medium 작가들을 지원하고 싶다면, 여기에서 가입해주세요.\n- 이 글에 박수를 보내주세요 :) ← 감사합니다!","ogImage":{"url":"/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_0.png"},"coverImage":"/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eEODHD API를 사용하여 Bitcoin 데이터에 스캘핑 전략 적용하기\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_0.png\" alt=\"Scalping Bitcoin\"\u003e\u003c/p\u003e\n\u003ch2\u003e스캘핑 전략이란?\u003c/h2\u003e\n\u003cp\u003e이 개념은 듣기만큼 복잡하지 않습니다. 시장에 있다고 상상해보세요. 한 가격에 물건을 사고 빨리 약간 높은 가격에 다른 사람에게 판매할 기회를 발견합니다. 그것이 바로 거래에서의 스캘핑이 하는 일입니다. 시장의 작은 가격 움직임을 이용해 빠르고 소규모 수익을 창출하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이제 암호화폐 거래에 적용하는 것을 생각해보겠습니다. 특히 비트코인의 경우, 초고속 디지털 시장에서 이를 진행한다고 상상해보세요. 비트코인과 같은 암호화폐는 가격이 매우 빠르게 변동할 수 있으며 짧은 시간 내에도 꽤 크게 변할 수 있습니다. 이는 스캘핑에 적합합니다. 적은 양의 비트코인을 구매한 다음, 가격이 약간 상승하자마자 소량 이익을 내고 팔아야 합니다. 그리고 다시 그렇게 반복하며 하루에 여러 번 거래를 합니다.\u003c/p\u003e\n\u003cp\u003e이를 제대로 수행하려면 짧은 간격으로 거래해야 합니다. 전형적인 스캘핑 접근 방식의 경우, 트레이더들은 주로 1분, 5분 또는 15분과 같은 짧은 시간프레임을 사용하는데, 이는 스캘핑이 매우 짧은 시간 내에 시장 움직임에서 이익을 얻으려는 것이므로입니다. 1분 시간프레임은 하루 거래 전체를 통해 다양한 소규모 가격 움직임을 포착할 수 있는 잠재력으로 매우 인기가 있습니다. 그러나 시간프레임의 선택은 트레이더의 특정 전략, 리스크 허용능력 및 거래되는 시장에 따라 다양할 수 있습니다. 이번 시연에서는 EODHD APIs에서 제공하는 1분 데이터를 사용하겠습니다.\u003c/p\u003e\n\u003ch2\u003e비트코인 스캘핑의 장점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e빠른 수익: 빠르고 민첩하다면 하루 내내 소규모 이익을 상당히 쌓을 수 있습니다. 개발한 암호화폐 거래 봇 PyCryptoBot은 이를 자동화하는 데 완벽합니다. 웹소켓을 사용할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e즐거움: 꽤 즐겁습니다! 언제나 기회를 찾아 신속하게 결정을 내려야 합니다.\u003c/li\u003e\n\u003cli\u003e레버리지 사용: 일부 트레이더들은 레버리지를 사용하여 거래력을 증폭시키고 소규모 가격 변동으로부터 이익을 증가시킬 수 있지만, 이는 일반적으로 암호화폐 거래소에는 적용되지 않습니다. 하지만 IG와 같은 플랫폼에서는 가능하지만 전문 계정이 필요하며 상당한 리스크가 있으므로 주의해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e비트코인 스캘핑의 단점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e고위험: 보상 가능성이 높을수록, 특히 레버리지를 사용하는 경우 손실도 증폭될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e수수료 부담: 매번 거래를 할 때마다 수수료가 발생합니다. 부주의하면 수익을 갉아먹거나 이긴 전략조차 패배로 변할 수 있습니다. 수수료는 전략 논리에 반영되어야 합니다.\u003c/li\u003e\n\u003cli\u003e스트레스와 시간 소모: 여유롭지 않습니다. 항상 준비돼 있어야 하며, 상당히 집중력을 필요로 하는 거래 방식입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e수수료에 대해 얘기해보죠. 이것은 계산에 꼭 고려해야 할 중요한 부분입니다. 거래를 할 때마다 거래소가 약간의 수수료를 차감합니다. 스캘핑이라면 자주 거래를 하기 때문에 작은 수수료가 많이 발생합니다. 주의를 기울이지 않으면 수익을 올리기 위해 움직여야 할 가격이 충분하지 않을 수도 있습니다. 이러면 움직이지 않고 제자리에 서 있기 위해 열심히 움직이고 있는 느낌이 들 수도 있습니다. 혹은 더 나빠진 경우, 돈을 잃을 수도 있습니다. 네, 수수료에 대해 자주 언급하지만 중요성을 강조하기에 그만이 없습니다.\u003c/p\u003e\n\u003cp\u003e요약하자면, 비트코인 스캘핑은 심리적으로 힘든 것으로 여겨집니다. 변동성이 높아 흥미로울 뿐만 아니라 이윤을 얻을 수 있지만, 손실의 영향, 특히 거래 전략에 미치는 수수료의 영향을 잘 파악해야 합니다. 실제 돈이 걸린 아주 빠른 속도의 비디오 게임을 하는 것과 비슷합니다. 잘 짜여진 전략이 필요하며, 뚜렷한 통제력이 필요하며, 냉정함을 유지해야 합니다.\u003c/p\u003e\n\u003ch2\u003e전략 개요\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e시간 단위: 1분 데이터.\u003c/li\u003e\n\u003cli\u003e매수 신호: 빠른 SMA(5기간)가 느린 SMA(12기간)를 상향 돌파하면 상승 모멘텀이 나타납니다. 우리는 신호 캔들의 종가에 매수합니다.\u003c/li\u003e\n\u003cli\u003e매도 신호: 빠른 SMA(5기간)가 느린 SMA(12기간)를 하향 돌파하면 하락 모멘텀이 나타납니다. 우리는 신호 캔들의 종가에 매도합니다.\u003c/li\u003e\n\u003cli\u003e거래 수수료: 각 거래에서 차감되는 왕복(매수 및 매도) 거래 수수료를 가정합니다. Coinbase Advanced Trade의 0.6% 테이커 수수료를 가정합니다.\u003c/li\u003e\n\u003cli\u003e재투자: 수수료를 고려한 이익을 모두 재투자합니다.\u003c/li\u003e\n\u003cli\u003e실행: 전략은 신호에 이어 종가에서 실행됩니다.\u003c/li\u003e\n\u003cli\u003e초기 투자: 백테스트는 정의된 초기 투자 금액으로 시작됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e데이터 검색 중...\u003c/h2\u003e\n\u003cp\u003eEODHD APIs에서 1분 단위 BTC-USD 데이터를 검색하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e eodhd \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e APIClient\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e config \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cfg\n\napi = APIClient(cfg.API_KEY)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_ohlc_data\u003c/span\u003e():\n    df = api.get_historical_data(\u003cspan class=\"hljs-string\"\u003e\"BTC-USD.CC\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"1m\"\u003c/span\u003e, results=\u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e df\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    df = get_ohlc_data()\n\n    df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e] = pd.to_numeric(df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e], errors=\u003cspan class=\"hljs-string\"\u003e\"coerce\"\u003c/span\u003e)\n    df.dropna(subset=[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e], inplace=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n    df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].fillna(value=df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].mean(), inplace=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(df)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_1.png\" alt=\"Chart\"\u003e\u003c/p\u003e\n\u003ch2\u003e기본 전략 적용\u003c/h2\u003e\n\u003cp\u003e이것은 기본적인 스캘핑 전략의 예입니다. 세부 조정을 권장드리며, 이후에 이를 백테스트하는 방법을 보여드릴 예정이니 결과에 미치는 개선 사항을 평가할 수 있을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efast_sma_period = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\nslow_sma_period = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\ndf[\u003cspan class=\"hljs-string\"\u003e\"fast_sma\"\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=fast_sma_period).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\ndf[\u003cspan class=\"hljs-string\"\u003e\"slow_sma\"\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=slow_sma_period).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\n\ndf[\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e  # \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e\ndf.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[df[\u003cspan class=\"hljs-string\"\u003e\"fast_sma\"\u003c/span\u003e] \u003e df[\u003cspan class=\"hljs-string\"\u003e\"slow_sma\"\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e  # buy signal\ndf.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[df[\u003cspan class=\"hljs-string\"\u003e\"fast_sma\"\u003c/span\u003e] \u0026#x3C; df[\u003cspan class=\"hljs-string\"\u003e\"slow_sma\"\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] = -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e  # sell signal\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(df)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_2.png\" alt=\"Image for Strategy\"\u003e\u003c/p\u003e\n\u003ch2\u003e전략 백테스팅\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efee_percent = \u003cspan class=\"hljs-number\"\u003e0.006\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e0.6\u003c/span\u003e%\n\ninitial_investment = \u003cspan class=\"hljs-number\"\u003e1000.0\u003c/span\u003e\ncash = initial_investment\nposition = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e  # bitcoin balance\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(df)):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e and df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] == -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n        # buy, assuming all cash is used\n        buy_amount = cash * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - fee_percent)  # deduct fee\n        position = buy_amount / df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i][\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e]\n        cash = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n    elif df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] == -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e and df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n        # sell, converting position to cash\n        cash = position * df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i][\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e] * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - fee_percent)  # deduct fee\n        position = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\nfinal_value = cash \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e position == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e position * df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e]\nnet_result = final_value - initial_investment\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"최종 가치: {final_value:.2f}\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"순수익: {net_result:.2f} ({net_result / initial_investment * 100:.2f}%)\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_3.png\" alt=\"Scalping Strategy for Cryptocurrency\"\u003e\u003c/p\u003e\n\u003cp\u003e요 정보는 120분 동안 데이터를 사용할 때 전략이 손해를 낼 것을 보여줍니다. 시작 투자금인 £1000은 120분 후에 £914.38로 감소할 것입니다. 순 결과로는 -£85.62 (-8.56%)가 됩니다. 이것은 크게 놀랍지 않습니다. Coinbase의 수수료가 매우 높기 때문에 전략에 수수료가 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e수수료를 제외하면 긍정적인 결과가 나옵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# fee_percent = \u003cspan class=\"hljs-number\"\u003e0.006\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e0.6\u003c/span\u003e%\nfee_percent = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e%\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-05-ScalpingStrategyforCryptocurrency_4.png\" alt=\"Scalping Strategy for Cryptocurrency\"\u003e\u003c/p\u003e\n\u003cp\u003e0.08% in 2 hours.\u003c/p\u003e\n\u003ch2\u003eTrailing Stop Loss and Take-Profit\u003c/h2\u003e\n\u003cp\u003eA potential way to improve on this while maintaining the inclusion of fees is to implement a trailing stop loss and/or a take-profit mechanism. The take-profit is often 3x the stop loss.\u003c/p\u003e\n\u003cp\u003e저는 이것을 실험해 보았고 긍정적인 결과를 얻었지만 수수료를 0.6%에서 0.1%로 낮춰야 했습니다. 비트코인과 같이 변동성이 큰 자산에서 이보다 높은 수수료로는 1분 간격으로는 일관성이 없어 보입니다.\u003c/p\u003e\n\u003cp\u003e또한 암호화폐와 함께 작업할 때 더 반응성이 좋은 EMA(Exponential Moving Average)로 SMA(Simple Moving Average) 교차선을 교체했습니다.\u003c/p\u003e\n\u003cp\u003e내 코드는 이렇게 생겼어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efast_ma_period = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nslow_ma_period = \u003cspan class=\"hljs-number\"\u003e26\u003c/span\u003e\n# df[\u003cspan class=\"hljs-string\"\u003e\"fast_ma\"\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=fast_ma_period).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\n# df[\u003cspan class=\"hljs-string\"\u003e\"slow_ma\"\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=slow_ma_period).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\ndf[\u003cspan class=\"hljs-string\"\u003e\"fast_ma\"\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eewm\u003c/span\u003e(span=fast_ma_period, adjust=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\ndf[\u003cspan class=\"hljs-string\"\u003e\"slow_ma\"\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eewm\u003c/span\u003e(span=slow_ma_period, adjust=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\n\ndf[\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e  # 기본값 설정\ndf.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[df[\u003cspan class=\"hljs-string\"\u003e\"fast_ma\"\u003c/span\u003e] \u003e df[\u003cspan class=\"hljs-string\"\u003e\"slow_ma\"\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e  # 매수 신호\ndf.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[df[\u003cspan class=\"hljs-string\"\u003e\"fast_ma\"\u003c/span\u003e] \u0026#x3C; df[\u003cspan class=\"hljs-string\"\u003e\"slow_ma\"\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] = -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e  # 매도 신호\n\nfee_percent = \u003cspan class=\"hljs-number\"\u003e0.001\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e%\n\ninitial_investment = \u003cspan class=\"hljs-number\"\u003e1000.0\u003c/span\u003e\ncash = initial_investment\nposition = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nhigh_since_buy = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nbuy_price = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\ntrailing_stop_loss = \u003cspan class=\"hljs-number\"\u003e0.002\u003c/span\u003e  # 예: \u003cspan class=\"hljs-number\"\u003e0.002\u003c/span\u003e × \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e%\ntake_profit = trailing_stop_loss * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e배 트레일링 스탑 손실\nstop_loss = \u003cspan class=\"hljs-number\"\u003e0.02\u003c/span\u003e  # 예: \u003cspan class=\"hljs-number\"\u003e0.02\u003c/span\u003e × \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e%\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(df)):\n    current_price = df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i][\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e]\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e position \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        high_since_buy = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(high_since_buy, current_price)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e current_price \u0026#x3C;= high_since_buy * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - trailing_stop_loss):\n            cash = position * current_price * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - fee_percent)\n            position = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            high_since_buy = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_price}에서 트레일링 스탑 손실 활성화, 현금 {cash}으로 변경\"\u003c/span\u003e)\n        elif current_price \u003e= buy_price * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e + take_profit):\n            cash = position * current_price * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - fee_percent)\n            position = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            high_since_buy = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_price}에서 이익 실현, 현금 {cash}으로 변경\"\u003c/span\u003e)\n        elif current_price \u0026#x3C;= buy_price * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - stop_loss):\n            cash = position * current_price * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - fee_percent)\n            position = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            high_since_buy = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_price}에서 손절, 현금 {cash}으로 변경\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e and df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] != \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cash \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            buy_amount = cash * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - fee_percent)\n            position = buy_amount / current_price\n            cash = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            high_since_buy = current_price\n            buy_price = current_price\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_price}에 매수, 포지션 {position}으로 변경\"\u003c/span\u003e)\n    elif df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] == -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e and df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"signal\"\u003c/span\u003e] != -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e position \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            cash = position * current_price * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - fee_percent)\n            position = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            high_since_buy = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_price}에 매도, 현금 {cash}으로 변경\"\u003c/span\u003e)\n\nfinal_value = cash \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e position == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e position * df.\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"close\"\u003c/span\u003e]\nnet_result = final_value - initial_investment\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"최종 가치: {final_value:.2f}\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"순 결과: {net_result:.2f} ({net_result / initial_investment * 100:.2f}%)\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 결과가 나왔어요...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e64034.67\u003c/span\u003e에 매수, 현재 포지션은 \u003cspan class=\"hljs-number\"\u003e0.015600923687121368\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e63988.53\u003c/span\u003e에 매도, 현재 현금은 \u003cspan class=\"hljs-number\"\u003e997.2818932076951\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e64011.68\u003c/span\u003e에 매수, 현재 포지션은 \u003cspan class=\"hljs-number\"\u003e0.015564106602333939\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e64431.99\u003c/span\u003e에서 익절, 현재 현금은 \u003cspan class=\"hljs-number\"\u003e1001.8235345995538\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e64399.0\u003c/span\u003e에 매수, 현재 포지션은 \u003cspan class=\"hljs-number\"\u003e0.015540951118261995\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e64606.62\u003c/span\u003e에서 트레일링 스탑 로스, 현재 현금은 \u003cspan class=\"hljs-number\"\u003e1003.0442750127916\u003c/span\u003e\n최종 가치: \u003cspan class=\"hljs-number\"\u003e1003.04\u003c/span\u003e\n순 결과: \u003cspan class=\"hljs-number\"\u003e3.04\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e0.30\u003c/span\u003e%)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e자동화: 봇 또는 웹소켓\u003c/h2\u003e\n\u003cp\u003e이상적으로 효과적으로 사용하려면 이 작업을 자동화하는 것이 좋습니다. 짧은 시간 내에 많은 분석과 업데이트를 다뤄야 하기 때문에 수동으로는 실수할 가능성이 매우 높습니다.\u003c/p\u003e\n\u003cp\u003e웹소켓을 통해 이 작업을 수행하는 방법을 알아보았어요. EODHD API는 암호화폐 웹소켓 API를 제공하며, 여기에서 해당 문서를 찾을 수 있어요.\u003c/p\u003e\n\u003cp\u003e시작할 수 있는 몇 가지 코드를 제공해보려고 해요…\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e websocket\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e threading\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e signal\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e config \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cfg\n\ndata = {}\nlast_printed_minute = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_message\u003c/span\u003e(ws, message):\n    \u003cspan class=\"hljs-variable language_\"\u003eglobal\u003c/span\u003e last_printed_minute\n    message_json = json.\u003cspan class=\"hljs-title function_\"\u003eloads\u003c/span\u003e(message)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"t\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage_json\u003c/span\u003e:\n        date_time = datetime.\u003cspan class=\"hljs-property\"\u003edatetime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eutcfromtimestamp\u003c/span\u003e(message_json[\u003cspan class=\"hljs-string\"\u003e\"t\"\u003c/span\u003e] / \u003cspan class=\"hljs-number\"\u003e1000.0\u003c/span\u003e)\n        floored_datetime = date_time.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(second=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, microsecond=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        iso_format = floored_datetime.\u003cspan class=\"hljs-title function_\"\u003eisoformat\u003c/span\u003e()\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e iso_format not \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e:\n            data[iso_format] = {\u003cspan class=\"hljs-string\"\u003e\"sum\"\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003efloat\u003c/span\u003e(message_json[\u003cspan class=\"hljs-string\"\u003e\"p\"\u003c/span\u003e]), \u003cspan class=\"hljs-string\"\u003e\"count\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            data[iso_format][\u003cspan class=\"hljs-string\"\u003e\"sum\"\u003c/span\u003e] += \u003cspan class=\"hljs-title function_\"\u003efloat\u003c/span\u003e(message_json[\u003cspan class=\"hljs-string\"\u003e\"p\"\u003c/span\u003e])\n            data[iso_format][\u003cspan class=\"hljs-string\"\u003e\"count\"\u003c/span\u003e] += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e last_printed_minute != \u003cspan class=\"hljs-attr\"\u003eiso_format\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e last_printed_minute is not \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n                avg_price = (\n                    data[last_printed_minute][\u003cspan class=\"hljs-string\"\u003e\"sum\"\u003c/span\u003e]\n                    / data[last_printed_minute][\u003cspan class=\"hljs-string\"\u003e\"count\"\u003c/span\u003e]\n                )\n                \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{last_printed_minute}: Average price: {avg_price}\"\u003c/span\u003e)\n            last_printed_minute = iso_format\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_error\u003c/span\u003e(ws, error):\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Error: \"\u003c/span\u003e + \u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(error))\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_close\u003c/span\u003e(ws, close_status_code, close_msg):\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"WebSocket closed\"\u003c/span\u003e)\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_open\u003c/span\u003e(ws):\n    def \u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(*args):\n        payload = {\n            \u003cspan class=\"hljs-string\"\u003e\"action\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"subscribe\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"symbols\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"BTC-USD\"\u003c/span\u003e,\n        }\n        ws.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e(payload))\n\n        # keep alive\n        \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e:\n            time.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\n            ws.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"action\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"keep_alive\"\u003c/span\u003e}))\n\n    thread = threading.\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(target=run)\n    thread.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e()\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_signal\u003c/span\u003e(signal, frame):\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Signal received, closing WebSocket...\"\u003c/span\u003e)\n    ws.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    websocket.\u003cspan class=\"hljs-title function_\"\u003eenableTrace\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n    ws = websocket.\u003cspan class=\"hljs-title class_\"\u003eWebSocketApp\u003c/span\u003e(\n        f\u003cspan class=\"hljs-string\"\u003e\"wss://ws.eodhistoricaldata.com/ws/crypto?api_token={cfg.API_KEY}\"\u003c/span\u003e,\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n    )\n\n    signal.\u003cspan class=\"hljs-title function_\"\u003esignal\u003c/span\u003e(signal.\u003cspan class=\"hljs-property\"\u003eSIGINT\u003c/span\u003e, on_signal)  # handle \u003cspan class=\"hljs-title class_\"\u003eCtrl\u003c/span\u003e-C\n    signal.\u003cspan class=\"hljs-title function_\"\u003esignal\u003c/span\u003e(signal.\u003cspan class=\"hljs-property\"\u003eSIGTERM\u003c/span\u003e, on_signal)  # handle kill commands\n\n    ws.\u003cspan class=\"hljs-title function_\"\u003erun_forever\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 웹소켓에 연결하고 BTC-USD 메시지를 구독할 거에요. 그런 다음 한 분 내 모든 데이터를 집계하고 해당 분의 평균 가격을 계산하며, ISO 형식의 분 타임스탬프에 연결할 거에요. 웹소켓 오픈을 유지하는 케이프 앨리브도 있으며, 스크립트가 종료되면 웹소켓을 정상적으로 중지할 거에요.\u003c/p\u003e\n\u003cp\u003e다음과 같이 출력이 나타납니다…\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e-14\u003cspan class=\"hljs-attr\"\u003eT20\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e26\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e: 평균 가격: \u003cspan class=\"hljs-number\"\u003e64106.09294307696\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e-14\u003cspan class=\"hljs-attr\"\u003eT20\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e: 평균 가격: \u003cspan class=\"hljs-number\"\u003e64108.821365536765\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e-14\u003cspan class=\"hljs-attr\"\u003eT20\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e28\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e: 평균 가격: \u003cspan class=\"hljs-number\"\u003e64137.0758961011\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e-14\u003cspan class=\"hljs-attr\"\u003eT20\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e29\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e: 평균 가격: \u003cspan class=\"hljs-number\"\u003e64134.83291021914\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e-14\u003cspan class=\"hljs-attr\"\u003eT20\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e: 평균 가격: \u003cspan class=\"hljs-number\"\u003e64162.79143044936\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e-14\u003cspan class=\"hljs-attr\"\u003eT20\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e: 평균 가격: \u003cspan class=\"hljs-number\"\u003e64212.15334335508\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제 스캘핑 코드에서는 EMA12 및 EMA26을 사용했습니다. 이는 EMA26을 계산하기 위해 웹소켓을 26분간 실행해야 하며, 이것이 매수/매도 신호를 계산하는 데 필요합니다.\u003c/p\u003e\n\u003cp\u003e여기서부터는 동일한 과정입니다. 웹소켓이 다음 분을 반환할 때마다 이동 평균을 다시 계산하고 결과에 대해 어떻게 처리할지 결정하면 됩니다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e스캘핑 전략은 잠재력이 있습니다. 반드시 봇이나 웹소켓으로 프로세스를 자동화해야 합니다. 이 작업을 수동으로 하면 머리가 순식간에 회색이 될 것입니다. 또한 매우 낮은 수수료를 제공하거나 다른 요금 구조를 가진 거래소를 찾아야 합니다. Binance는 이 측면에서 꽤 좋은데, 그들의 수수료가 훨씬 낮습니다.\u003c/p\u003e\n\u003cp\u003e이 기사가 흥미로웠고 유용했기를 바랍니다. 계속해서 최신 정보를 받아보고 싶다면, 저를 팔로우하고 이메일 알림에 가입해주시기 바랍니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMichael Whittle\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e만약 이 글이 마음에 드셨다면, 제 Medium 페이지를 팔로우해주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e더 많은 흥미로운 기사를 보고 싶다면, 제 출판물을 팔로우해주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e협업에 관심이 있으시다면, LinkedIn에서 연결해보세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e제 글을 비롯한 Medium 작가들을 지원하고 싶다면, 여기에서 가입해주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e이 글에 박수를 보내주세요 :) ← 감사합니다!\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-05-ScalpingStrategyforCryptocurrency"},"buildId":"z0ZGRQY04MD5cUdT-Nqp1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>