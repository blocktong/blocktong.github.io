<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>blocktong</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://blocktong.github.io///posts/21" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="blocktong" data-gatsby-head="true"/><meta property="og:title" content="blocktong" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://blocktong.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://blocktong.github.io///posts/21" data-gatsby-head="true"/><meta name="twitter:title" content="blocktong" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | blocktong" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-49719f280d4c762f.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/_next/static/BcNXY5smQfBgbhe4ZLNG6/_buildManifest.js" defer=""></script><script src="/_next/static/BcNXY5smQfBgbhe4ZLNG6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Block Tong</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="폭발 에어드랍 단독 혜택 이더리움 레이어 2 혁명의 미래에 참여하는 방법" href="/post/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="폭발 에어드랍 단독 혜택 이더리움 레이어 2 혁명의 미래에 참여하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="폭발 에어드랍 단독 혜택 이더리움 레이어 2 혁명의 미래에 참여하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">폭발 에어드랍 단독 혜택 이더리움 레이어 2 혁명의 미래에 참여하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데브이이 런치패드 업데이트" href="/post/2024-05-05-DevvELaunchpadUpdate"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데브이이 런치패드 업데이트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-DevvELaunchpadUpdate_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데브이이 런치패드 업데이트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">데브이이 런치패드 업데이트</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="잃어버린 열쇠를 찾아요" href="/post/2024-05-05-InSearchofLostKeys"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="잃어버린 열쇠를 찾아요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-InSearchofLostKeys_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="잃어버린 열쇠를 찾아요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">잃어버린 열쇠를 찾아요</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="폭발 초대 코드 안내 BLAST STAKING 에어드랍을 받으려면 어떻게 해야 할까요" href="/post/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="폭발 초대 코드 안내 BLAST STAKING 에어드랍을 받으려면 어떻게 해야 할까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="폭발 초대 코드 안내 BLAST STAKING 에어드랍을 받으려면 어떻게 해야 할까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">폭발 초대 코드 안내 BLAST STAKING 에어드랍을 받으려면 어떻게 해야 할까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루스트로 블록체인 구현하기" href="/post/2024-05-05-ImplementingaBlockchaininRust"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루스트로 블록체인 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루스트로 블록체인 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">루스트로 블록체인 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="만타 에어드랍이 진행 중입니다 청구하는 방법에 대한 빠른 안내입니다" href="/post/2024-05-05-MantaAirdropisLiveQuickGuidehowtoClaim"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="만타 에어드랍이 진행 중입니다 청구하는 방법에 대한 빠른 안내입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-MantaAirdropisLiveQuickGuidehowtoClaim_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="만타 에어드랍이 진행 중입니다 청구하는 방법에 대한 빠른 안내입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">만타 에어드랍이 진행 중입니다 청구하는 방법에 대한 빠른 안내입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="비트스마일리 포인트 시스템인 비트포인트를 소개합니다" href="/post/2024-05-05-IntroducingbitPointthebitSmileyPointSystem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="비트스마일리 포인트 시스템인 비트포인트를 소개합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-IntroducingbitPointthebitSmileyPointSystem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="비트스마일리 포인트 시스템인 비트포인트를 소개합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">비트스마일리 포인트 시스템인 비트포인트를 소개합니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루스트로 웹 3 NFT API를 구현하기" href="/post/2024-05-05-ImplementingaWeb3NFTAPIinRust"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루스트로 웹 3 NFT API를 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루스트로 웹 3 NFT API를 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">루스트로 웹 3 NFT API를 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">29<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="VGX Foundation이 SafeMoon Wallet을 인수했습니다 새로운 장이 시작됩니다" href="/post/2024-05-05-VGXFoundationAcquiresSafeMoonWalletANewChapterBegins"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="VGX Foundation이 SafeMoon Wallet을 인수했습니다 새로운 장이 시작됩니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-VGXFoundationAcquiresSafeMoonWalletANewChapterBegins_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="VGX Foundation이 SafeMoon Wallet을 인수했습니다 새로운 장이 시작됩니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">VGX Foundation이 SafeMoon Wallet을 인수했습니다 새로운 장이 시작됩니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 키 아닌 당신의 영혼" href="/post/2024-05-05-NotYourKeysNotYourSoul"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 키 아닌 당신의 영혼" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-05-NotYourKeysNotYourSoul_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 키 아닌 당신의 영혼" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Block Tong</span></div><strong class="PostList_title__loLkl">당신의 키 아닌 당신의 영혼</strong><div class="PostList_meta__VCFLX"><span class="date">May 5, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"폭발 에어드랍 단독 혜택 이더리움 레이어 2 혁명의 미래에 참여하는 방법","description":"","date":"2024-05-05 17:40","slug":"2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution","content":"\n\n![Blast Airdrop](/assets/img/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_0.png)\n\n## BLAST 에어드랍이란?\n\n‘Blast'는 최근에 소개된 이더리움 레이어 2 제공물로, 공개 출시에 앞서 클로즈형 초청만 받는 초기 액세스 캠페인으로 주목받고 있습니다. Blur Platform 창립자 \"Pacman\"이 만들었으며, 이미 최고의 암호화 펀드인 Paradigm과 eGirl Capital 등으로부터 투자를 받았습니다. 본 안내서는 개인 Blast 커뮤니티와 에어드랍 프로젝트에 액세스 받는 데 필요한 모든 내용을 다루고 있습니다.\n\n## Blast Layer 2를 특별하게 만드는 것들\n\n\n\n다른 스케일링 솔루션과 달리 Blast는 스테이킹된 ETH 및 안정적인 코인에 대한 네이티브 수익 기회를 제공합니다. 최대 30%의 APY를 제공합니다. 이는 비토큰화된 자산에 대해서도 매력적인 보상을 획득할 수 있는 DeFi 사용자에게 수익을 제공합니다. Blast는 또한 이더리움을 통해 NFT 유동성을 연결하는 주요 포털이 될 것을 목표로 하며, 해당 플랫폼으로 거대한 거래량을 유인할 것입니다. \n\n강력한 가치 제안과 주요 투자자의 후원을 통해, Blast는 막대한 상승 잠재력을 가지고 있습니다. 다른 레이어 2 옵션과 다르게 Blast는 스테이킹된 ETH 및 안정적인 코인에 대한 네이티브 수익 기회를 제공합니다. 최대 30%의 APY를 제공하여 DeFi 사용자가 비토큰화된 자산에서도 매력적인 보상을 받을 수 있습니다. Blast는 또한 NFT 유동성을 연결하는 주요 게이트웨이가 되어 목표로 하며, 거대한 거래량을 시스템으로 유도할 것입니다. \n\n강력한 가치 제안과 주요 투자자의 후원을 통해, Blast는 막대한 잠재력을 지니고 있습니다.\n\n![2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_1.png](/assets/img/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_1.png)\n\n**Blast 에어드랍 이벤트 — 어떻게 초대를 받을 수 있나요?**\n\n현재 Blast에 접속하려면 커뮤니티의 일원인 누군가로부터 초대 코드를 획득해야 합니다.\n\n\n\n**BLAST 에어드랍 참여를 위한 초대 코드 몇 개 올려드릴게요:**\n\n- SFA3G\n- DB4HD\n- 934HD\n\n\n\n4YSDH\n\n4HSJG\n\n블라스트 에어드랍을 받기 위한 자격 요건은 무엇인가요?\n\n- BLAST 웹사이트를 방문하고 MetaMask와 같은 기본 ETH 지갑을 연결하세요.\n\n\n\n\n![Image](/assets/img/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_2.png)\n\n- 이더리움 메인넷에서 ETH나 스테이블코인을 브릿지해보세요. 수익을 창출할 수 있습니다.\n\n![Image](/assets/img/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_3.png)\n\n- 커스텀 추천 코드로 친구를 초대하여 에어드랍 달성 목표로 나아갈 수 있어요!\n\n\n\n\n흥미가 계속해서 증가함에 따라 Blast 초대권을 빨리 얻어 Blast 에어드랍 무료 토큰 배포의 자격을 확보하세요! 곧 시작됩니다. 🚀🎁","ogImage":{"url":"/assets/img/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_0.png"},"coverImage":"/assets/img/2024-05-05-BlastAirdropExclusiveHowtoJointheFutureofEthereumsLayer2Revolution_0.png","tag":["Tech"],"readingTime":2},{"title":"데브이이 런치패드 업데이트","description":"","date":"2024-05-05 17:38","slug":"2024-05-05-DevvELaunchpadUpdate","content":"\n\n### [DevvE Launchpad Update](/assets/img/2024-05-05-DevvELaunchpadUpdate_0.png)\n\n**TL;DR:** We're gearing up for the launch on April 30th! Stage 1 of 3 is about to go live, with exciting updates on Genesis NFTs \u0026 DevvDrop.\n\nHey there, crypto enthusiasts! As we draw closer to the much-anticipated launch of the DevvE Launchpad, our dedicated team has been working tirelessly to craft an exceptional launchpad experience for our valued clients and community.\n\nWe're currently right on schedule for an initial rollout of the platform later this month. Please note that we'll be introducing the features of our staking platform gradually to ensure a smooth and robust user experience. We're labeling this initial phase as \"Stage 1\" in line with our commitment to making the DevvE Launchpad a standout platform in its category. Stay tuned as we progress through our 3-stage development plan.\n\n\n\n![2024-05-05-DevvELaunchpadUpdate_1.png](/assets/img/2024-05-05-DevvELaunchpadUpdate_1.png)\n\n# Stage 1을 통한 업데이트 및 일부 변경 사항\n\n## Private 및 Public 티어 할당\n\n저희는 DevvE 스테이킹 및 티어 할당을 관리하는 스마트 계약을 성공적으로 배포했습니다. 이 스마트 계약은 사용자의 총 스테이크를 고려하여 회원 티어를 결정하며, 스테이크 잠금 기간에 대한 추가 배수를 적용합니다. 이 스마트 계약들은 철저히 테스트되어 사용할 준비가 되어 있습니다.\n\n\n\n하지만 우리는 멤버십 티어 설명에 기술된 대로 할당 배포를 위해 공개 판매 스마트 계약을 아직 배포하지 않았습니다. 이에 새로운 스마트 계약을 생성해야 합니다. 소통된 일정을 준수하기 위해 공개 판매 라운드의 첫 번째 론치패드 오퍼링은 프라이빗 판매 할당과 동일한 공식을 채택할 것입니다. 2단계로 넘어가기 전까지 이 조정이 사용자의 할당 수령에 미미하거나 전혀 영향을 미치지 않을 것으로 믿습니다. \n\n## Seedling Lottery System\n\n시앙딩 로터리 시스템은 초기 론치패드 라운드에서 1배의 프라이빗 세일 할당을 구현하지 않을 것입니다. 대신, 시앙딩 티어의 모든 DevvE 잠긴 스테이커들에게 1배 할당을 제공할 것입니다. 나중에 검토되어 원래 문서로 되돌아갈 수 있습니다. \n\n![DevvELaunchpadUpdate_2.png](/assets/img/2024-05-05-DevvELaunchpadUpdate_2.png)\n\n\n\n## DevvDrop\n\nDevvDrop의 첫 번째 이벤트가 곧 공개될 예정입니다. 리워드 프로그램을 시작하기 위해 스테이킹을 진행하면서 이 이벤트에 참여할 수 있습니다. 이는 퍼블릭 세일과 유사하게, 사용자들이 보유한 DevvE의 퍼센트에 기반하여 12개월 동안 토큰을 조달하는 독립 스마트 컨트랙트를 포함합니다. 이러한 컨트랙트는 완료되어 최종 테스트 단계에 있으며, 첫 번째 프로젝트 론칭을 위한 배포 준비가 되어 있습니다! 이곳에서 주목해야 할 중요한 점은 조달이 독립적인 스마트 컨트랙트에 의해 이뤄지므로 토큰이 이용 가능해지는 TGE 이후에 조달이 시작되어야 한다는 것입니다.\n\n저희 커뮤니티에서 알고 있듯이, 첫 번째 DevvDrop은 $FIAS입니다. DevvE 저당 담당자들에게 분배될 3,000,000 달러($TGE 가격 기준 240,000 달러)의 토큰이 할당되었습니다.\n\n이후에는 런치패드나 DevvExchange에서 새로운 프로젝트가 론칭되면, DevvE를 잠금 상태로 유지하는 사용자들은 추가 풀에 모두 참여할 수 있습니다. Fias 이후 곧 시작할 2번째 DevvDrop을 통해 사용자들의 리워드가 가속화될 것으로 예상됩니다. 12개월 동안 토큰의 조달이 이뤄지는 기간 동안 사용자들은 무제한 DevvDrop을 포함하여 그들의 계정에 조달되는 완전한 보상 잠재력을 수집할 수 있을 것입니다.\n\n\n\n## 제네시스 NFT\n\n우리의 초기 지지자들은 우리 성공의 중추입니다. 모든 관련자들에게 보상을 드리고자 제네시스 NFT를 드리려고 합니다! 이를 통해 다양한 흥미로운 혜택을 누릴 수 있습니다. 예를 들면, DevvE 런치패드를 위한 독점적인 사적 거래, 예정된 DevvExchange의 할인 혜택, 곧 출시될 DevvMerch 샵의 할인 혜택, 향후 런치패드 프로젝트 결정에 참여할 자격을 얻게 됩니다. 덤으로 희귀 NFT 버전을 받을 수도 있는데, 이는 추가 혜택을 더해줍니다.\n\n무료 제네시스 드롭 대상으로 선정되려면, 티어 2 이상의 스테이커여야하며, 9개월 이상 록업하고, 최소 1,000달러 이상의 $DEVVE를 스테이킹하고, 런치패드 출시일로부터 40일 이내에 이 모든 조건을 충족해야 합니다. 그러나 팀으로부터 예정된 NFT 커뮤니케이션에서 자세한 정보를 기대해주십시오.\n\n## 7일 냉각 기간\n\n\n\n첫 번째 출시 단계에서는 7일 동안의 냉각 기간이 제공되지 않습니다. 모든 담보는 변경할 수 없는 스마트 계약으로 처리될 것이지만 나줘 구현하려고 합니다 후에 이 기능을 과정입니다.\n\n## 일반 UI/UX 개선 사항\n\n1단계 런치패드 운영의 성공적인 배포 이후에 우리의 포커스는 독특한 메커니즘과 함께 스마트 계약의 기술적 구현에 있었지만 이제 일반 개선사항 목록이 계획되어 있습니다.\n\n거의 다 왔어요...!\n\n\n\nWe're in the final stages of integrating with our KYC provider, and it's taking a bit longer than we expected. The exciting news is that everything is moving forward smoothly for the launch, and we can't wait for you to try out the DevvE Launchpad!\n\nThe DevvE Team.\n\nUpdate: Join us now at [DevvE Launchpad Stake](https://www.devvelaunchpad.io/stake) \n\n![DevvE Launchpad Update](/assets/img/2024-05-05-DevvELaunchpadUpdate_3.png)\n\n\n\n더 많은 정보 및 DevvE 링크:\n\n- 웹사이트: [DevvE](https://www.devve.io/)\n- Twitter/X: [DevveEcosystem](https://twitter.com/DevveEcosystem)\n- Discord: [DevvE Discord](https://discord.gg/q2NNV6WXfV)\n\n\n\n텔레그램: [Devve 공식 채널](https://t.me/DevveOfficial)\n\n텔레그램 공지사항: [DevvE 공지 채널](https://t.me/DevvEAnnouncements)\n\nLinkedIn: [Devve 회사 링크](https://www.linkedin.com/company/devve/)\n\nReddit: [DevvE 공식 Reddit](https://www.reddit.com/r/DevvEOfficial/)\n\n\n\n**[Medium](https://medium.com/@DevveEcosystem)**\n\n**[YouTube](https://www.youtube.com/@DevvEecosystem)**","ogImage":{"url":"/assets/img/2024-05-05-DevvELaunchpadUpdate_0.png"},"coverImage":"/assets/img/2024-05-05-DevvELaunchpadUpdate_0.png","tag":["Tech"],"readingTime":5},{"title":"잃어버린 열쇠를 찾아요","description":"","date":"2024-05-05 17:37","slug":"2024-05-05-InSearchofLostKeys","content":"\n\n이 글은 \"과거에서의 소식\"으로, 새해가 다가오는 지금 이 시기에 적절하다고 생각해요. 사토시 나카모토는 2009년 1월 3일에 최초의 블록체인인 비트코인을 발표했습니다. 그리고 우리는 거의 그 이벤트의 15주년을 맞이하고 있어요.\n\n블록체인은 지갑을 주요 사용자 인터페이스로 사용하며, 지난 15년 동안 지갑과 개인 키 관리는 크게 발전해 왔어요. Resonance Security의 엔지니어들과 함께 작성된 이 글에서는 블록체인 지갑의 개발자와 사용자들이 과거에 경험한 일부 문제들을 살펴보려 해요.\n\n이 글을 통해 왜 지갑이 중요한지, 그리고 왜 안전하고 신뢰할 수 있게 지원하는 기술이 그렇게 어려운지에 대해 보다 명확한 이해를 갖게 될 거에요.\n\n# 지갑이란 무엇인가요?\n\n\n\n사토시의 첫 릴리스에는 블록체인 노드를 실행하는 소프트웨어와 블록체인 월렛이 모두 포함되어 있었습니다. 월렛 소프트웨어는 블록체인 상에서 자산을 소유한 사람들이 거래를 승인하는 데 사용되는 개인 키를 관리합니다. 이러한 개인 키는 디지털 자산을 보유하고 있는 공개 블록체인 주소를 파생시키며 이를 통해 해당 자산을 거래하는 승인을 디지털로 서명합니다.\n\n블록체인은 비대칭 키 암호화를 사용하며 대개 ECDSA 알고리즘을 사용합니다. 따라서 개인 키를 생성하려면 약 256비트의 무작위 숫자(대략 1과 1.157 * 10⁷⁷ 사이의 숫자, 약 77개의 제로로 이루어져 있으며 1 뒤에 일의 비어 있는 숫자가 100개인 큰 숫자)를 선택해야 합니다.\n\n결론적으로, 1) 정말로 무작위이면서 추측하기 어려운 256비트 숫자를 선택하는 것은 상당히 어렵고, 2) 그 숫자를 잃지 않고 보관하거나 다른 사람이 액세스하거나 훔치지 못하도록 하는 것은 더 어렵습니다.\n\n# 원본 월렛\n\n\n\n상기 언급된 첫 번째 블록체인 지갑은 종종 사토시 클라이언트로 불리기도 합니다. 초기에는 사토시 클라이언트가 C++ 난수 생성기를 사용하여 무작위로 개인 키를 생성하고 wallet.dat이라는 파일에 저장했습니다.\n\n처음에는 파일이 암호화되지 않았기 때문에, 비트코인에 달러 가치가 생기면서 해커들이 네트워크화된 컴퓨터에 침입해서 wallet.dat 파일 및 따라서 파생된 비트코인 주소에 저장된 암호화폐를 훔치려고 시도하기 시작했습니다.\n\n나중에 wallet.dat은 무작위 마스터 키로 암호화되었고, 이 마스터 키 자체는 wallet 암호라 불리는 비밀번호로 암호화되었습니다. 사용자 중에는 지나치게 간단한 wallet 암호를 선택하여 시간이 지남에 따라 시도 및 실패로 추측될 수 있는 경우가 있습니다.\n\n이전에 폐기된 컴퓨터나 하드 드라이브에 초기 비트코인 소프트웨어의 오래된 설치 파일이 아직 남아 있는 경우가 가끔 발견됩니다. 이 파일에는 옛날 비트코인 자산에 액세스할 수 있는 키가 저장되어 있습니다. 파일이 암호화되지 않았거나 원래 소유자가 wallet 암호를 기억하고 있다면, 예상치 못한 암호화폐 대박에 이르게 될 수 있습니다.\n\n\n\n# 뇌 없는 지갑\n\n약 2013년경, 몇 명이 아이디어를 냈는데 처음에는 눈부시게 보였어요 — 비밀번호나 암호를 만들고 이를 SHA256 암호화 해시 함수로 해싱해 256비트 숫자로 만들어서 개인 키로 사용하는 것이죠. 이렇게 하면 비트코인을 머리 속에 넣고 다닐 수 있어요!\n\n그러나 이 방법에는 두 가지 문제점이 있어요. 첫 번째는 사람들이 오랜 기간 동안 일어나는 일을 기억하는 데 잘하지 않다는 점이에요. 오늘은 암호가 기억하기 쉽게 느껴질 수 있지만, 1년이나 10년 후에는 그렇지 않을 거예요.\n\n두 번째는 사람들이 진정으로 무작위로 암호를 만들어내는 데 능하지 않으며, 그래서 많은 브레인월렛들이 추측 가능했어요. 예를 들어, 누군가가 심슨즈 시즌 5, 에피소드 7의 한 대사가 좋은 암호일 것이라 생각했어요: \"You don't win friends with salad!\", 이를 사용해서 공개 주소 15gCfQVJ68vyUVdb6e3VDU4iTkTC3HtLQ2를 생성했어요.\n\n\n\n누군가가 이를 추측하여 그 당시 보유한 세 비트코인을 탈취했습니다. 다행히 이후에 해당 비트코인은 반환되었고, 원래 주인은 수십 또는 수백 비트코인을 잃을 뻔했던 교훈을 얻었습니다.\n\n# 의사 난수 생성기\n\n지갑을 신중하게 다루고 오프라인으로 보관하고 시드 문구를 은행 금고 뒷면에 안전하게 보관한다해도, 첫 번째로 개인 키를 생성하는 데 사용된 방법이 실제로 무작위가 아니라면 아무 소용이 없습니다.\n\n이것은 컴퓨터 프로그래밍에서 반복되는 문제입니다. 컴퓨터는 무작위로 잘 처리하지 못합니다. 그들은 결정론적인 기계입니다. 대부분의 경우, 예를 들어 적들이 무작위로 생성되는 게임을 작성할 때, 빠른 의사 난수 생성기(PRNG)를 사용하는 것이 충분합니다.\n\n\n\n하지만 PRNG(의사 난수 생성기)는 컴퓨터의 어떤 경우에서도 동일한 \"랜덤\" 숫자 시퀀스를 생성합니다. 이는 동일한 시드 값을 사용하여 프로세스를 시작하면 된다는 뜻이며, 개발자들은 주로 PRNG 시드 값으로 현재 시간을 사용합니다.\n\n![Image](/assets/img/2024-05-05-InSearchofLostKeys_0.png)\n\n누군가는 컴퓨터 게임에서 고블린이나 좀비들이 나타날 정확한 위치를 찾는 데 시간과 노력을 들일 사람이 없겠지만, 랜덤 숫자가 블록체인 주소를 생성하는 데 사용되고, 해당 블록체인 주소에 암호화폐가 보관되어 있다면, 값 보관 주소를 생성하는 데 사용된 시드 입력을 시도해 볼 가치가 있습니다.\n\n결국, Cakewallet이라는 지갑 제공 업체가 자신들의 코드에서 정확히 이 실수를 저질렀다는 것을 밝혀냈습니다. Cakewallet의 첫 릴리스가 2018년에 나왔고, 결함이 2021년까지 발견되지 않았기 때문에, 취약한 지갑 주소의 3년간 윈도우가 남게 되었습니다.\n\n\n\n그리고 세 가지 해야 할 것은 단지 95 백만 초에 불과합니다. 모든 월렛 주소는 1 억 회 미만으로 브루트 포스로 공격당할 수 있기 때문에 오프라인에서 당신의 해독 소프트웨어를 실행하고 괜찮은 컴퓨터와 몇 달이면 충분합니다.\n\n# 수의 보호 실패\n\n많은 책임을 맡았을 때, 많은 사람들이 선택한 첫 번째 방법은 부모 대신 역할을 맡을 사람을 찾는 것입니다. 그래서 외부 위임 월렛이 있습니다. 자산을 회사나 개인에게 이전하고 그들에게 월렛 보안, 비밀번호 기억 및 해커로부터의 보호 등의 모든 일을 처리하도록 합니다.\n\n이론상으로 비트코인 및 기타 디지털 자산을 보호하는 조직이 규모의 효율성을 가지고 있으며 보안 컨설턴트, 암호화 소프트웨어 개발자 및 경험 많은 네트워크 엔지니어를 고용하여 모든 것이 원할하게 진행되도록 할 수 있다고 생각됩니다.\n\n\n\n실제로, 보관 지갑들이 많은 사례에서 실패하는 것을 볼 수 있습니다. 큰 일반적인 두 가지 사례는 다음과 같습니다:\n\n- 2014년 Mt. Gox가 폐쇄되었을 때 수백만 개의 비트코인이 2년 동안 핫 암호화폐 지갑에서 도난당했음을 알게 되었을 때 폐쇄되었습니다. 분실된 자금: 대략 65만 비트코인과 2,700만 달러.\n- 2022년 FTX가 폐쇄되었습니다. 거래소가 입금에 대한 보증금을 지지하기에 충분한 자산을 보유하지 않았고 일부 자금을 사기적으로 거래하거나 대여하거나 발표금액 중 상당 부분을 배해 바하마의 정치 기부 및 부동산에 사용한 사실이 드러난 후입니다. 분실된 자금: 대략 80억 달러.\n\n![InSearchofLostKeys](/assets/img/2024-05-05-InSearchofLostKeys_1.png)\n\n보호자가 더 능숙할지도 모르고 범인일 가능성도 있는 한 가지 문제는 보유자 없이는 보증할 수 없다는 점입니다. 또한, 암호화폐는 도난이나 분실로부터 자산을 보호해 주는 연방예금보험공사가 없습니다. 더구나 중앙집중형 보호자는 해커 그룹에게 풍부한 공격 대상이 됩니다.\n\n\n\n# 스마트 계약 믿기\n\n자산을 직접 보관하거나 자신의 자산을 보유하고 스마트 계약을 사용해보는 건 어떨까요? 이것이 바로 이더리움의 Parity 지갑 스마트 계약 라이브러리가 설계된 목적입니다. 해당 라이브러리를 사용하여 자산을 지갑 스마트 계약으로 이체하고, 이후 자산을 다시 이동하기 위해 여러 인가 서명이 필요합니다.\n\n이 다중 서명 방법은 좋은 방법처럼 보였습니다 (그리고 실제로 그렇습니다): 예를 들어, 6 명의 이사 중 3 명이 서명을 할 때야 자산을 이동할 수 있습니다. 그렇기에 만약 그 중 한 명 또는 두 명이 피싱이나 간과로 암호를 분실하거나 부패한 비투명을 한다 해도 자산은 안전합니다.\n\n안타깝게도, Parity 지갑 라이브러리에는 버그가 포함되어 있었습니다. 2017 년에 배포될 때 (다른 버그를 고치기 위해 다시 배포된 경우) 지갑 라이브러리는 소유자로 초기화되지 않았습니다. 코드에 \"kill\" 함수가 포함되어 있었는데, 해당 함수는 계약의 소유자에 의해 호출될 수 있습니다. devops199라는 핸들을 사용하는 누군가는 초기화 함수를 호출하여 라이브러리의 소유권을 확보한 후, 모든 Parity 지갑 라이브러리를 사용하는 다중 서명 지갑에 의해 보유되고 있는 모든 자금을 얼렸습니다.\n\n\n\n![In Search of Lost Keys](/assets/img/2024-05-05-InSearchofLostKeys_2.png)\n\n총 분실 금액은 513,743 ETH로, 현재 가격 기준으로 약 12억 달러입니다.\n\n# 요약\n\n암호화 자산을 보호하는 것은 마치 \"머리로는 당신이 잃고, 꼬리로는 해커들이 얻는\" 게임처럼 느껴집니다. 자신만으로 보호하기는 어렵고, 다른 사람에게 맡기는 것은 더 어려울 수 있습니다.\n\n\n\n암호화폐는 여전히 야생에 놓여있다는 사실은 변함없습니다. 여러분은 결정해야 합니다 - 나는 가이드와 함께 가야 하나요(그들의 능력을 어떻게 판단할 수 있을까요), 아니면 생존 기술을 배우고 자신에게 의존해야 하나요. 블록체인 공간이 공원이 될 때까지, 그것이 바로 현재의 상황입니다.\n\n그동안, 자신과 자산을 보호하는 것은 작업을 필요로 합니다:\n\n- 암호화폐와 안전한 관행에 대해 교육을 받는 데 시간을 투자하세요,\n- 인증 및 감사를 확인하고, 해당 인증 또는 감사 단체를 조사하세요,\n- 너무 좋아 보이면 확실히 그렇다는 것을 기억하세요.\n\n이제 남은 것은 저와 Resonance Security가 여러분에게 번영하고, 무엇보다도 안전한 새해를 기원하는 것뿐입니다.","ogImage":{"url":"/assets/img/2024-05-05-InSearchofLostKeys_0.png"},"coverImage":"/assets/img/2024-05-05-InSearchofLostKeys_0.png","tag":["Tech"],"readingTime":6},{"title":"폭발 초대 코드 안내 BLAST STAKING 에어드랍을 받으려면 어떻게 해야 할까요","description":"","date":"2024-05-05 17:36","slug":"2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop","content":"\n\n![BLAST AIRDROP](/assets/img/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop_0.png)\n\n# BLAST 에어드랍이란\n\n블러 플랫폼의 창립자인 \"Pacman\"에 의해 만들어진 Blast라는 새로운 이더리움 레이어 2 제공물이 공개 런칭 이전에 초대제한 조기 액세스 캠페인으로 주목을 받고 있습니다. Paradigm과 eGirl Capital과 같은 최고의 암호화 자금으로부터 투자를 유치했습니다. 이 안내서는 현재 알려진 바에 따라 개인 Blast 커뮤니티 가입 및 에어드랍 이니셔티브 참여 접근법에 관한 모든 것을 다루고 있습니다.\n\n# Blast 레이어 2의 특별함\n\n\n\n다른 스케일링 솔루션과 달리, Blast는 스테이킹된 이더리움과 스테이블코인에 대한 네이티브 수익 기회를 제공합니다. 최대 30%의 연간 수익률을 제공하여, 비토큰화된 자산에도 매력적인 보상을 획득할 수 있습니다. Blast는 또한 이더리움 간의 NFT 유동성을 연결하는 주요 포턀로 발전하고 방대한 거래량을 플랫폼으로 유도할 계획입니다. 강력한 가치 제안 및 주요 투자자의 지원을 통해, Blast는 상당한 상승 잠재력을 보유하고 있습니다.\n\n![Blast](/assets/img/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop_1.png)\n\nBlast 공개 이벤트 - 초대 받는 방법?\n\n현재 Blast에 접속하려면 커뮤니티 구성원 중 한 명으로부터 초대 코드를 받아야 합니다.\n\n\n\n여기 BLAST 에어드랍에 참여하는 데 사용할 수 있는 초대 코드 몇 개가 있어요:\n\n- SFA3G\n- DB4HD\n- 934HD\n\n\n\n4YSDH\n\n4HSJG\n\n블라스트 에어드랍을 받는 방법은?\n\n- BLAST 웹사이트를 방문하고, 메타마스크와 같은 기본 이더리움 지갑을 연결하세요.\n\n\n\n\n![Blast Invite Code Instruction](/assets/img/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop_2.png)\n\n- 이더리움 메인넷에서 이더리움 또는 스테이블코인을 브릿지하여 수익을 얻으세요.\n\n![Blast Invite Code Instruction](/assets/img/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop_3.png)\n\n- 커스텀 추천 코드로 친구들을 초대하여 에어드랍 마일스톤을 달성하세요!\n\n\n\n\n흥미가 계속해서 증폭되고 있으니, Blast 초대장을 빨리 받아내어 블라스트 에어드랍 무료 토큰 분배의 대상이 되세요! 곧 찾아옵니다. 🚀💰","ogImage":{"url":"/assets/img/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop_0.png"},"coverImage":"/assets/img/2024-05-05-BlastInvitecodeInstructionHowtogetBLASTSTAKINGAirdrop_0.png","tag":["Tech"],"readingTime":2},{"title":"루스트로 블록체인 구현하기","description":"","date":"2024-05-05 17:33","slug":"2024-05-05-ImplementingaBlockchaininRust","content":"\n\n![Implementing a Blockchain in Rust](/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png)\n\n안녕하세요! 이 기사는 Rust에서 기본적인 블록체인을 구현하는 단계별 방법을 제공합니다. 블록 구조의 초기 설정부터 시작하여 고유 식별자와 암호 해시를 포함하고, 블록 생성, 채굴, 그리고 유효성 검사로 그 기초를 마련합니다. 각 함수의 밑바탕과 그 이유를 설명하여 작업 증명, 논스 계산, 블록체인의 무결성과 연속성을 유지하는 메커니즘에 대한 통찰을 제공합니다.\n\n참고: 이는 학습 목적을 위한 베어본과 기본 블록체인 구현이며 프로덕션 환경에는 사용하지 않는 것이 좋습니다! :)\n\n자, 함께 Rustaceans 여러분, 바로 들어가 봅시다!\n\n\n\n# 기본 사항\n\n블록체인의 P2P 네트워크 상호작용 처리에서 핵심 개념과 주요 요소는 다음과 같습니다:\n\n## 노드와 피어 찾기\n\n- 노드 식별: 블록체인 네트워크의 각 노드는 암호화 키 쌍에서 파생된 고유 식별자를 갖습니다.\n- 피어 찾기: 노드는 네트워크를 형성하기 위해 서로를 발견해야 합니다. 미리 정의된 피어(정적 구성), DNS 기반 발견, 또는 로컬 네트워크 발견을 위해 mDNS와 같은 프로토콜을 사용하는 등, 다양한 방법으로 이를 달성할 수 있습니다.\n- 부트스트랩 노드: 새로운 노드는 종종 신뢰할 수 있는 알려진 노드(부트스트랩 노드)에 연결하여 빠르게 네트워크에 통합됩니다.\n\n\n\n## 네트워크 프로토콜\n\n- 프로토콜 스택: 블록체인 P2P 네트워크는 특정 프로토콜 스택을 사용하여 통신합니다. 주로 사용되는 프로토콜로는 기본 전송을 위한 TCP/IP와 안전한 통신을 위한 암호 프로토콜(예: TLS 또는 Noise)이 있습니다.\n- 메시징 프로토콜: Floodsub이나 Gossipsub과 같은 프로토콜은 메시지 방송 및 네트워크 전파를위해 사용됩니다.\n\n## 데이터 전파 및 동기화\n\n- 방송: 노드는 트랜잭션 및 새롭게 채굴된 블록을 네트워크로 방송하여 모든 참가자가 최신 데이터를 수신하도록합니다.\n- 체인 동기화: 노드는 블록체인 복사본을 가장 긴 체인(일반적으로 유효한 것으로 인정됨)에 동기화하여 네트워크의 일관성을 유지합니다.\n- 합의 메커니즘: 합의 알고리즘인 작업 증명(PoW) 또는 지분 증명(PoS) 등이 새로운 블록을 검증하고 추가하기위해 특히 블록체인의 상태에 대한 합의에 사용됩니다.\n\n\n\n이러한 핵심 개념을 이해했다면, 이제 코드로 넘어가 봅시다!\n\n# cargo.toml — 다음 종속성을 추가하세요\n\n```toml\n[dependencies]\nchrono = \"0.4\"\nsha2 = \"0.9.8\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nlibp2p = { version = \"0.40.0\", features = [\"tcp-tokio\", \"mdns\"] }\ntokio = { version = \"1.0\", features = [\"io-util\", \"io-std\", \"macros\", \"rt\", \"rt-multi-thread\", \"sync\", \"time\"] }\nhex = \"0.4\"\nonce_cell = \"1.5\"\nlog = \"0.4\"\npretty_env_logger = \"0.4\"\n```\n\n우리는 많은 시간을 잡아먹지 않도록 모든 라이브러리를 자세히 다루지 않겠습니다. 하지만 P2P 구현에 중요한 라이브러리로써 libp2p를 언급해 봅니다.\n\n\n\n저는 libp2p에 대해 자세한 기사를 작성했습니다. 여기서 이 풍부한 Rust 크레이트에 익숙해질 수 있습니다.\n\n## blockchain.rs — 이벤트 처리 및 P2P 통신\n\n우리가 이벤트 처리 및 p2p 방법을 구현할 'blockchain.rs'라는 새 파일을 만들어봅시다.\n\n### 기본 설정\n\n\n\n- KEYS, PEER_ID, CHAIN_TOPIC, BLOCK_TOPIC: 이러한 정적 변수는 신원을 위한 암호화 키, 네트워크 노드를 위한 피어 ID, 그리고 Floodsub 프로토콜을 사용하여 체인 및 블록 관련 메시지를 처리하기 위한 주제를 초기화합니다.\n\n```rust\nuse super::{App, Block};\nuse libp2p::{\n    floodsub::{Floodsub, FloodsubEvent, Topic},\n    identity,\n    mdns::{Mdns, MdnsEvent},\n    swarm::{NetworkBehaviourEventProcess, Swarm},\n    NetworkBehaviour, PeerId,\n};\nuse log::{error, info};\nuse once_cell::sync::Lazy;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse tokio::sync::mpsc;\n\npub static KEYS: Lazy\u003cidentity::Keypair\u003e = Lazy::new(identity::Keypair::generate_ed25519);\npub static PEER_ID: Lazy\u003cPeerId\u003e = Lazy::new(|| PeerId::from(KEYS.public()));\npub static CHAIN_TOPIC: Lazy\u003cTopic\u003e = Lazy::new(|| Topic::new(\"chains\"));\npub static BLOCK_TOPIC: Lazy\u003cTopic\u003e = Lazy::new(|| Topic::new(\"blocks\"));\n```\n\n# 이벤트 유형\n\n- ChainResponse, LocalChainRequest, EventType: 이러한 데이터 구조는 노드가 보내고 받을 수 있는 이벤트 및 메시지 유형을 정의합니다. ChainResponse 및 LocalChainRequest는 체인 요청에 응답하고 로컬 체인 상태를 요청하는 데 사용됩니다.\n\n\n\n```rust\n#[derive(Debug, Serialize, Deserialize)]\npub struct ChainResponse {\n    pub blocks: Vec\u003cBlock\u003e,\n    pub receiver: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LocalChainRequest {\n    pub from_peer_id: String,\n}\n\npub enum EventType {\n    LocalChainResponse(ChainResponse),\n    Input(String),\n    Init,\n}\n```\n\n## AppBehaviour\n\n- NetworkBehaviour Implementation (AppBehaviour): This struct implements the NetworkBehaviour trait, combining different behaviours like Floodsub (for pub/sub messaging) and mDNS (for local network peer discovery). It also holds channels for sending responses and initializing events and an instance of the App struct which contains the blockchain logic.\n\n```rust\n#[derive(NetworkBehaviour)]\n#[behaviour(out_event=\"Event\")]\npub struct AppBehaviour {\n    pub floodsub: Floodsub,\n    pub mdns: Mdns,\n    #[behaviour(ignore)]\n    pub response_sender: mpsc::UnboundedSender\u003cChainResponse\u003e,\n    #[behaviour(ignore)]\n    pub init_sender: mpsc::UnboundedSender\u003cbool\u003e,\n    #[behaviour(ignore)]\n    pub app: App,\n}\n\n#[derive(Debug)]\npub enum Event {\n    ChainResponse(ChainResponse),\n    Floodsub(FloodsubEvent),\n    Mdns(MdnsEvent),\n    Input(String),\n    Init,\n}\n\nimpl From\u003cFloodsubEvent\u003e for Event {\n    fn from(event: FloodsubEvent) -\u003e Self {\n        Self::Floodsub(event)\n    }\n}\n\nimpl From\u003cMdnsEvent\u003e for Event {\n    fn from(event: MdnsEvent) -\u003e Self {\n        Self::Mdns(event)\n    }\n}\n\nimpl AppBehaviour {\n    pub async fn new(\n        app: App,\n        response_sender: mpsc::UnboundedSender\u003cChainResponse\u003e,\n        init_sender: mpsc::UnboundedSender\u003cbool\u003e,\n    ) -\u003e Self {\n        let mut behaviour = Self {\n            app,\n            floodsub: Floodsub::new(*PEER_ID),\n            mdns: Mdns::new(Default::default())\n                .await\n                .expect(\"can create mdns\"),\n            response_sender,\n            init_sender,\n        };\n\n        behaviour.floodsub.subscribe(CHAIN_TOPIC.clone());\n        behaviour.floodsub.subscribe(BLOCK_TOPIC.clone());\n\n        behaviour\n    }\n}\n```\n\n\n\n# 이벤트 처리\n\n- FloodsubEvent 및 MdnsEvent를 위한 NetworkBehaviourEventProcess: 이러한 구현은 응용 프로그램이 다양한 네트워크 이벤트에 반응하는 방식을 정의합니다.\n- Floodsub 이벤트: 새 블록, 체인 응답 또는 로컬 체인 요청과 같은 블록체인 관련 메시지를 처리합니다. 예를 들어, 새 블록이 수신되면 try_add_block을 통해 블록체인에 추가됩니다.\n- mDNS 이벤트: 로컬 네트워크에서 새 피어의 발견 또는 기존 피어의 손실을 처리합니다. 이는 Floodsub 프로토콜에서 피어 목록을 업데이트합니다.\n\n```rust\n// 수신 이벤트 핸들러\nimpl NetworkBehaviourEventProcess\u003cFloodsubEvent\u003e for AppBehaviour {\n    fn inject_event(\u0026mut self, event: FloodsubEvent) {\n        if let FloodsubEvent::Message(msg) = event {\n            if let Ok(resp) = serde_json::from_slice::\u003cChainResponse\u003e(\u0026msg.data) {\n                if resp.receiver == PEER_ID.to_string() {\n                    info!(\"{}로부터 응답:\", msg.source);\n                    resp.blocks.iter().for_each(|r| info!(\"{:?}\", r));\n\n                    self.app.blocks = self.app.choose_chain(self.app.blocks.clone(), resp.blocks);\n                }\n            } else if let Ok(resp) = serde_json::from_slice::\u003cLocalChainRequest\u003e(\u0026msg.data) {\n                info!(\"{}로부터 로컬 체인 전송\", msg.source.to_string());\n                let peer_id = resp.from_peer_id;\n                if PEER_ID.to_string() == peer_id {\n                    if let Err(e) = self.response_sender.send(ChainResponse {\n                        blocks: self.app.blocks.clone(),\n                        receiver: msg.source.to_string(),\n                    }) {\n                        error!(\"채널을 통해 응답 전송 중 오류 발생, {}\", e);\n                    }\n                }\n            } else if let Ok(block) = serde_json::from_slice::\u003cBlock\u003e(\u0026msg.data) {\n                info!(\"{}로부터 새 블록 수신\", msg.source.to_string());\n                self.app.try_add_block(block);\n            }\n        }\n    }\n}\n\nimpl NetworkBehaviourEventProcess\u003cMdnsEvent\u003e for AppBehaviour {\n    fn inject_event(\u0026mut self, event: MdnsEvent) {\n        match event {\n            MdnsEvent::Discovered(discovered_list) =\u003e {\n                for (peer, _addr) in discovered_list {\n                    self.floodsub.add_node_to_partial_view(peer);\n                }\n            }\n            MdnsEvent::Expired(expired_list) =\u003e {\n                for (peer, _addr) in expired_list {\n                    if !self.mdns.has_node(\u0026peer) {\n                        self.floodsub.remove_node_from_partial_view(\u0026peer);\n                    }\n                }\n            }\n        }\n    }\n}\r\n```\n\n# 유틸리티 함수\n\n\n\n- get_list_peers: 네트워크에서 발견된 피어 목록을 반환합니다.\n- handle_print_peers: 콘솔에 피어 목록을 로깅합니다.\n- handle_print_chain: 로컬 블록체인 상태를 기록하며, 블록체인의 시각적 표현을 제공합니다.\n- handle_create_block: 사용자 입력을 처리하여 새 블록을 생성합니다. 제공된 데이터로 새 블록을 생성하고, 로컬 블록체인을 업데이트하고, Floodsub을 사용하여 새 블록을 피어에 브로드캐스트합니다.\n\n```rust\npub fn get_list_peers(swarm: \u0026Swarm\u003cAppBehaviour\u003e) -\u003e Vec\u003cString\u003e {\n    info!(\"발견된 피어:\");\n    let nodes = swarm.behaviour().mdns.discovered_nodes();\n    let mut unique_peers = HashSet::new();\n    for peer in nodes {\n        unique_peers.insert(peer);\n    }\n    unique_peers.iter().map(|p| p.to_string()).collect()\n}\n\npub fn handle_print_peers(swarm: \u0026Swarm\u003cAppBehaviour\u003e) {\n    let peers = get_list_peers(swarm);\n    peers.iter().for_each(|p| info!(\"{}\", p));\n}\n\npub fn handle_print_chain(swarm: \u0026Swarm\u003cAppBehaviour\u003e) {\n    info!(\"로컬 블록체인:\");\n    let pretty_json =\n        serde_json::to_string_pretty(\u0026swarm.behaviour().app.blocks).expect(\"can jsonify blocks\");\n    info!(\"{}\", pretty_json);\n}\n\npub fn handle_create_block(cmd: \u0026str, swarm: \u0026mut Swarm\u003cAppBehaviour\u003e) {\n    if let Some(data) = cmd.strip_prefix(\"create b\") {\n        let behaviour = swarm.behaviour_mut();\n        let latest_block = behaviour\n            .app\n            .blocks\n            .last()\n            .expect(\"적어도 하나의 블록이 있어야 함\");\n        let block = Block::new(\n            latest_block.id + 1,\n            latest_block.hash.clone(),\n            data.to_owned(),\n        );\n        let json = serde_json::to_string(\u0026block).expect(\"can jsonify request\");\n        behaviour.app.blocks.push(block);\n        info!(\"새 블록을 브로드캐스팅 중\");\n        behaviour\n            .floodsub\n            .publish(BLOCK_TOPIC.clone(), json.as_bytes());\n    }\n}\n```\n\n# main.rs — Main Loop 및 블록 채굴\n\n이제 'main.rs'라는 새 파일을 생성하여 메인 루프와 블록 채굴을 담당할 것입니다. 코어 로직은 아래와 같습니다:\n\n\n\n# 블록 구조\n\n블록 구조체는 블록체인 내의 블록 구조를 정의합니다. 이 구조에는 다음이 포함됩니다:\n\n- id: 블록의 고유 식별자입니다.\n- hash: 블록의 해시입니다.\n- previous_hash: 체인 내 이전 블록의 해시입니다.\n- timestamp: 블록의 생성 시간입니다.\n- data: 블록의 데이터 또는 페이로드입니다.\n- nonce: 채굴 과정 중 사용되는 값입니다.\n\n```rust\nuse std::io::{Read, Write};\nuse chrono::prelude::*;\nuse libp2p::{\n    core::upgrade,\n    futures::StreamExt,\n    mplex,\n    noise::{Keypair, NoiseConfig, X25519Spec},\n    swarm::{Swarm, SwarmBuilder},\n    tcp::TokioTcpConfig,\n    Transport,\n};\nuse log::{error, info, warn};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse std::time::Duration;\nuse tokio::{\n    io::{stdin, AsyncBufReadExt, BufReader},\n    select, spawn,\n    sync::mpsc,\n    time::sleep,\n};\n\nconst DIFFICULTY_PREFIX: \u0026str = \"00\";\n\nmod blockchain;\npub struct App {\n    pub blocks: Vec\u003cBlock\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Block {\n    pub id: u64,\n    pub hash: String,\n    pub previous_hash: String,\n    pub timestamp: i64,\n    pub data: String,\n    pub nonce: u64,\n}\n```\n\n\n\n# 블록 생성 (새로운 기능)\n\n블록 구현 블록(DOM)에 있는 새로운 기능은 새 블록을 생성합니다. 이 기능은 mine_block 함수를 호출하여 블록의 해시와 논스를 생성합니다. 다른 속성들은 입력 값과 현재 시간을 기준으로 설정됩니다.\n\n```rust\nimpl Block {\n    pub fn new(id: u64, previous_hash: String, data: String) -\u003e Self {\n        let now = Utc::now();\n        let (nonce, hash) = mine_block(id, now.timestamp(), \u0026previous_hash, \u0026data);\n        Self {\n            id,\n            hash,\n            timestamp: now.timestamp(),\n            previous_hash,\n            data,\n            nonce,\n        }\n    }\n}\n```\n\n# 해시 계산 (calculate_hash 함수)\n\n\n\n`calculate_hash` 함수는 블록의 해시를 생성합니다. 이 함수는 블록의 속성을 JSON 객체로 만들고 이 데이터를 해시하기 위해 SHA-256 알고리즘을 사용합니다. 이 함수는 블록체인의 무결성을 보장하는 데 중요합니다.\n\n```rust\nfn calculate_hash(id: u64, timestamp: i64, previous_hash: \u0026str, data: \u0026str, nonce: u64) -\u003e Vec\u003cu8\u003e {\n    let data = serde_json::json!({\n        \"id\": id,\n        \"previous_hash\": previous_hash,\n        \"data\": data,\n        \"timestamp\": timestamp,\n        \"nonce\": nonce\n    });\n    let mut hasher = Sha256::new();\n    hasher.update(data.to_string().as_bytes());\n    hasher.finalize().as_slice().to_owned()\n}\n```\n\n## 채굴 (mine_block 함수)\n\n`mine_block`은 작업 증명 알고리즘이 구현된 곳입니다. 이 함수는 nonce 값을 반복하여 특정 접두사(난이도 접두사로 정의됨)로 시작하는 해시를 찾으려고 시도합니다. 유효한 해시가 발견되면 함수는 nonce와 해당 해시를 반환합니다.\n\n\n\n```rust\nfn mine_block(id: u64, timestamp: i64, previous_hash: \u0026str, data: \u0026str) -\u003e (u64, String) {\n    info!(\"블록 채굴 중...\");\n    let mut nonce = 0;\n\n    loop {\n        if nonce % 100000 == 0 {\n            info!(\"논스: {}\", nonce);\n        }\n        let hash = calculate_hash(id, timestamp, previous_hash, data, nonce);\n        let binary_hash = hash_to_binary_representation(\u0026hash);\n        if binary_hash.starts_with(DIFFICULTY_PREFIX) {\n            info!(\n                \"채굴 성공! 논스: {}, 해시: {}, 이진 해시: {}\",\n                nonce,\n                hex::encode(\u0026hash),\n                binary_hash\n            );\n            return (nonce, hex::encode(hash));\n        }\n        nonce += 1;\n    }\n}\n```\n\n# 이진 해시 표현 (hash_to_binary_representation 함수)\n\n해시를 해당 이진 표현으로 변환하는 함수입니다. 이는 채굴 과정에서 해시가 난이도 조건을 충족하는지 확인하는 데 사용됩니다.\n\n```rust\nfn hash_to_binary_representation(hash: \u0026[u8]) -\u003e String {\n    let mut res: String = String::default();\n    for c in hash {\n        res.push_str(\u0026format!(\"{:b}\", c));\n    }\n    res\n}\n```\n\n\n\n# 제네시스 블록 (genesis 함수)\n\n이 함수는 블록체인에서 첫 번째 블록을 생성하는 함수로, 제네시스 블록이라고 알려져 있습니다. 이 블록은 수동으로 블록체인에 추가됩니다.\n\n```rust\nimpl App {\n    fn new() -\u003e Self {\n        Self { blocks: vec![] }\n    }\n\n    fn genesis(\u0026mut self) {\n        let genesis_block = Block {\n            id: 0,\n            timestamp: Utc::now().timestamp(),\n            previous_hash: String::from(\"genesis\"),\n            data: String::from(\"genesis!\"),\n            nonce: 2836,\n            hash: \"0000f816a87f806bb0073dcf026a64fb40c946b5abee2573702828694d5b4c43\".to_string(),\n        };\n        self.blocks.push(genesis_block);\n    }\n```\n\n# 블록 추가하기 (try_add_block 함수)\n\n\n\n`try_add_block` 함수는 블록체인에 새로운 블록을 추가하려고 시도합니다. 먼저, 새로운 블록을 최신 블록과 검증합니다. 새로운 블록이 유효하면 체인에 추가됩니다.\n\n```rust\nfn try_add_block(\u0026mut self, block: Block) {\n    let latest_block = self.blocks.last().expect(\"there is at least one block\");\n    if self.is_block_valid(\u0026block, latest_block) {\n        self.blocks.push(block);\n    } else {\n        error!(\"could not add block - invalid\");\n    }\n}\n```\n\n## 블록 유효성 검사 (is_block_valid 함수)\n\n이 함수는 이전 블록에 대해 블록을 유효성 검사합니다. 다음을 확인합니다:\n\n\n\n- 이전 해시 필드는 이전 블록의 해시와 일치합니다.\n- 해시 난이도 수준이 올바릅니다.\n- 블록 ID가 이전 블록의 ID를 따릅니다.\n- 블록 해시가 유효합니다.\n\n```rust\nfn is_block_valid(\u0026self, block: \u0026Block, previous_block: \u0026Block) -\u003e bool {\n    if block.previous_hash != previous_block.hash {\n        warn!(\"블록 ID가 {}인 블록은 잘못된 이전 해시를 가지고 있습니다.\", block.id);\n        return false;\n    } else if !hash_to_binary_representation(\n        \u0026hex::decode(\u0026block.hash).expect(\"16진수로 디코딩할 수 있어야 합니다.\"),\n    )\n        .starts_with(DIFFICULTY_PREFIX)\n    {\n        warn!(\"블록 ID가 {}인 블록은 유효하지 않은 난이도를 가지고 있습니다.\", block.id);\n        return false;\n    } else if block.id != previous_block.id + 1 {\n        warn!(\n            \"블록 ID가 {}인 블록은 최신 블록 이후의 다음 블록이 아닙니다: {}\",\n            block.id, previous_block.id\n        );\n        return false;\n    } else if hex::encode(calculate_hash(\n        block.id,\n        block.timestamp,\n        \u0026block.previous_hash,\n        \u0026block.data,\n        block.nonce,\n    )) != block.hash\n    {\n        warn!(\"블록 ID가 {}인 블록은 유효하지 않은 해시를 가지고 있습니다.\", block.id);\n        return false;\n    }\n    true\n}\n```\n\n# 체인 유효성 검사 (is_chain_valid 함수)\n\nis_chain_valid는 전체 블록 체인의 유효성을 검사합니다. 블록체인이 일관적이고 유효한 상태를 유지하는 데 사용됩니다.\n\n\n\n```rust\nfn is_chain_valid(\u0026self, chain: \u0026[Block]) -\u003e bool {\n    for i in 0..chain.len() {\n        if i == 0 {\n            continue;\n        }\n        let first = chain.get(i - 1).expect(\"has to exist\");\n        let second = chain.get(i).expect(\"has to exist\");\n        if !self.is_block_valid(second, first) {\n            return false;\n        }\n    }\n    true\n}\n```\n\n# 체인 선택 (choose_chain 함수)\n\n이 함수는 블록체인의 여러 버전이 충돌하는 경우 해결하는 데 사용됩니다. 항상 가장 긴 유효한 체인을 선택합니다.\n\n```rust\n// 항상 가장 긴 유효한 체인을 선택합니다\nfn choose_chain(\u0026mut self, local: Vec\u003cBlock\u003e, remote: Vec\u003cBlock\u003e) -\u003e Vec\u003cBlock\u003e {\n    let is_local_valid = self.is_chain_valid(\u0026local);\n    let is_remote_valid = self.is_chain_valid(\u0026remote);\n\n    if is_local_valid \u0026\u0026 is_remote_valid {\n        if local.len() \u003e= remote.len() {\n            local\n        } else {\n            remote\n        }\n    } else if is_remote_valid \u0026\u0026 !is_local_valid {\n        remote\n    } else if !is_remote_valid \u0026\u0026 is_local_valid {\n        local\n    } else {\n        panic!(\"로컬 및 원격 체인이 모두 유효하지 않습니다\");\n    }\n}\n```\n\n\n\n# 메인 기능 및 블록체인 네트워킹\n\n주요 기능은 블록체인 애플리케이션의 네트워킹 및 이벤트 처리 부분을 설정합니다. 토키오(tokio)와 립투피(libp2p) 라이브러리를 사용하여 피어 간 상호 작용을 관리하며, 체인 요청 및 사용자 입력 처리와 같은 이벤트에 응답합니다.\n\n```rust\n#[tokio::main]\nasync fn main() {\n    pretty_env_logger::init();\n\n    info!(\"Peer Id: {}\", blockchain::PEER_ID.clone());\n    let (response_sender, mut response_rcv) = mpsc::unbounded_channel();\n    let (init_sender, mut init_rcv) = mpsc::unbounded_channel();\n\n    let auth_keys = Keypair::\u003cX25519Spec\u003e::new()\n        .into_authentic(\u0026blockchain::KEYS)\n        .expect(\"can create auth keys\");\n\n    let transp = TokioTcpConfig::new()\n        .upgrade(upgrade::Version::V1)\n        .authenticate(NoiseConfig::xx(auth_keys).into_authenticated())\n        .multiplex(mplex::MplexConfig::new())\n        .boxed();\n\n    let behaviour = blockchain::AppBehaviour::new(App::new(), response_sender, init_sender.clone()).await;\n\n    let mut swarm = SwarmBuilder::new(transp, behaviour, *blockchain::PEER_ID)\n        .executor(Box::new(|fut| {\n            spawn(fut);\n        }))\n        .build();\n\n    let mut stdin = BufReader::new(stdin()).lines();\n\n    Swarm::listen_on(\n        \u0026mut swarm,\n        \"/ip4/0.0.0.0/tcp/0\"\n            .parse()\n            .expect(\"can get a local socket\"),\n    )\n        .expect(\"swarm can be started\");\n\n    spawn(async move {\n        sleep(Duration::from_secs(1)).await;\n        info!(\"sending init event\");\n        init_sender.send(true).expect(\"can send init event\");\n    });\n\n    loop {\n        let evt = {\n            select! {\n                line = stdin.next_line() =\u003e Some(blockchain::EventType::Input(line.expect(\"can get line\").expect(\"can read line from stdin\"))),\n                response = response_rcv.recv() =\u003e {\n                    Some(blockchain::EventType::LocalChainResponse(response.expect(\"response exists\")))\n                },\n                _init = init_rcv.recv() =\u003e {\n                    Some(blockchain::EventType::Init)\n                }\n                event = swarm.select_next_some() =\u003e {\n                    info!(\"Unhandled Swarm Event: {:?}\", event);\n                    None\n                },\n            }\n        };\n\n        if let Some(event) = evt {\n            match event {\n                blockchain::EventType::Init =\u003e {\n                    let peers = blockchain::get_list_peers(\u0026swarm);\n                    swarm.behaviour_mut().app.genesis();\n\n                    info!(\"connected nodes: {}\", peers.len());\n                    if !peers.is_empty() {\n                        let req = blockchain::LocalChainRequest {\n                            from_peer_id: peers\n                                .iter()\n                                .last()\n                                .expect(\"at least one peer\")\n                                .to_string(),\n                        };\n\n                        let json = serde_json::to_string(\u0026req).expect(\"can jsonify request\");\n                        swarm\n                            .behaviour_mut()\n                            .floodsub\n                            .publish(blockchain::CHAIN_TOPIC.clone(), json.as_bytes());\n                    }\n                }\n                blockchain::EventType::LocalChainResponse(resp) =\u003e {\n                    let json = serde_json::to_string(\u0026resp).expect(\"can jsonify response\");\n                    swarm\n                        .behaviour_mut()\n                        .floodsub\n                        .publish(blockchain::CHAIN_TOPIC.clone(), json.as_bytes());\n                }\n                blockchain::EventType::Input(line) =\u003e match line.as_str() {\n                    \"ls p\" =\u003e blockchain::handle_print_peers(\u0026swarm),\n                    cmd if cmd.starts_with(\"ls c\") =\u003e blockchain::handle_print_chain(\u0026swarm),\n                    cmd if cmd.starts_with(\"create b\") =\u003e blockchain::handle_create_block(cmd, \u0026mut swarm),\n                    _ =\u003e error!(\"unknown command\"),\n                },\n            }\n        }\n    }\n}\n```\n\n와우, 이것 참 많이네요!\n\n\n\n내 GitHub 저장소에서 완전한 구현을 찾을 수 있어요: [루스티체인](https://github.com/luishsr/rustychain).\n\n## 블록체인 테스트\n\nRust로 제공된 블록체인 구현을 사용하고 테스트하려면 환경 설정, 노드 시작 및 상호 작용하는 일련의 단계를 따라야 해요. 시작하는 데 도움이 되는 빠른 가이드를 제공할게요:\n\n## 단일 노드 실행\n\n\n\n- **컴파일 및 실행**: Rust 블록체인 코드가 있는 디렉토리로 이동한 후 cargo build를 사용하여 프로젝트를 컴파일합니다. 성공적인 컴파일이 완료되면 cargo run을 사용하여 노드를 실행합니다.\n- **초기 테스트**: 처음에는 제네시스 블록이 올바르게 생성되고 노드가 제대로 시작되는지 확인하기 위해 단일 노드로 테스트합니다. 만약 구현되어 있다면 현재 체인이나 노드 상태를 표시하는 명령을 사용할 수 있습니다.\n\n# 여러 노드 실행하기\n\n실제 블록체인 네트워크를 시뮬레이션하려면 여러 노드를 동시에 실행해야 합니다.\n\n- **여러 터미널 열기**: 여러 터미널 창 또는 탭을열어주세요. 각각은 네트워크에서 별개의 노드를 나타냅니다.\n- **독립적으로 노드 실행**: 각 터미널에서 프로젝트 디렉토리로 이동하고 cargo run을 실행합니다. 각 인스턴스는 블록체인 네트워크의 별개 노드로 동작하게 됩니다.\n\n\n\n# 노드와 상호작용하기\n\n블록체인의 기능을 테스트하려면 노드와 상호작용해야 합니다.\n\n- 새 블록 생성: 구현된 명령어(예: `data`를 이용한 `create b`)를 사용하여 새 블록을 생성하세요. 이는 블록체인에 거래나 데이터 추가를 시뮬레이션할 것입니다.\n- 블록 전파: 한 노드에서 새 블록이 생성되면 이 블록을 다른 노드에 전파해야 합니다. 다른 노드가 이 새 블록을 수신하고 유효성을 검사하여 자신의 블록체인 버전에 추가하는지 확인하세요.\n- 블록체인 상태 보기: 정기적으로 각 노드의 블록체인 현재 상태를 출력하는 명령어를 사용하세요. 노드 간에 일관성이 있어야하며 최신 유효 블록을 반영해야 합니다.\n- 체인 충돌 테스트: 서로 다른 노드에서 동시에 다른 블록을 생성하여 체인 충돌을 시뮬레이트하세요. 구현이 이러한 충돌을 해결하는 방식(일반적으로 가장 긴 유효 체인을 선택함)을 관찰하세요.\n\n# 🚀 루이스 소아레스에 의한 소프트웨어 개발 및 기타 다양한 리소스 탐색하기\n\n\n\n📚 학습 플랫폼: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅, 사이버 보안, 블록체인, 리눅스 등 다양한 기술 분야에서 지식을 넓히세요. 저의 포괄적인 자료 모음을 통해:\n\n- GitHub 리포지토리와 함께 하는 실습 튜토리얼: 전용 GitHub 리포지토리를 통해 단계별 실습을 통해 다양한 기술을 실용적으로 익힐 수 있습니다. [튜토리얼 접근하기](링크)\n- 심층 안내서 및 기사: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅 등의 핵심 개념을 자세히 다룬 안내서와 실제 예제가 풍부한 기사로 깊게 파보세요. [더 읽기](링크)\n- 전자책 모음집: \"러스트 소유권 마스터하기\" 및 \"애플리케이션 보안 안내서\"와 같은 제목을 포함한 무료 전자책 시리즈로 다양한 기술 분야의 이해를 향상시키세요. [전자책 다운로드](링크)\n- 프로젝트 쇼케이스: API 게이트웨이, 블록체인 네트워크, 사이버 보안 도구, 클라우드 서비스 등과 같이 다양한 분야의 완전 기능 프로젝트를 발견하세요. [프로젝트 보기](링크)\n- LinkedIn 뉴스레터: LinkedIn에서 제 뉴스레터를 구독하여 러스트, 소프트웨어 개발 및 신흥 기술에 관한 규칙적인 업데이트와 통찰력을 유지하세요. [여기서 구독하기](링크)\n\n🔗 저와 연결해보세요:\n\n- Medium: 미디엄에서 제 글을 읽고 유용하다고 생각하면 박수를 보내주세요. 이는 저에게 글쓰기와 러스트 콘텐츠 공유를 계속 이끌어주는 원동력이 됩니다. [Medium 팔로우하기](링크)\n- 개인 블로그: 제 개인 블로그에서 더 많은 러스트 관련 콘텐츠를 확인하세요. [블로그 방문하기](링크)\n- LinkedIn: 더 많은 통찰력 있는 토론과 업데이트를 위해 제 전문 네트워크에 참여하세요. [LinkedIn 연결하기](링크)\n- 트위터: 빠른 업데이트와 러스트 프로그래밍에 대한 생각을 보려면 트위터에서 저를 팔로우하세요. [트위터에서 팔로우하기](링크)\n\n\n\nWassup, folks? Feel free to leave a comment or shoot me a message!\n\nCheers,\n\nLuis Soares\n[luis.soares@linux.com](mailto:luis.soares@linux.com)\n\nSenior Software Engineer | Cloud Engineer | SRE | Tech Lead | Rust | Golang | Java | ML AI \u0026 Statistics | Web3 \u0026 Blockchain","ogImage":{"url":"/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png"},"coverImage":"/assets/img/2024-05-05-ImplementingaBlockchaininRust_0.png","tag":["Tech"],"readingTime":23},{"title":"만타 에어드랍이 진행 중입니다 청구하는 방법에 대한 빠른 안내입니다","description":"","date":"2024-05-05 17:32","slug":"2024-05-05-MantaAirdropisLiveQuickGuidehowtoClaim","content":"\n\n![Manta Airdrop](/assets/img/2024-05-05-MantaAirdropisLiveQuickGuidehowtoClaim_0.png)\n\n암호화폐 생태계에서 화려한 벤처, Manta 에어드랍은 자격을 갖춘 회원들 사이에서 MANTA 토큰을 분배하는 것을 목표로 합니다. 이 블로그 섹션에서는 등록 기간, 수령 절차 및 자격 기준을 포함한 이 이벤트의 주요 세부 정보를 설명합니다. 이 독특한 제안은 쉬운 작업을 수행하여 지지자들이 무료 암호화폐 자산을 얻을 수 있도록 합니다. MANTA의 일부를 지금 청구하지 않고는 놓치지 마세요!\n\nMANTA 토큰을 청구하는 것은 간단한 과정입니다. 참가자는 공식 지침에 명시된 방법을 따라야 합니다. 단계별 설명은 각 단계를 안내하여 원활한 청구 과정이 이뤄지도록 합니다.\n\n# MANTA 에어드랍에 대해\n\n\n\n참여 요건은 Manta 에어드랍에 참여하기 위해 꼭 해야 하는 사항입니다. 모든 사용자는 에어드랍 자격을 획득하기 위해 이러한 기준을 충족해야 합니다. 세부 내용은 일반적으로 일정 토큰을 소유하고 Manta Network에 지속적으로 참여하는 것을 포함합니다. 이러한 사전 요구 사항을 깊이 이해하는 것이 중요합니다. 이를 통해 사용자가 무료 토큰의 일부를 받을 수 있도록 할 수 있습니다.\n\n# MANTA 에어드랍 단계별 안내서\n\n크립토 에어드랍을 청구하는 것은 바다에서 보물을 발견하는 것과 같습니다. 아래 지침을 따르세요:\n\n![MantaAirdropisLiveQuickGuidehowtoClaim_1](/assets/img/2024-05-05-MantaAirdropisLiveQuickGuidehowtoClaim_1.png)\n\n\n\nManta 공식 에어드랍 포털에 방문해주세요.\n\n당신의 지갑을 에어드랍 포털에 연결해주세요.\n\n\"자격 확인\" 버튼을 누르고 확인이 완료될 때까지 잠시 기다려주세요.\n\n자격이 확인되면 \"받기\" 버튼이 활성화됩니다.\n\n\n\n\"‘받기(Get)’를 클릭하고 요청된 확인 작업을 완료하세요.\n\n지갑에서 이체를 확인하여 토큰을 받아보세요.\n\n인내심이 필요할 수 있어요; 토큰 분배에는 시간이 걸릴 수 있습니다.\n\n- $MANTA를 청구하세요\"\n\n\n\n좋은 일했어요! 쉬운 100–500달러가 당신을 기다리고 있어요! 제게 지지를 보내고 박수를 보내고 팔로우해주세요. 감사합니다!\n\n## MANTA 토큰 스테이킹\n\nMANTA 토큰을 스테이킹하는 것은 암호화폐 수익을 최적화하는 주요 전략 중 하나입니다. Manta 생태계에서, 스테이커들은 자신의 토큰을 스테이킹하는 대신 인센티브를 획득합니다. 이러한 인센티브는 더 많은 MANTA 토큰으로 제공되며, 이로 인해 암호화폐 보유량이 상당히 증가합니다.\n\n## 에어드롭 후의 거래 전략\n\n\n\n에어드랍 후 거래 전략은 암호화폐 수익을 더욱 최대화할 수 있습니다. 시장 변동성을 최대한 활용하기 위해 올바른 매수 및 매도 주문을 시간에 맞추는 것이 중요합니다. 시장 트렌드를 추적하고 기술적 분석을 활용하며 균형있는 투자 포트폴리오를 유지하는 것이 핵심입니다.\n\n# 대체 투자 기회\n\nMANTA 스테이킹 및 거래를 넘어, Manta 생태계 내에서 다양한 투자 기회를 찾을 수 있습니다. 이러한 기회는 자산 풀에 참여하거나 협력 플랫폼의 제품을 조사하는 것을 포함합니다. 이러한 대안은 수익을 창출할 가능성을 제공하며 포트폴리오를 확장하고 리스크를 줄이는 가능한 경로를 제공합니다.","ogImage":{"url":"/assets/img/2024-05-05-MantaAirdropisLiveQuickGuidehowtoClaim_0.png"},"coverImage":"/assets/img/2024-05-05-MantaAirdropisLiveQuickGuidehowtoClaim_0.png","tag":["Tech"],"readingTime":2},{"title":"비트스마일리 포인트 시스템인 비트포인트를 소개합니다","description":"","date":"2024-05-05 17:31","slug":"2024-05-05-IntroducingbitPointthebitSmileyPointSystem","content":"\n\n**bitPoint**은 프로토콜 내 참여를 통해 사용자에게 제공되는 토큰 에어드랍 보상입니다. 사용자들은 다양한 활동을 통해 포인트를 획득할 수 있으며, 각 시즌의 끝에 포인트가 집계되어 자동으로 보상으로 전환되며, 그 후 초기화됩니다.\n\n프리시즌은 2024년 5월 1일에 시작되어 2024년 5월 11일에 마감될 예정입니다. 이 기간 동안 사용자들은 bitlayer에서 bitUSD를 생성하거나 bitCow에서 지정된 거래 페어에 대한 유동성을 제공함으로써 포인트를 획들할 수 있습니다(예: bitUSD-USDT/bitUSD-WBTC). 프리시즌 종료시, 총 bitSmiley 토큰 공급의 1%가 사용자들 사이에서 포인트에 기반하여 분배될 것입니다.\n\n다음은 프리시즌에 대한 구체적인 규정입니다:\n\n포인트 획득 방법 및 계산 공식:\n\n\n\n(a) bitUSD 발행하기\n\n- Mint 포인트 = 발행된 bitUSD * 3\n\n(b) bitCow에서 유동성 제공하기\n\n- Add 포인트 = bitUSD로 제공된 유동성 * 4\n\n\n\nTeam Bonus: 사용자들은 초대 코드를 사용하여 팀을 만들거나 가입할 수 있으며, 팀 포인트에 따라 순위가 매겨집니다. 전체 포인트가 높은 팀에 가입하면 개인 포인트가 크게 증가하며, 아래 표에 나와 있습니다:\n\n![Team Bonus Table](/assets/img/2024-05-05-IntroducingbitPointthebitSmileyPointSystem_0.png)\n\n* 그룹에 가입하기 전에 획득한 모든 팀 보너스는 개인 포인트 보너스에 기여하지 않습니다.\n\nbit-Disc 스테이킹 보너스: bitSmiley 웹사이트에서 M-bitDisc를 스테이킹하고 EVM 월렛 주소를 연결한 사용자들은 아래에 설명된 대로 추가 보상을 받게 됩니다.\n\n\n\n![Introducing BitPoint: the BitSmiley Point System](/assets/img/2024-05-05-IntroducingbitPointthebitSmileyPointSystem_1.png)\n\nTo sum it up, individual BitDisc points bonuses will be revised at the end of the pre-season based on user activities from previous days to determine points.\n\nFor AA wallet users, we strongly suggest using your EVM wallet to engage with the BitPoint system during this pre-season. If you have restaked M-bitDisc-Black with your AA wallet, please link your AA wallet with your EVM wallet before the pre-season concludes to receive your restaking bonus points.\n\nThe formula for calculating total points is as follows:\n\n\n\n포인트 Per day는 (포인트 Mint + 포인트 Add) * (1 + 개별 bitDisc 포인트 보너스) * (1 + 개별 팀 포인트 보너스)와 같이 계산됩니다.\n\n예를 들어, 사용자가 10,000 bitUSD를 Mint하고 5,000 bitUSD를 유동성 추가하며, 3 개의 bitDisc 토큰을 스테이킹하고, 가입한 팀이 총 포인트 기준 상위 5%에 속한다면, 그들의 하루 총 포인트는 다음과 같이 계산됩니다:\n\n포인트 총합 = (10,000 * 3 + 5,000 * 4) * (1 + 5%) * (1 + 10%)\n\n만약 사용자의 팀 순위가 다음 날 8%로 떨어지고, 사용자가 추가로 2개의 bitDisc-Black을 스테이킹한다면, 사용자의 총 포인트는 다음과 같을 것입니다:\n\n\n\nTo calculate this formula, we first determine the value of the expressions within parentheses:\n\n1. \\( 10,000 \\times 3 + 5,000 \\times 4 = 30,000 + 20,000 = 50,000 \\)\n2. \\( 10,000 \\times 3 + 5,000 \\times 4 + 5,000 \\times 1.5 = 30,000 + 20,000 + 7,500 = 57,500 \\)\n\nNext, we apply the percentages:\n\n1. For the first expression: \\( 50,000 \\times 1.05 \\times 1.10 = 58,575 \\)\n2. For the second expression: \\( 57,500 \\times 1.08 \\times 1.08 = 69,954 \\)\n\nFinally, we sum the two results:\n\n\\( 58,575 + 69,954 = 128,529 \\)\n\nTherefore, the total point value is 128,529.","ogImage":{"url":"/assets/img/2024-05-05-IntroducingbitPointthebitSmileyPointSystem_0.png"},"coverImage":"/assets/img/2024-05-05-IntroducingbitPointthebitSmileyPointSystem_0.png","tag":["Tech"],"readingTime":3},{"title":"루스트로 웹 3 NFT API를 구현하기","description":"","date":"2024-05-05 17:27","slug":"2024-05-05-ImplementingaWeb3NFTAPIinRust","content":"\n\n![ImplementingaWeb3NFTAPIinRust](/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png)\n\n안녕하세요 러스테이션 분들! 🦀\n\n오늘의 글에서는 이더리움 블록체인을 활용하여 NFT를 발행하는 Rust API를 구현해 보겠습니다. 또한 IPFS와의 분산 파일 저장소 통합, 그리고 솔리디티를 사용한 스마트 계약 구현도 다룰 예정이에요.\n\n이 글을 마치면 swagger-ui를 사용하여 API와 상호 작용할 수 있게 되며, Web3, RESTful Rust API, 이더리움 블록체인, 그리고 솔리디티를 사용한 스마트 계약을 어떻게 통합하는지에 대한 기본 지식을 습득할 수 있을 거예요.\n\n\n\n기대하시는 대로, 러스트 NFT API에 대한 이 깊은 탐험은 정보가 풍부하고 흥미로울 것입니다. 다만 일반적으로 쓰는 글보다 조금 더 길어져서 죄송합니다. 보다 실용적인 접근을 선호하시거나 코드를 더 탐구하고 싶어하는 분들을 위해 좋은 소식이 있어요!\n\n🚀 프로젝트를 실행하고 자세히 살펴볼 수 있는 전체 코드베이스와 단계별 지침을 https://github.com/luishsr/rust-nft-api GitHub 저장소에 깔끔하게 정리해 놨습니다. 언제든지 참여하셔서 즐거운 코딩하세요!\n\n바로 시작해봅시다!\n\n# 프로젝트 구조 개요\n\n\n\n프로젝트는 다음과 같이 구성되어 있습니다:\n\n\nrust-nft-api/\n├── contract/\n│   └── MyNFT.sol\n├── nft-images/\n│   └── token.jpg\n├── src/\n│   ├── main.rs\n│   ├── error.rs\n│   ├── ipfs.rs\n│   ├── model.rs\n│   ├── utils.rs\n│   └── web3client.rs\n├── static/\n│   └── swagger-ui/\n├── .env\n└── Cargo.toml\n```\n\n- contract/: NFT에 대한 Solidity 스마트 계약(MyNFT.sol)을 포함하며, NFT의 발행 및 전송 규칙을 정의합니다.\n- nft-images/: 각 NFT와 관련된 이미지 또는 자산을 저장하며, NFT 메타데이터에서 참조됩니다.\n- src/: 러스트 파일이 있는 소스 디렉토리이며, API 기능에서 특정 목적을 제공합니다:\n  - main.rs: API의 진입점으로 서버 및 라우트 설정을 수행합니다.\n  - error.rs: API에 대한 사용자 지정 오류 처리를 정의합니다.\n  - ipfs.rs: IPFS와 상호 작용하여 오프체인 메타데이터를 저장합니다.\n  - model.rs: API에서 사용되는 데이터 모델을 정의하며, NFT 및 메타데이터 구조를 포함합니다.\n  - utils.rs: 프로젝트 전체에서 사용되는 유틸리티 함수를 포함합니다.\n  - web3client.rs: Web3를 사용하여 이더리움 블록체인과의 통신을 관리합니다.\n- static/: API 문서화를 위한 Swagger UI와 같은 정적 파일을 포함합니다.\n- .env: API 키 및 블록체인 노드 URL과 같은 환경 변수를 관리하는 dotenv 파일입니다.\n- Cargo.toml: 의존성 및 프로젝트 정보를 나열하는 러스트 패키지 매니페스트 파일입니다.\n\n# 주요 구성 요소 및 기능\n\n\n\n# 스마트 계약 (MyNFT.sol)\n\n이 스마트 계약은 Solidity로 작성되어 이더리움 블록체인에 배포되었습니다. ERC-721 표준에 따라 NFT의 발행, 이전 및 관리 규칙을 정의합니다. 이는 이더리움에서 NFT에 널리 사용되는 표준입니다.\n\n# IPFS 통합 (ipfs.rs)\n\nIPFS 또는 InterPlanetary File System은 NFT의 오프체인 메타데이터를 저장하는 데 사용됩니다. 이를 통해 이미지와 설명 정보를 포함한 메타데이터가 분산화되고 위변조되지 않음을 보장합니다. ipfs.rs 모듈은 IPFS로부터 메타데이터를 업로드하고 검색하는 작업을 처리합니다.\n\n\n\n# 웹3 클라이언트 (web3client.rs)\n\n이 모듈은 Web3 라이브러리를 사용하여 이더리움 블록체인에 연결을 설정합니다. 블록체인과 상호 작용하도록 API를 활성화하여 NFT 발행, NFT 세부 정보 검색 및 블록체인 이벤트 수신과 같은 작업을 수행할 수 있습니다.\n\n# API 엔드포인트 (main.rs)\n\nmain.rs 파일은 RESTful API 서버를 설정하고 NFT 생성, 토큰 ID로 NFT 세부 정보 가져오기 및 모든 NFT 나열과 같은 다양한 엔드포인트에 대한 경로를 정의합니다. Actix-web 프레임워크를 사용하여 HTTP 요청과 응답을 처리합니다.\n\n\n\n# 에러 처리 및 유틸리티 (error.rs, utils.rs)\n\n강력한 API를 위해서 적절한 에러 처리가 중요합니다. error.rs 모듈은 사용자 정의 에러 유형과 처리 메커니즘을 정의하여 클라이언트에게 명확하고 유용한 오류 메시지가 반환되도록 보장합니다. utils.rs 모듈에는 데이터 유효성 검증 및 형식 지원과 같은 API 내에서 다양한 작업을 지원하는 유틸리티 함수가 포함되어 있습니다.\n\n# 단계 1. 스마트 계약 구현\n\nSolidity로 개발된 MyNFT 계약은 안전한 블록체인 개발을 위한 표준 라이브러리인 OpenZeppelin의 ERC721URIStorage 계약을 확장합니다. 이는 NFT 소유권을 표현하는 인기있는 표준인 ERC721 프로토콜을 활용하며 NFT에 URI 기반 메타데이터를 연결하는 기능을 추가합니다.\n\n\n\n## 주요 구성 요소\n\n- 토큰 카운터: OpenZeppelin의 Counters 유틸리티를 활용하여 발행된 각 NFT에 대한 고유 식별자를 유지합니다.\n- 토큰 세부 정보 구조: 각 NFT에 대한 중요 정보인 ID, 이름, 소유자 및 관련 URI를 보유하는 TokenDetails 구조체를 정의합니다.\n- 매핑: 세 가지 주요 매핑이 사용되어 NFT 소유권 및 세부 정보를 추적합니다:\n  - _tokenDetails는 각 토큰 ID를 해당 TokenDetails로 매핑합니다.\n  - _ownedTokens는 소유자 주소를 소유한 토큰 ID 목록으로 매핑합니다.\n  - _ownedTokensIndex는 토큰 ID를 소유자의 토큰 목록에서의 위치로 매핑합니다.\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract MyNFT is ERC721URIStorage {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    struct TokenDetails {\n        uint256 tokenId;\n        string tokenName;\n        address tokenOwner;\n        string tokenURI;\n    }\n\n    mapping(uint256 =\u003e TokenDetails) private _tokenDetails;\n    mapping(address =\u003e uint256[]) private _ownedTokens;\n    mapping(uint256 =\u003e uint256) private _ownedTokensIndex;  // 토큰 ID를 소유자의 토큰 목록에서의 위치로 매핑합니다\n\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    function mintNFT(address recipient, string memory tokenName, string memory tokenURI) public returns (uint256) {\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _mint(recipient, newItemId);\n        _setTokenURI(newItemId, tokenURI);\n\n        _tokenDetails[newItemId] = TokenDetails({\n            tokenId: newItemId,\n            tokenName: tokenName,\n            tokenOwner: recipient,\n            tokenURI: tokenURI\n        });\n\n        _addTokenToOwnerEnumeration(recipient, newItemId);\n\n        return newItemId;\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokens[to].push(tokenId);\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length - 1;\n    }\n\n    function getAllTokensByOwner(address owner) public view returns (uint256[] memory) {\n        if (owner == address(0)) {\n            uint256 totalTokens = _tokenIds.current();\n            uint256[] memory allTokenIds = new uint256[](totalTokens);\n            for (uint256 i = 0; i \u003c totalTokens; i++) {\n                allTokenIds[i] = i + 1;  // 토큰 ID는 발행 방식에 따라 1부터 시작합니다\n            }\n            return allTokenIds;\n        } else {\n            return _ownedTokens[owner];\n        }\n    }\n\n    function getTokenDetails(uint256 tokenId) public view returns (uint256, string memory, address, string memory) {\n        require(_ownerOf(tokenId) != address(0), \"ERC721: 존재하지 않는 토큰에 대한 조회\");\n\n        TokenDetails memory tokenDetail = _tokenDetails[tokenId];\n        return (tokenDetail.tokenId, tokenDetail.tokenName, tokenDetail.tokenOwner, tokenDetail.tokenURI);\n    }\n}\n```\n\n# 단계 2. Web3Client 작성하기\n\n\n\nThe `web3client.rs` file includes the implementation of the `Web3Client` struct, responsible for enabling interactions with smart contracts on the Ethereum network through the Rust programming language. Let's explore the main features of this implementation.\n\n## Web3Client Structure\n\nThe `Web3Client` struct comprises two primary fields:\n\n- `web3`: An object of the `Web3` type, establishing a link to an Ethereum node.\n- `contract`: A `Contract` instance, representing the smart contract on the Ethereum blockchain that the API will engage with.\n\n\n\n## 구현 세부 사항\n\n- 새로운 함수: 이것은 Web3Client 구조체를 위한 생성자입니다. 제공된 스마트 계약 주소로 새 Web3 인스턴스 및 새 Contract 인스턴스를 초기화합니다.\n- 이더리움 노드 연결: ETH_NODE_URL 환경 변수로 지정된 이더리움 노드에 HTTP 연결을 설정합니다. 이 연결은 이더리움 블록체인으로 트랜잭션을 보내거나 호출하는 데 필수적입니다.\n- 스마트 계약 ABI: Rust 애플리케이션이 계약과 상호 작용하는 방법을 이해하는 데 스마트 계약의 ABI(응용 프로그램 이진 인터페이스)가 필요합니다. ABI는 CONTRACT_ABI_PATH 환경 변수로 지정된 파일에서 로드됩니다. 해당 ABI 파일은 일반적으로 스마트 계약이 컴파일될 때 Solidity 컴파일러에 의해 생성됩니다.\n- 계약 초기화: ABI 및 스마트 계약 주소를 사용하여 새 Contract 인스턴스가 생성됩니다. 이 인스턴스를 사용하면 Rust 애플리케이션이 스마트 계약의 함수를 호출하거나 해당에서 발생한 이벤트를 수신하고 상태를 쿼리할 수 있습니다.\n\n```rust\nuse std::env;\nuse std::error::Error;\nuse web3::contract::Contract;\nuse web3::transports::Http;\nuse web3::{ethabi, Web3};\n\npub struct Web3Client {\n    pub web3: Web3\u003cHttp\u003e,\n    pub contract: Contract\u003cHttp\u003e,\n}\n\nimpl Web3Client {\n    pub fn new(contract_address: \u0026str) -\u003e Result\u003cSelf, Box\u003cdyn Error\u003e\u003e {\n        let http = Http::new(\u0026env::var(\"ETH_NODE_URL\")?)?;\n        let web3 = Web3::new(http);\n\n        let contract_abi_path = env::var(\"CONTRACT_ABI_PATH\")?;\n        let contract_abi_file = std::fs::File::open(contract_abi_path)?;\n        let contract_abi: ethabi::Contract = serde_json::from_reader(contract_abi_file)?;\n\n        let contract = Contract::new(web3.eth(), contract_address.parse()?, contract_abi);\n\n        Ok(Web3Client { web3, contract })\n    }\n}\n```\n\n# 단계 3. 데이터 구조\n\n\n\n안녕하세요! 오늘은 Rust NFT API 프로젝트 내 모델.rs 파일에 대해 이야기해보려고 해요.\n\n해당 파일은 Rust의 강력한 타입 시스템을 이용하여 주요 데이터 구조를 정의하며, serde를 통한 직렬화 기능과 utoipa의 API 문서화 기능을 결합하고 있어요.\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse utoipa::Component;\n\n#[derive(Serialize, Deserialize, Component)]\npub struct MintNftRequest {\n    pub(crate) owner_address: String,\n    pub(crate) token_name: String,\n    pub(crate) token_uri: String,\n    pub(crate) file_path: String,\n}\n\n#[derive(Serialize, Deserialize, Component)]\npub struct TokenFileForm {\n    file: Vec\u003cu8\u003e,\n}\n\n#[derive(Serialize, Deserialize, Component)]\npub struct ApiResponse {\n    pub(crate) success: bool,\n    pub(crate) message: String,\n    pub(crate) token_uri: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, Component)]\npub struct NftMetadata {\n    pub(crate) token_id: String,\n    pub(crate) owner_address: String,\n    pub(crate) token_name: String,\n    pub(crate) token_uri: String,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct UploadResponse {\n    token_uri: String,\n}\n```\n\n## MintNftRequest\n\n이 구조는 새로운 NFT를 발행하기 위한 요청 본문을 나타냅니다. 소유자 주소, 토큰 이름, 토큰 URI(해당 NFT와 관련된 메타데이터 또는 자산을 가리킴), 그리고 NFT와 연결할 자산의 파일 경로에 대한 필드를 포함하고 있어요. pub (crate)의 사용은 이들 필드가 크레이트 내에서 접근 가능하게 만듭니다.\n\n더 궁금한 점이 있으면 언제든지 물어보세요! 😊\n\n\n\n# TokenFileForm\n\nTokenFileForm은 파일 업로드 양식의 데이터 구조를 정의합니다. 특히 NFT와 관련된 파일을 업로드하기 위한 것입니다. 파일 필드는 업로드되는 파일의 바이너리 내용을 나타내는 'Vec u8'의 바이트 벡터입니다.\n\n## ApiResponse\n\n다양한 API 작업의 결과를 전달하는 데 사용할 수 있는 일반적인 API 응답 구조입니다. 작업이 성공했는지를 나타내는 성공 플래그, 추가 정보 또는 오류 세부 정보를 제공하는 메시지, 그리고 NFT가 관련된 작업에서 특히 중요한 옵션인 token_uri가 포함되어 있습니다. 여기서는 NFT의 메타데이터 또는 자산을 가리키는 URI가 반환될 수 있습니다.\n\n\n\n## NftMetadata\n\nNFT와 관련된 메타데이터를 나타냅니다. 토큰 ID, 소유자 주소, 토큰 이름 및 토큰 URI가 포함되어 있습니다. 이 모델은 NFT 세부 정보를 검색하거나 표시하는 작업에 중요합니다.\n\n## UploadResponse\n\n파일 업로드 작업에 특별히 맞춘 이 모델은 업로드 작업의 응답을 캡처하며 주로 업로드된 파일의 토큰 URI를 포함합니다. 이 URI는 그 후 민팅 프로세스나 업로드된 자산을 연결하는 데 필요한 다른 목적에 사용할 수 있습니다.\n\n\n\n# 단계 4. IPFS와 인터페이스\n\n러스트 NFT API 프로젝트 내 ipfs.rs 모듈은 InterPlanetary File System (IPFS)와의 상호 작용을 처리하는 데 전념합니다. IPFS는 분산형 저장 솔루션으로, 오프 체인 NFT 메타데이터나 자산을 저장하는 데 중요한 역할을 합니다.\n\n```rust\nuse crate::model::ApiResponse;\nuse axum::Json;\nuse reqwest::Client;\nuse serde_json::Value;\nuse std::convert::Infallible;\nuse std::env;\nuse tokio::fs::File;\nuse tokio::io::AsyncReadExt;\n\npub async fn file_upload(file_name: String) -\u003e Result\u003cJson\u003cApiResponse\u003e, Infallible\u003e {\n    let client = Client::new();\n    let ipfs_api_endpoint = \"http://127.0.0.1:5001/api/v0/add\";\n\n    // 현재 디렉토리 가져오기\n    let mut path = env::current_dir().expect(\"Failed to get current directory\");\n    // 경로에 'nft-images' 하위 디렉토리 추가\n    path.push(\"nft-images\");\n    // 파일 이름을 경로에 추가\n    path.push(file_name);\n\n    //println!(\"Full path: {}\", path.display());\n\n    // 파일을 비동기적으로 열기\n    let mut file = File::open(path.clone()).await.expect(\"Failed to open file\");\n\n    // 파일 바이트 읽기\n    let mut file_bytes = Vec::new();\n    file.read_to_end(\u0026mut file_bytes)\n        .await\n        .expect(\"Failed to read file bytes\");\n\n    // 경로에서 파일 이름 추출\n    let file_name = path\n        .file_name()\n        .unwrap()\n        .to_str()\n        .unwrap_or_default()\n        .to_string();\n\n    let form = reqwest::multipart::Form::new().part(\n        \"file\",\n        reqwest::multipart::Part::stream(file_bytes).file_name(file_name),\n    );\n\n    let response = client\n        .post(ipfs_api_endpoint)\n        .multipart(form)\n        .send()\n        .await\n        .expect(\"Failed to send file to IPFS\");\n\n    if response.status().is_success() {\n        let response_body = response\n            .text()\n            .await\n            .expect(\"Failed to read response body as text\");\n\n        let ipfs_response: Value =\n            serde_json::from_str(\u0026response_body).expect(\"Failed to parse IPFS response\");\n        let ipfs_hash = format!(\n            \"https://ipfs.io/ipfs/{}\",\n            ipfs_response[\"Hash\"].as_str().unwrap_or_default()\n        );\n\n        Ok(Json(ApiResponse {\n            success: true,\n            message: \"File uploaded to IPFS successfully.\".to_string(),\n            token_uri: Some(ipfs_hash),\n        }))\n    } else {\n        Ok(Json(ApiResponse {\n            success: false,\n            message: \"IPFS upload failed.\".to_string(),\n            token_uri: None,\n        }))\n    }\n}\n```\n\n처리 흐름\n\n\n\n### 초기 설정:\nReqwest로 HTTP 요청을 보내기 위해 Client 인스턴스가 생성됩니다.\n\n### 파일 경로 구성:\n해당 함수는 현재 작업 디렉토리, nft-images 하위 디렉토리 및 제공된 파일 이름을 결합하여 파일 경로를 구성합니다.\n\n### 파일 읽기:\n지정된 파일을 비동기적으로 열고 읽어서 해당 바이트를 벡터로 수집합니다.\n\n### 폼 준비:\n파일 바이트를 포함하는 멀티파트 폼을 준비하고, 파일 이름을 폼 데이터의 일부로 사용합니다.\n\n\n\n**IPFS API 요청:** IPFS 노드의 add 엔드포인트 (/api/v0/add)로 멀티파트 폼을 전송하는 POST 요청을 보냅니다.\n\n**응답 처리:**\n\n- 성공 시, IPFS 응답을 구문 분석하여 파일의 IPFS 해시를 추출하고, 해당 파일을 IPFS 게이트웨이를 통해 액세스할 수 있는 URL을 구성한 후, 이 URL이 포함된 성공적인 ApiResponse를 생성합니다.\n- 실패 시, 업로드 실패를 나타내는 ApiResponse를 생성합니다.\n\n**단계 5. 에러 처리**\n\n\n\n에러.rs 파일은 응용 프로그램 작동 중 발생할 수 있는 다양한 에러 유형을 정의하고 관리하는 데 전념되어 있습니다. 이 모듈은 사용자 정의 에러 유형을 정의하는 데 thiserror 크레이트를 사용하고 이러한 에러를 적절한 HTTP 응답으로 매핑하는 axum 프레임워크를 사용합니다. 이 파일 내에서 에러 처리가 어떻게 구조화되어 있는지 살펴보겠습니다:\n\n```rust\nuse axum::{\n    http::StatusCode,\n    response::{IntoResponse, Response},\n    Json,\n};\nuse serde_json::json;\nuse thiserror::Error;\n\n// `thiserror`를 사용하여 사용자 정의 응용 프로그램 에러 유형 정의\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"잘못된 요청: {0}\")]\n    BadRequest(String),\n\n    #[error(\"내부 서버 에러: {0}\")]\n    InternalServerError(String),\n\n    #[error(\"Web3 에러: {0}\")]\n    Web3Error(#[from] web3::Error),\n\n    #[error(\"직렬화 에러: {0}\")]\n    SerdeError(#[from] serde_json::Error),\n\n    #[error(\"내부 에러: {0}\")]\n    GenericError(String),\n\n    #[error(\"스마트 컨트랙트 에러: {0}\")]\n    NotFound(String),\n}\n\nimpl From\u003cBox\u003cdyn std::error::Error\u003e\u003e for AppError {\n    fn from(err: Box\u003cdyn std::error::Error\u003e) -\u003e Self {\n        AppError::GenericError(format!(\"오류가 발생했습니다: {}\", err))\n    }\n}\n\n// `AppError`를 `IntoResponse`에 구현하여 HTTP 응답으로 변환\nimpl IntoResponse for AppError {\n    fn into_response(self) -\u003e Response {\n        let (status, error_message) = match \u0026self {\n            AppError::BadRequest(message) =\u003e (StatusCode::BAD_REQUEST, message.clone()),\n            AppError::InternalServerError(message) =\u003e {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.clone())\n            }\n            AppError::Web3Error(message) =\u003e {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.to_string())\n            }\n            AppError::SerdeError(message) =\u003e {\n                (StatusCode::INTERNAL_SERVER_ERROR, message.to_string())\n            }\n            AppError::GenericError(message) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, message.clone()),\n            AppError::NotFound(message) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, message.clone()),\n        };\n\n        let body = Json(json!({ \"error\": error_message })).into_response();\n        (status, body).into_response()\n    }\n}\n\n// 파일 업로드 에러를 처리하기 위한 사용자 정의 UploadError 유형\n#[derive(Error, Debug)]\npub enum UploadError {\n    #[error(\"IO 에러: {0}\")]\n    IoError(#[from] std::io::Error),\n}\n\n#[derive(Error, Debug)]\npub enum SignatureError {\n    #[error(\"Hex 디코딩 에러: {0}\")]\n    HexDecodeError(#[from] hex::FromHexError),\n}\n\nimpl From\u003cSignatureError\u003e for AppError {\n    fn from(err: SignatureError) -\u003e AppError {\n        match err {\n            SignatureError::HexDecodeError(_) =\u003e {\n                AppError::BadRequest(\"잘못된 hex 형식\".to_string())\n            }\n        }\n    }\n}\n\n// `UploadError`를 `IntoResponse`에 구현하여 HTTP 응답으로 변환\nimpl IntoResponse for UploadError {\n    fn into_response(self) -\u003e Response {\n        let (status, error_message) = match self {\n            UploadError::IoError(_) =\u003e (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                \"내부 서버 에러\".to_string(),\n            ),\n        };\n\n        let body = Json(json!({ \"error\": error_message })).into_response();\n        (status, body).into_response()\n    }\n}\n```\n\n## 사용자 정의 응용 프로그램 에러 유형\n\n- AppError: 응용 프로그램의 주요 에러 유형으로, 잘못된 요청, 내부 서버 에러 및 Web3 상호 작용, 직렬화 문제 및 일반적인 에러와 관련된 특정 에러와 같은 다양한 에러 시나리오를 포괄합니다. AppError의 각 변형은 설명적인 에러 메시지와 함께 에러 응답의 디버깅 및 사용자 친화성을 향상시킵니다.\n- UploadError 및 SignatureError: 이들은 각각 파일 업로드 에러 및 서명 관련 에러를 처리하기 위한 특수화된 에러 유형입니다. AppError와 마찬가지로 다양한 실패 시나리오에 대해 특정 에러 메시지를 제공합니다.\n\n\n\n## 오류 변환\n\n- From 트레이트는 보다 넓은 오류 유형(std::io::Error 및 hex::FromHexError와 같은)에서 구체적인 응용 프로그램 오류(UploadError 및 SignatureError)로의 변환을 허용하기 위해 구현됩니다. 이를 통해 다양한 오류 원천을 잘 정의된 범주로 캡슐화하여 응용 프로그램의 다양한 부분에서 원활한 오류 처리가 가능합니다.\n\n## 오류 응답\n\n- AppError, UploadError 및 SignatureError에 대한 IntoResponse 트레이트 구현은 이러한 오류를 HTTP 응답으로 변환합니다. 오류 유형 및 해당 메시지에 따라 적합한 HTTP 상태 코드(예: StatusCode::BAD_REQUEST 또는 StatusCode::INTERNAL_SERVER_ERROR)가 선택됩니다. 그런 다음 오류 메시지가 JSON 객체로 직렬화되어 API 소비자를 위한 일관된 및 정보 제공이 되는 오류 응답 형식을 제공합니다.\n\n\n\n# Step 6. 유틸리티 함수\n\nutils.rs 모듈은 암호화 방식으로 개인 키를 사용하여 데이터에 서명하는 방법을 보여줍니다. 이 함수는 블록체인 트랜잭션이나 안전한 데이터 교환과 같이 데이터의 신뢰성과 무결성을 확인해야 하는 시나리오에서 특히 유용합니다.\n\n```rust\nuse secp256k1::{Message, Secp256k1, SecretKey};\nuse sha3::{Digest, Keccak256};\nuse std::error::Error;\n\npub fn mock_sign_data(data: \u0026[u8], private_key_hex: \u0026str) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n    // 16진수 개인 키를 디코드합니다\n    let private_key = SecretKey::from_slice(\u0026hex::decode(private_key_hex)?)?;\n\n    // 새로운 Secp256k1 컨텍스트를 생성합니다\n    let secp = Secp256k1::new();\n\n    // Keccak256를 사용하여 데이터 해싱\n    let data_hash = Keccak256::digest(data);\n\n    // 해시에 서명합니다\n    let message = Message::from_digest_slice(\u0026data_hash)?;\n    let signature = secp.sign_ecdsa(\u0026message, \u0026private_key);\n\n    // 서명을 16진수로 인코딩합니다\n    Ok(hex::encode(signature.serialize_compact()))\n}\n```\n\n프로세스:\n\n\n\n### Hex Decoding: \nThe process kicks off with the hex::decode function, which decodes the hexadecimal private key into bytes.\n\n### Private Key Preparation: \nNext up, the decoded bytes are transformed into a SecretKey instance that aligns with the secp256k1 cryptographic library.\n\n### Hashing: \nThe data undergoes hashing through the Keccak256 algorithm, a variation of SHA-3 extensively utilized in Ethereum for hashing operations.\n\n### Signing: \nSubsequently, the hash gets enveloped in a Message type, and the secp256k1 library steps in to sign this message with the designated private key.\n\n\n\n16진수 인코딩: 마지막으로, 서명은 간결한 형식으로 직렬화되어 쉬운 전송과 저장을 위해 16진수 문자열로 인코딩됩니다.\n\n## 암호 라이브러리\n\n- 이 기능은 secp256k1 라이브러리를 활용하여 타원 곡선 암호화를 수행합니다. 이 라이브러리는 이더리움과 비트코인에서 서명 생성 및 확인에 사용되는 secp256k1 곡선을 특별히 지원합니다.\n- sha3 크레이트는 Keccak256 해시 알고리즘의 구현을 제공하여, 데이터 서명 프로세스가 블록체인 기술에서 흔히 사용되는 암호화 관행과 일치함을 보장합니다.\n\n# 단계 7. 핵심 API 구현\n\n\n\n`main.rs` 파일은 Rust NFT API의 진입점 역할을 하며, 다양한 구성 요소를 조정하여 NFT 관리를 위한 포괄적인 백엔드를 제공합니다. 각 코드 섹션별로 설명과 함께 아래와 같이 코드를 살펴보겠습니다:\n\n## OpenAPI 스키마 생성\n\n```rust\n#[derive(utoipa::OpenApi)]\n#[openapi(\n    handlers(process_mint_nft, get_nft_metadata, list_tokens),\n    components(MintNftRequest, NftMetadata)\n)]\nstruct ApiDoc;\n\n// OpenAPI 스키마의 JSON 버전 반환\n#[utoipa::path(\n    get,\n    path = \"/api/openapi.json\",\n    responses(\n        (status = 200, description = \"JSON 파일\", body = Json)\n    )\n)]\nasync fn openapi() -\u003e Json\u003cutoipa::openapi::OpenApi\u003e {\n    Json(ApiDoc::openapi())\n}\n```\n\n이 함수는 JSON 형식으로 OpenAPI 스키마를 생성하며, 개발자들에게 API 엔드포인트, 요청 본문 및 응답의 명확한 명세를 제공합니다. 이는 API 발견 및 상호 작용을 돕는 OpenAPI 문서화를 위해 utoipa 크레이트를 활용합니다.\n\n\n\n## NFT Minting Endpoint\n\n```js\nasync fn process_mint_nft(\n    Extension(web3_client): Extension\u003cArc\u003cWeb3Client\u003e\u003e,\n    Json(payload): Json\u003cMintNftRequest\u003e,\n) -\u003e Result\u003cJson\u003cNftMetadata\u003e, AppError\u003e {\n#[utoipa::path(\npost,\n    path = \"/mint\",\n    request_body = MintNftRequest,\nresponses(\n    (status = 200, description = \"NFT minted successfully\", body = NftMetadata),\n    (status = 400, description = \"Bad Request\"),\n    (status = 500, description = \"Internal Server Error\")\n)\n)]\nasync fn process_mint_nft(\n    Extension(web3_client): Extension\u003cArc\u003cWeb3Client\u003e\u003e,\n    Json(payload): Json\u003cMintNftRequest\u003e,\n) -\u003e Result\u003cJson\u003cNftMetadata\u003e, AppError\u003e {\n    let owner_address = payload\n        .owner_address\n        .parse::\u003cAddress\u003e()\n        .map_err(|_| AppError::BadRequest(\"Invalid owner address\".into()))?;\n\n    // Retrieve the mock private key from environment variables\n    let mock_private_key = env::var(\"MOCK_PRIVATE_KEY\").expect(\"MOCK_PRIVATE_KEY must be set\");\n\n    // Simulate data to be signed\n    let data_to_sign = format!(\"{}:{}\", payload.owner_address, payload.token_name).into_bytes();\n\n    // Perform mock signature\n    let _mock_signature = mock_sign_data(\u0026data_to_sign, \u0026mock_private_key)?;\n\n    let upload_response = match ipfs::file_upload(payload.file_path.clone()).await {\n        Ok(response) =\u003e response,\n        Err(_) =\u003e unreachable!(), // Since Err is Infallible, this branch will never be executed\n    };\n\n    let uploaded_token_uri = upload_response.token_uri.clone().unwrap();\n\n    // Call mint_nft using the file_url as the token_uri\n    let token_id = mint_nft(\n        \u0026web3_client.web3,\n        \u0026web3_client.contract,\n        owner_address,\n        uploaded_token_uri.clone(),\n        payload.token_name.clone(),\n    )\n    .await\n    .map_err(|e| AppError::InternalServerError(format!(\"Failed to mint NFT: {}\", e)))?;\n\n    Ok(Json(NftMetadata {\n        token_id: token_id.to_string(),\n        owner_address: payload.owner_address,\n        token_name: payload.token_name,\n        token_uri: uploaded_token_uri.clone(),\n    }))\n}    \n\n\n}\n```\n\n위 코드는 NFT Minting Endpoint에 대한 내용입니다. 해당 엔드포인트는 새로운 NFT를 발행하는 요청을 처리합니다. MintNftRequest 페이로드를 통해 NFT 소유자의 주소, 토큰 이름 및 파일 경로를 입력받습니다. 이 함수는 모의 서명 작업을 수행하고, 연관된 파일을 IPFS에 업로드하며, 스마트 계약과 상호작용하여 NFT를 발행하고 성공 시 NFT 메타데이터를 반환합니다.\n\n## NFT Metadata Retrieval Endpoint\n\n\n\n```rust\n#[utoipa::path(\nget,\n    path = \"/nft/{token_id}\",\nparams(\n    (\"token_id\" = String, )),\nresponses(\n    (status = 200, description = \"NFT 메타데이터가 성공적으로 검색되었습니다\", body = NftMetadata),\n    (status = 400, description = \"잘못된 요청\"),\n    (status = 500, description = \"내부 서버 오류\")\n)\n)]\nasync fn get_nft_metadata(\n    Extension(web3_client): Extension\u003cArc\u003cWeb3Client\u003e\u003e,\n    Path(token_id): Path\u003cString\u003e,\n) -\u003e Result\u003cJson\u003cNftMetadata\u003e, AppError\u003e {\n    let parsed_token_id = token_id\n        .parse::\u003cU256\u003e()\n        .map_err(|_| AppError::BadRequest(\"잘못된 토큰 ID\".into()))?;\n\n    match get_nft_details(\u0026web3_client.contract, parsed_token_id.to_string()).await {\n        Ok((_, token_name, token_owner, token_uri)) =\u003e {\n            // 토큰을 위한 NftMetadata 구성\n            let nft_metadata = NftMetadata {\n                token_id: parsed_token_id.to_string(),\n                owner_address: format!(\"{:?}\", token_owner),\n                token_name,\n                token_uri,\n            };\n\n            Ok(Json(nft_metadata))\n        }\n        Err(AppError::NotFound(msg)) =\u003e Err(AppError::NotFound(msg)),\n        Err(_) =\u003e Err(AppError::InternalServerError(\n            \"NFT 세부 정보를 검색하는 데 실패했습니다\".into(),\n        )),\n    }\n}\n```\n\n이 엔드포인트는 토큰 ID를 제공받아 해당 NFT의 메타데이터를 검색합니다. 토큰의 이름 및 URI와 같은 세부 정보를 스마트 계약에서 쿼리하여 NFT의 메타데이터를 제공하는 구조화된 응답을 제공합니다.\n\n## NFT 리스트 엔드포인트\n\n```rust\n#[utoipa::path(\nget,\n    path = \"/tokens/{owner_address}\",\nparams(\n    (\"owner_address\" = Option\u003cString\u003e, description = \"토큰을 소유자별로 필터링할 소유자 주소. 모든 토큰을 나열하려면 유형 0을 입력하십시오.\")\n),\nresponses(\n    (status = 200, description = \"토큰 목록이 성공적으로 검색되었습니다\", body = [NftMetadata]),\n    (status = 400, description = \"잘못된 요청\"),\n    (status = 500, description = \"내부 서버 오류\")\n)\n)]\n\nasync fn list_tokens(\n    Extension(web3_client): Extension\u003cArc\u003cWeb3Client\u003e\u003e,\n    token_owner: Option\u003cPath\u003cString\u003e\u003e,\n) -\u003e Result\u003cJson\u003cVec\u003cNftMetadata\u003e\u003e, StatusCode\u003e {\n    let owner_address = match token_owner {\n        Some(ref owner) if owner.0 != \"0\" =\u003e match owner.0.parse::\u003cAddress\u003e() {\n            // 소유자가 \"0\"이 아닌지 확인\n            Ok(addr) =\u003e addr,\n            Err(_) =\u003e return Err(StatusCode::BAD_REQUEST),\n        },\n        _ =\u003e Address::default(), // \"0\" 또는 없음을 모든 토큰을 나열하는 표시로 취급\n    };\n\n    let token_ids =\n        match get_all_owned_tokens(\u0026web3_client.web3, \u0026web3_client.contract, owner_address).await {\n            Ok(ids) =\u003e ids,\n            Err(_) =\u003e return Err(StatusCode::INTERNAL_SERVER_ERROR),\n        };\n\n    let mut nft_metadata_list = Vec::new();\n    for token_id in token_ids {\n        match get_nft_details(\u0026web3_client.contract, token_id.to_string()).await {\n            Ok((_, token_name, _onwer, token_uri)) =\u003e {\n                let nft_metadata = NftMetadata {\n                    token_id: token_id.to_string(),\n                    owner_address: _onwer.to_string(),\n                    token_name,\n                    token_uri,\n                };\n                nft_metadata_list.push(nft_metadata);\n            }\n            Err(e) =\u003e eprintln!(\"토큰 {}에 대한 메타데이터 검색 실패: {:?}\", token_id, e), // 필요에 따라 로그 또는 오류 처리\n        }\n    }\n\n    Ok(Json(nft_metadata_list))\n}\n```\n\n\n\n**list_tokens** 엔드포인트는 특정 주소가 소유한 모든 NFT를 나열하거나 특별한 매개변수가 제공된 경우 모두 발행된 NFT를 나열합니다. 이는 스마트 계약으로 소유한 토큰 ID를 조회하고 각각의 메타데이터를 가져오는 과정을 포함합니다.\n\n## NFT 생성 유틸리티 함수\n\n```rust\n#[utoipa::path(\npost,\n    path = \"/mint\",\n    request_body = MintNftRequest,\nresponses(\n    (status = 200, description = \"NFT가 성공적으로 생성됨\", body = NftMetadata),\n    (status = 400, description = \"잘못된 요청\"),\n    (status = 500, description = \"내부 서버 오류\")\n)\n)]\nasync fn process_mint_nft(\n    Extension(web3_client): Extension\u003cArc\u003cWeb3Client\u003e\u003e,\n    Json(payload): Json\u003cMintNftRequest\u003e,\n) -\u003e Result\u003cJson\u003cNftMetadata\u003e, AppError\u003e {\n    let owner_address = payload\n        .owner_address\n        .parse::\u003cAddress\u003e()\n        .map_err(|_| AppError::BadRequest(\"유효하지 않은 소유자 주소\".into()))?;\n\n    // 환경 변수에서 모의 개인 키 가져오기\n    let mock_private_key = env::var(\"MOCK_PRIVATE_KEY\").expect(\"MOCK_PRIVATE_KEY가 설정되어 있어야 함\");\n\n    // 서명될 데이터 시뮬레이션\n    let data_to_sign = format!(\"{}:{}\", payload.owner_address, payload.token_name).into_bytes();\n\n    // 모의 서명 수행\n    let _mock_signature = mock_sign_data(\u0026data_to_sign, \u0026mock_private_key)?;\n\n    let upload_response = match ipfs::file_upload(payload.file_path.clone()).await {\n        Ok(response) =\u003e response,\n        Err(_) =\u003e unreachable!(), // Err은 Infallible이므로 이 부분은 실행되지 않음\n    };\n\n    let uploaded_token_uri = upload_response.token_uri.clone().unwrap();\n\n    // 파일 URL을 토큰 URI로 사용하여 mint_nft 호출\n    let token_id = mint_nft(\n        \u0026web3_client.web3,\n        \u0026web3_client.contract,\n        owner_address,\n        uploaded_token_uri.clone(),\n        payload.token_name.clone(),\n    )\n    .await\n    .map_err(|e| AppError::InternalServerError(format!(\"NFT 생성 실패: {}\", e)))?;\n\n    Ok(Json(NftMetadata {\n        token_id: token_id.to_string(),\n        owner_address: payload.owner_address,\n        token_name: payload.token_name,\n        token_uri: uploaded_token_uri.clone(),\n    }))\n}\n```\n\n이 유틸리티 함수는 스마트 계약과 상호작용하여 새 NFT를 생성하며, 소유자, 토큰 URI 및 토큰 이름을 지정합니다. 블록체인으로 거래를 구성하고 보내는 세부사항을 캡슐화합니다.\n\n\n\n## 소유한 토큰 검색 유틸리티 함수\n\n```rust\nasync fn get_all_owned_tokens\u003cT: Transport\u003e(\n    _web3: \u0026Web3\u003cT\u003e,\n    contract: \u0026Contract\u003cT\u003e,\n    owner: Address,\n) -\u003e Result\u003cVec\u003cu64\u003e, Box\u003cdyn Error\u003e\u003e {\n    let options = Options::with(|opt| {\n        opt.gas = Some(1_000_000.into());\n    });\n\n    let result: Vec\u003cu64\u003e = contract\n        .query(\"getAllTokensByOwner\", owner, owner, options, None)\n        .await?;\n\n    Ok(result)\n}\n```\n\n이 함수는 지정된 주소가 소유한 토큰 ID 목록을 가져와 사용자가 소유한 NFT 목록을 나열하는 데 도움이 됩니다. 이 함수는 스마트 계약을 쿼리하고 응답을 쉽게 소비할 수 있도록 포맷합니다.\n\n## 서버 초기화 및 라우트 정의\n\n\n\n## 주소 지정 및 들어오는 요청 수신 시작\n\n메인 함수는 Axum 서버를 초기화하며, 정의된 엔드포인트에 대한 경로를 설정하고 CORS와 같은 미들웨어를 구성합니다. 서버를 지정된 주소에 바인딩하고 들어오는 요청을 수신하기 시작합니다.\n\n## 정적 파일 제공 오류 처리\n\n```rust\nasync fn handle_serve_dir_error(error: io::Error) -\u003e (StatusCode, String) {\n    (\n        StatusCode::INTERNAL_SERVER_ERROR,\n        format!(\"정적 파일 제공에 실패했습니다: {}\", error),\n    )\n}\n```\n\n\n\n이 기능은 정적 파일을 제공하는 중에 발생하는 문제를 명확히 보고하는 오류 처리를 제공하여 static/swagger-ui 디렉토리에서 파일을 제공하는 동안 발생하는 문제를 처리합니다.\n\nmain.rs 파일의 각 섹션은 Rust NFT API의 전체 기능에 기여합니다. 엔드포인트 정의 및 요청 처리부터 이더리움 및 IPFS와 상호 작용하여 NFT 응용 프로그램에 강력한 백엔드를 제공합니다.\n\nGitHub 레포를 확인해보세요! 🚀\n\nRust NFT API에 대한 이 깊은 탐구가 유익하고 흥미로웠기를 바랍니다. 우리 일반적인 글보다 조금 더 길어진 것 같아도 감사합니다.\n\n\n\n그 결과에 만족하시는 분들이나 코드를 더 탐구하고 싶은 분들께 좋은 소식이 있어요!\n\n전체 코드베이스 및 프로젝트를 설정하는 단계별 지침을 찾을 수 있는 GitHub 저장소를 소개합니다: [https://github.com/luishsr/rust-nft-api](https://github.com/luishsr/rust-nft-api). 언제든지 참여해보세요. 즐거운 코딩 되세요!\n\n# 🚀 Luis Soares의 더 많은 정보 확인하기\n\n📚 학습 허브: 러스트, 소프트웨어 개발, 클라우드 컴퓨팅, 사이버 보안, 블록체인, 리눅스 등 다양한 기술 분야에서 지식을 확장할 수 있는 광범위한 자료 모음으로 지식을 향상해보세요:\n\n\n\n- GitHub Repos와 함께한 실전 튜토리얼: 단계별 튜토리얼로 다양한 기술에 대한 실용적인 기술을 습득하고 전용 GitHub 리포지토리를 이용하세요. [튜토리얼 확인하기](link)\n- 깊이 있는 안내서 및 기사: Rust, 소프트웨어 개발, 클라우드 컴퓨팅 등 핵심 개념을 자세한 안내서와 실용적인 예시가 가득한 기사로 깊게 들어가 보세요. [더 읽기](link)\n- E-Book 컬렉션: \"Mastering Rust Ownership\"와 \"Application Security Guide\"와 같은 제목의 무료 E-Book 시리즈로 여러 기술 분야에 대한 이해를 높이세요. [E-Book 다운로드](link)\n- 프로젝트 쇼케이스: API 게이트웨이, 블록체인 네트워크, 사이버 보안 도구, 클라우드 서비스 등 다양한 도메인에서 완전히 기능하는 프로젝트를 발견하세요. [프로젝트 보기](link)\n- LinkedIn 뉴스레터: LinkedIn에서 구독하면 Rust, 소프트웨어 개발 및 신생 기술에 대한 정기 업데이트와 통찰을 얻을 수 있습니다. [여기서 구독하기](link)\n\n🔗 나와 소통하기:\n\n- Medium: Medium에서 제가 쓴 기사를 읽고 도움이 됐다면 claps를 주세요. 제게 글쓰고 Rust 콘텐츠를 계속 공유하게 하는 원동력이 됩니다. [Medium 팔로우하기](link)\n- 개인 블로그: 제 개인 블로그에서 더 많은 Rust 관련 콘텐츠를 찾아보세요. [블로그 방문하기](link)\n- LinkedIn: 더 많은 통찰을 얻기 위해 전문 네트워크에 참여하세요. [LinkedIn에서 접속하기](link)\n- Twitter: Rust 프로그래밍에 대한 빠른 업데이트와 생각을 보려면 Twitter로 팔로우하세요. [Twitter 팔로우하기](link)\n\n대화하고 싶으세요? 댓글을 남기거나 메시지를 보내주세요!\n\n\n\n모두 좋은 일 되길 바라며,\n\nLuis Soares  \nluis.soares@linux.com  \n\n시니어 소프트웨어 엔지니어 | 클라우드 엔지니어 | SRE | 기술 리드 | Rust | Golang | Java | ML AI 및 통계 | Web3 \u0026 블록체인","ogImage":{"url":"/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png"},"coverImage":"/assets/img/2024-05-05-ImplementingaWeb3NFTAPIinRust_0.png","tag":["Tech"],"readingTime":29},{"title":"VGX Foundation이 SafeMoon Wallet을 인수했습니다 새로운 장이 시작됩니다","description":"","date":"2024-05-05 17:26","slug":"2024-05-05-VGXFoundationAcquiresSafeMoonWalletANewChapterBegins","content":"\n\n## VGX Foundation은 SafeMoon 월렛의 획기적인 인수를 발표하게 되어 매우 기쁩니다! 이동은 모든 사용자에게 안전하고 사용하기 편리한 경험을 제공하기 위한 우리의 불굴의 약속을 상징합니다.\n\n## SafeMoon 커뮤니티에 대한 깊은 감사\n\n## 우리는 SafeMoon 커뮤니티를 가장 높이 평가합니다. 그들의 열정과 프로젝트에 대한 헌신은 정말로 영감을 주었습니다. 우리는 SafeMoon 월렛과 그 핵심 기능들의 유산을 존중하기로 맹세했습니다. 안심하세요, 친숙한 \"SafeMoon\" 브랜딩은 유지될 것입니다.\n\n## 함께 미래를 만들어가기\n\n\n\n## 우리는 능력 있는 SafeMoon 기술 개발팀과 활발히 협의 중에 있습니다. 그들의 전문지식과 경험은 귀중하며, SafeMoon 지갑을 더 큰 성과로 이끌어낼 수 있는데 중요한 역할을 할 것이라고 강력하게 믿습니다. 우리는 그들을 영입하기 위한 기회를 적극적으로 모색하고 있습니다.\n\n## 투명성과 의사소통\n\n## 명확하고 일관된 의사소통의 중요성을 이해합니다. SafeMoon 지갑의 미래를 신중히 계획하는 단계에 있지만, 우리는 지속적으로 커뮤니티에 최신 정보를 전하고자 약속합니다. 우리는 업데이트와 발전 상황을 공유할 것이며, 모두가 이 흥미진진한 여정을 함께할 수 있도록 최선을 다하겠습니다.\n\n## SafeMoon 지갑의 미래를 함께 설계하는 여정에서 계속해서 발표되는 소식을 기대해 주세요!","ogImage":{"url":"/assets/img/2024-05-05-VGXFoundationAcquiresSafeMoonWalletANewChapterBegins_0.png"},"coverImage":"/assets/img/2024-05-05-VGXFoundationAcquiresSafeMoonWalletANewChapterBegins_0.png","tag":["Tech"],"readingTime":1},{"title":"당신의 키 아닌 당신의 영혼","description":"","date":"2024-05-05 17:24","slug":"2024-05-05-NotYourKeysNotYourSoul","content":"\n\n## 계속되고 있는 온라인 신원 위기\n\n지난 달, Resonance Security의 Charles Dray가 WiKey의 CEO 인 Ofir Paz와 나 사이에 대화를 조장했습니다. 우리는 신원 및 접근 관리 (IAM) 및 온라인 인증에서 직면한 문제에 대해 이야기했습니다. 이 기사는 그 대화의 결과물입니다.\n\n# 소개\n\n웹에는 신원 문제가 있습니다. 대부분의 경우, 우리는 인증을 위해 60년이 넘은 시스템을 사용하고 있습니다 - 사용자 이름과 비밀번호; MIT 컴퓨터 과학 교수 인 Fernando Corbato에 의해 1961 년 만들어진 디지털 인증 방법입니다.\n\n\n\n![/assets/img/2024-05-05-NotYourKeysNotYourSoul_0.png](/assets/img/2024-05-05-NotYourKeysNotYourSoul_0.png)\n\n이후로 이 간단한 시스템의 문제를 해결하기 위해 다양한 기능을 추가로 제안해 왔습니다. 더 견고하고 긴 암호를 저장하는 비밀번호 관리자, 문자 또는 이메일을 통한 확인 코드, 30초마다 새로운 코드를 생성하는 인증기 앱, 그리고 공개/비공개 키 암호화(비대칭 키 암호화)의 사용 등이 있습니다.\n\n이 중 후자에 대해 이 글에서 다루겠지만, 그에 앞서 한 가지 질문에 대한 해답이 필요합니다.\n\n# 인증이란 무엇인가요?\n\n\n\n인증은 한 당사자가 상대방이 이전에 대화를 나눈 상대방과 동일한 사람이 맞는지 확인하는 프로세스를 말합니다.\n\n그리고 인증은 중요한데, 외부 서버에서 다른 사람이 당신을 가장했다고 생각한다면 당신과 관련된 중요한 정보에 접근할 수 있고, 그 정보를 변경할 수도 있기 때문입니다. 그래서 당신만이 자신으로서 서버에 로그인할 수 있는 것이 중요합니다.\n\n예를 들어, 파일 서버에서는 기밀 및 자산 정보, 의료 정보 또는 금융 정보를 보유할 수 있습니다. 만약 잘못된 사람이 당신처럼 로그인하면, 그들은 회사의 비밀 발명품 및 비즈니스 계획을 열람하거나 당신의 건강 기록을 볼 수도 있습니다. 또한 개인 사진을 다운로드할 수도 있습니다.\n\n서버가 사용자가 자신의 신원을 기반으로 조치를 취할 수 있도록 허용한다면, 당신으로 로그인하는 해커가 당신처럼 로그인한다면 파일을 삭제하거나 전체 사용자 계정을 삭제하고 자금을 이체하여 다양한 문제를 일으킬 수도 있습니다.\n\n\n\n몇 일 전, 내 아들이 Minecraft 계정과 Roblox 계정을 잃었어요. 그 이유는 암호로 대문자 이름을 사용했기 때문이에요. 저는 암호 안전성에 대해 년 전에 그에게 강의했음에도 불구하고 말이죠. 어떤 악당이 그가 사용한 것을 추측해내어 내 아들로 위장하고 로그인하여 그의 계정을 삭제해버리면서 몇 년 동안의 게임 기록을 망가뜨렸어요.\n\n만약 내 아들이 사용자 이름과 암호보다 나은 인증 방법을 사용했고, Minecraft와 Roblox가 그에게 그렇게 하도록 요구했다면 어땠을까요...\n\n# 비대칭 키 암호화가 구해줬어요\n\n1995년 핀란드 연구자 타투 위든은 \"보안 셸\"(SSH)을 만들었어요. 이는 인증 과정에 공개 키 암호화를 사용하여 다른 종류의 인증을 적용해요. 이를 올바르게 사용하면 공개 키 암호화를 통해 다른 유형의 인증이 적용됩니다.\n\n\n\n![NotYourKeysNotYourSoul_1.png](/assets/img/2024-05-05-NotYourKeysNotYourSoul_1.png)\n\n로그인 프로세스에 대한 비유를 들어보겠습니다:\n\n일단 서버에 손글씨 서명 부분을 제공하여 시작한다고 상상해보세요. 그 손글씨는 당신만이 만들어낼 수 있는 것입니다. 이것으로 계정이 만들어집니다.\n\n그리고 로그인할 때마다 서버는 도전 과제를 제시합니다. 그것은 임의의 숫자가 적힌 종이 조각이나 현재 날짜와 시간이 적힌 것 등입니다.\n\n\n\n우선, 서버로 요청을 보내면 서버는 고유한 도전 과제를 당신의 개인 키로 디지턈 서명을 하여 서버로 다시 보냅니다. 그런 다음 서버는 서명이 유효하고 서명 내의 공개 키가 서버가 보유한 공개 키와 일치하는지 확인합니다. 만약 일치하는 경우에는 당신은 로그인됩니다.\n\n기술적 설명은 다음과 같습니다:\n\n컴퓨터에서 공개/비공개 키 쌍을 생성하고 공개 키를 액세스하려는 서버와 공유합니다. 일반적으로 서버의 관리자는 공개 키가 본인 것임을 확인하기 위해 이메일, 안전한 메시지, 전화 또는 심지어 직접적인 방법 등의 비전송 채널을 통해 검사합니다.\n\n그러면 서버에 공개 키를 다시 보내 로그인을 식별합니다. 그 후 서버가 고유한 도전 과제를 다시 보내면 이를 당신의 비공개 키로 디지턈 서명을 한 다음 디지턈 서명을 서버로 보냅니다. 그 후 서버는 서명이 유효하고 서명 내의 공개 키가 서버가 저장한 공개 키와 일치하는지 확인합니다. 만약 일치한다면 로그인됩니다.\n\n\n\n# 얼마나 일반적인가요?\n\n웹2에서는 FIDO2 \"무암호\" 인증에서 하드웨어 장치인 USB 동글이나 Bluetooth 또는 NFC를 통해 컴퓨터에 연결되는 폰 앱과 같은 장치가 키 생성 및 도전에 대한 서명을 처리하는 공개/비공개 키 도전/응답 방법을 사용합니다. \"개인 키 보유 및 공개 키 공유 및 도전/응답 서명\"의 조합을 \"패스키 사용\"이라고 합니다.\n\n웹3에서는 블록체인 지갑을 사용하여 로그인할 때 동일한 메커니즘을 사용합니다. 왜냐하면 MetaMask와 같은 브라우저 확장 프로그램 또는 Trezor 또는 Ledger와 같은 하드웨어 지갑도 공개/비공개 키 쌍을 생성하고 디지털로 서명할 수 있기 때문입니다.\n\n사용자(또는 더 자주 사용자가 구입한 장치)가 개인 키를 안전하게 보관한다면, 공개/비공개 키 도전/응답 방법은 견고하고 신뢰할 수 있는 인증을 위해 우리가 가지고 있는 가장 안전한 시스템일 것입니다.\n\n\n\n그것이 개발자들이 종종 간과하는 문제입니다. 개인 키나 그것이 저장된 장치를 분실하면, 당신은 자신의 신원을 잃게 됩니다.\n\n![Identity loss](/assets/img/2024-05-05-NotYourKeysNotYourSoul_2.png)\n\n# 신원 분실\n\n모든 사람들은 어느 순간에 무언가를 잃어버렸습니다. 차 열쇠를 잃어버린 적이 있거나, 해변에 안경을 두고 온 적이 있거나, 쇼핑하다가 핸드폰을 도난당한 적이 있거나, 호텔 서랍에 여권을 두고 온 적이 있습니다. 저 역시 코르푸 섬에서 일주일을 보낸 동안 그랬었습니다.\n\n\n\n계정 로그인 보안을 확보하는 것이 중요하지만 사용자가 필수적으로 로그인에 필요한 것을 잃을 때의 복구 전략이 더 중요할 수도 있습니다.\n\nFIDO2를 사용하는 웹사이트에서 Google이나 Apple 솔루션을 이용해 계정을 등록하면 개인 키가 Google 클라우드나 iCloud에 백업되어, 개인 키가 타사 서버에 저장됩니다. 패스워드 해시 데이터베이스가 해커들에 의해 도난당하고 무차별 대입 공격을 받을 위험 대신, 개인 키가 추출될 위험이 있습니다.\n\n이 회사들이 여러분의 개인 키를 잘 관리할 지 여부는 미지수입니다. 모든 회사가 결국 해킹을 당하는 것이 사실이고, 회사들이 관리자의 보안 절차와 보안 인증 보고서 세부 정보를 공개하지 않기 때문에 그들이 얼마나 성실하고 능력이 있는지, 그리고 정직한지에 대해 우리는 전혀 알 수 없습니다.\n\n# 그리고 ID 복구\n\n\n\n이번 섹션에서는 핵심 회수 및 교체를 제공하기 위한 탈중앙화 방법론에 대해 이야기하겠습니다 (의미: 실리콘밸리의 기술 거물이 운영하지 않음). 이것은 일반적인 토론이며, 개요된 솔루션을 안전하고 보안성 있는 것으로 만들기 위해 극복해야 할 많은 기술적 도전과 예외 사례가 있습니다. 그러나 원칙은 거기에 있습니다.\n\n기업 클라우드에 개인 키를 저장하는 것이 현명하지 않다면, 다른 옵션은 무엇이 있을까요? 역설적으로 말하면, 해결책은 여기 남아 있다는 것을 입증한 누구도 소유하지 않은 탈중앙화 시스템에 저장하는 것입니다. 예를 들어, 비트코인이나 이더리움과 같은 공개 허가 없는 블록체인입니다.\n\n물론, 당신의 키를 누구나 가져가서 당신을 가장할 수 있는 곳에 공개로 올릴 수는 없습니다. 친구에게 그것을 먼저 그들의 공개 키로 암호화해달라고 부탁해보는 건 어떤가요? 그렇게 함으로써, 만약 당신이 그것을 잃어버리고 돌려받아야 할 때, 그들이 그것을 회수하고 복호화할 수 있지만, 당신의 친구 이외의 누구도 개인 키를 손에 넣을 수 없습니다.\n\n이것은 당신이 디지털 삶을 신뢰할 수 있는 친구 하나가 있어야만 가능합니다. 다중 당사자 계산 (MPC) 키 회수를 소개합니다:\n\n\n\n친구들과 신뢰하는 동료들에게 키를 여러 부분으로 나누어 주고, \"N 중 M\" 조합 중 어떠한 조합이라도 키를 복원할 수 있도록 합니다.\n\n예를 들어, 키를 다섯 부분으로 나누어 맡기면 그 중에서 세 부분을 사용해 전체 키를 재구성할 수 있게 됩니다. 이렇게 하면 다섯 명 중 두 명이 믿을만하지 않다고 판명되어도, 개인 키와 디지털 신원은 안전하게 지켜집니다. 키를 분실하여 복구가 필요한 경우 세 명 이상의 친구가 여전히 주변에 있고 정직하다면, 키 백업을 할 수 있습니다.\n\n[이미지: 2024-05-05-NotYourKeysNotYourSoul_3.png]\n\n키를 나누는 것은 해적보물지도를 분리하는 것만큼 간단하지 않습니다 – 약간의 은폐가 사용됩니다. 그렇지 않으면 어린이 모험 소설을 읽어본 적이 있는 사람이라면, 두 세부분이 충분하여 나머지를 추론할 수도 있음을 아시겠죠.\n\n\n\n친구들이나 동료들이 당신의 비밀 키를 재조합하여 음모를 꾸릴 수 없도록 합니다. 복구 프로세스가 시작되면 사용자에게 알림이 전달되어 복구(또는 이권을 행사) 프로세스를 중지할 수 있습니다. 친구들이나 복구 도우미들이 할 수 있는 유일한 기능은 당신이 이전과 동일한 사람이 맞다는 것을 입증하는 것입니다. 키는 블록체인의 많은 관련 없는 유효성 검사자들 사이에 분할되고 암호화되기 때문에 그중 아무도 개인적으로 그것에 접근할 수 없습니다: 당신도, 당신의 친구도, 중앙 집중식 시스템도요.\n\n물론 다른 많은 부분들이 존재합니다: 훼손된 키를 취소하고 새로운 대체품을 승인하는 방법 등이 있지만, 이들은 이 기사의 범위를 벗어납니다.\n\n# 연합 신원\n\n기업들에게 온라인 신원을 관리하도록 의존하는 위험을 살펴보았지만, 조사할 가치가 있는 추가적인 위험 요인이 하나 더 있습니다:\n\n\n\n하나의 제공업체에 자신의 신원을 묶는 것 또는 \"연합 신원 검열\" 문제에 대해 알아보았습니다. \"Google/Facebook/LinkedIn을 사용하여 로그인\" 버튼을 통해 여러 온라인 서비스에 계정을 만들고 로그인하면 의존하는 신원 제공업체가 계정을 차단하거나 취소하기만 하면 절대적으로 모든 것에 액세스할 수 없게 됩니다.\n\n예를 들어, 몇 주 전에 LinkedIn에서 실수로 내 코멘트에 \"Bitcoin\"이라는 단어를 사용했기 때문에 계정이 차단되었습니다. 결과적으로 내가 선호하는 특허 검색 데이터베이스에 로그인할 수 없었습니다.\n\n연합 신원 관리는 기업에 자신의 영혼을 팔아넘기는 게 아니라, 자유롭게 제공하는 것입니다.\n\n# 결론\n\n\n\n세계는 드디어 디지털 아이덴티티를 진지하게 받아들이기 시작했습니다. 블록체인 세계에서는 자주 인용되는 몇 가지 말들이 있습니다. 이를 온라인 세계 전반에 더 널리 적용해야 할 필요가 있습니다. 첫 번째 말은 다음과 같습니다:\n\n이에 대한 주의사항은 의무적으로 의존하는 시스템이 투명한 경우에만 확인할 수 있다는 점입니다. 일반적으로 기업은 주주의 이익을 당신의 이전에 우선시하는 것으로 법적으로 요구됩니다.\n\n두 번째 말은:\n\n이것은 간단합니다. 암호화폐에서 키를 소유하지 않는다는 것은 코인을 소유하지 않는다는 것이고, 자신의 신원을 키를 제공한다는 것이 당신이 자기 자신을 얼마나 존중하는지를 나타냅니다.\n\n\n\n이 두 가지 핵심 포인트는 시간이 흐름에 따라 기업들이 제공하는 서비스와의 상호 운용성을 유지하면서 온라인 신원을 직접 관리하는 것이 점점 더 중요해질 것이라는 이유입니다.\n\n# 저자 소개\n\n저는 Keir Finlow-Bates로 더 알려진 블록체인 간단도프입니다. 주로 블록체인 연구자이자 발명가입니다. 2010년 후반에 원래 비트코인 코드를 조사하면서 이 여정을 시작했고, 그때부터 계속해서 블록체인에 귀를 기울였습니다.\n\n![Not Your Keys, Not Your Soul](/assets/img/2024-05-05-NotYourKeysNotYourSoul_4.png)\n\n\n\n나는 블록체인을 설명하는 'Move Over Brokers Here Comes The Blockchain'과 웹3 사기가 어떻게 작동하는지 실제 예시를 통해 설명하는 'Evil Tokenomics'이라는 주제의 두 권의 책도 저술했습니다.\n\n더 많은 정보는 제 웹사이트에서 확인할 수 있어요: [thinklair.com](https://thinklair.com)\n\n# Resonance Security 소개\n\nResonance Security는 종단 간 사이버 보안 제품 및 서비스를 소개하는 신중하게 선별된 플랫폼입니다. 우리는 귀하의 조직의 종단 간 사이버 보안 요구 사항을 위한 컨시어지 역할을하며, 가치 있는 보안 제공 요소를 한 플랫폼에 집약시켜 귀하의 기술 스택을 종단 간으로 안전하게 보호하는 데 필요한 것을 알리는 것을 목표로 합니다.\n\n\n\n우리 플랫폼과 보안 인증팀은 다음을 다룹니다: 침투 테스트, 스마트 계약 감사, 블록체인 시스템 및 web3 감사, DevSecOps, 그리고 클라우드 보안.\n\n더 많은 정보가 필요하시다면 https://www.resonance.security를 방문해주세요.","ogImage":{"url":"/assets/img/2024-05-05-NotYourKeysNotYourSoul_0.png"},"coverImage":"/assets/img/2024-05-05-NotYourKeysNotYourSoul_0.png","tag":["Tech"],"readingTime":7}],"page":"21","totalPageCount":31,"totalPageGroupCount":2,"lastPageGroup":11,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"21"},"buildId":"BcNXY5smQfBgbhe4ZLNG6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>